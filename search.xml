<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>短链生成器</title>
      <link href="/posts/%E7%9F%AD%E9%93%BE%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/posts/%E7%9F%AD%E9%93%BE%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用短链"><a href="#为什么要用短链" class="headerlink" title="为什么要用短链"></a>为什么要用短链</h1><ul><li>长度限制<br>  短信、微博等内容长度有限制，若其中连接缩短，则可编辑内容增加，利于节省费用、文案排版等</li><li>便于分享<br>  长链二维码过于密集识别难度大，部分软件平台链接长度有限制，链接太长无法被识别</li></ul><h1 id="短链本质"><a href="#短链本质" class="headerlink" title="短链本质"></a>短链本质</h1><p>链接标识与原链接的一对一映射</p><h1 id="短链跳转的原理"><a href="#短链跳转的原理" class="headerlink" title="短链跳转的原理"></a>短链跳转的原理</h1><ul><li>浏览器请求短链</li><li>后端服务根据短链标识获取原链接</li><li>后端向浏览器返回301或302状态码与原链接<ul><li>301 永久重定向 浏览器请求短链后会缓存原链接，再次请求时则会直接请求原链接，不利于数据统计</li><li>302 临时重定向 浏览器不会缓存原链接，每次请求都会先请求短链，便于统计链接访问数据</li></ul></li><li>浏览器跳转到原链接</li></ul><h1 id="短链标识组成"><a href="#短链标识组成" class="headerlink" title="短链标识组成"></a>短链标识组成</h1><p>短链标识一般由 0-9A-Za-z 62个数字与字母自负组成，若标识长度为6位，则完全容量多达568亿(62^6=56,800,235,584),能够满足绝大部分业务场景</p><h1 id="短链生成"><a href="#短链生成" class="headerlink" title="短链生成"></a>短链生成</h1><ul><li><h2 id="哈希算法（摘要算法）"><a href="#哈希算法（摘要算法）" class="headerlink" title="哈希算法（摘要算法）"></a>哈希算法（摘要算法）</h2><ul><li>选择标准<ul><li>性能高</li><li>碰撞概率小</li></ul></li><li>可选算法<ul><li>非加密算法<ul><li>MurmurHash Google于2008年出品，随机分布特征表现良好，广泛应用于Redis、MemCacheH、Base</li></ul></li><li>加密算法（不推荐）由于需要对数据进行加密，性能远低于非加密算法<ul><li>Md5 消息摘要算法</li><li>SHA 安全散列算法</li></ul></li></ul></li></ul></li><li><h2 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h2><ul><li>UUID(Universally Unique Identifier)<br>  Id较长且无序，插入数据库是会导致频繁的页分裂，影响数据库性能，单一组件不能保证幂等性（<a href="https://blog.csdn.net/baochao95/article/details/61924952" target="_blank" rel="noopener">页分裂</a>）</li></ul></li><li><h2 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h2><p>  一种无碰撞的方法，因为是有序数字，可能存在安全问题</p><ul><li>数据库 自增主键，使用简单，实现方便，可以借助于唯一索引保证幂等性</li><li>Redis 分布式全局唯一自增ID，需要手动实现，适用于分布式系统，单一组件不能保证幂等性</li></ul></li></ul><h1 id="短链存储"><a href="#短链存储" class="headerlink" title="短链存储"></a>短链存储</h1><p>基本数据：原链、短链标识、过期时间、访问次数（如果有需要）</p><ul><li><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>  持久存储，部分数据库拥有自增主键，可以同时实现短链标识的生成和存储工作，性能不及Hbase与Redis</p></li><li><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>MemCache<br>  本地缓存，无法持久化，适用于单机，建议与数据库搭配使用</li><li>Redis<br>  分布式缓存，存在数据过期机制，属于缓存类组件，数据无法持久化，不适用于大量数据存储, 性能较高</li></ul></li><li><h2 id="数据库-缓存"><a href="#数据库-缓存" class="headerlink" title="数据库+缓存"></a>数据库+缓存</h2><p>  在业务量大，高并发的情况下，建议采用以下方案</p><ul><li>数据库作为持久存储，存储所有的短链，保证业务容量</li><li>Redis与MemCache作为两层缓存，弥补数据库性能的不足</li></ul></li></ul><h1 id="Hash算法冲突解决"><a href="#Hash算法冲突解决" class="headerlink" title="Hash算法冲突解决"></a>Hash算法冲突解决</h1><ul><li><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><ul><li>允许冲突存在，长链字段添加唯一索引，最终生成的短链标识可由Hash结果与数据库Id组合而成</li><li>Hash结果作为最后的短链标识，数据库对Hash结果字段做唯一索引，若插入失败则需要在长链中拼接固定标识重新Hash<br>  若存在多次冲突，则需要多次访问数据库，会导致性能下降</li></ul></li><li><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><ul><li>利用布隆过滤器可以有效地去重和解决冲突，但是会有误报<br><a href="https://zhuanlan.zhihu.com/p/43263751" target="_blank" rel="noopener">布隆过滤器</a>是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</li></ul></li></ul><h1 id="幂等性校验"><a href="#幂等性校验" class="headerlink" title="幂等性校验"></a>幂等性校验</h1><p>可以通过对数据表原链接添加唯一索引进行幂等性校验，若短链生成QPS过高的情况下可以将热点数据</p><h1 id="高并发解决方案"><a href="#高并发解决方案" class="headerlink" title="高并发解决方案"></a>高并发解决方案</h1><p>针对高并发的情狂可以使用openResty，它是一个基于 Nginx 与 Lua 的高性能 Web 平台，由于 Nginx 的非阻塞 IO 模型，使用 openResty 可以轻松支持 100 w + 的并发数，同时 openResty 也自带了缓存机制，集成了 redis 这些缓存模块，也可以直接连 mysql，不需要再通过业务层连这些中间件</p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><pre><code>https://github.com/XiaoWeicheng/shorturl</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse Memory Analyzer (MAT) 使用入门</title>
      <link href="/posts/Eclipse-Memory-Analyzer-MAT-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
      <url>/posts/Eclipse-Memory-Analyzer-MAT-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">Eclipse Memory Analyzer (MAT) 下载</a><br>直接解压运行</p><h1 id="生成Dump文件"><a href="#生成Dump文件" class="headerlink" title="生成Dump文件"></a>生成Dump文件</h1><p>jmap -dump:live,format=b,file=[fileName] [javaPid]<br>注意运行命令时请使用运行java进程的user操作，或使用sudo -u [userName]</p><h1 id="打开Dump文件"><a href="#打开Dump文件" class="headerlink" title="打开Dump文件"></a>打开Dump文件</h1><img src="https://xhieug.sn.files.1drv.com/y4mYgZ0A9T0nRTXQ6s_FDEaUu88Qx9_NbolFUTZ5_YWb4Fpyakrsok07L7gNI-O7x0QbleAMs833DQi7K6tPzUcIQRE_t4VZXMDGgQKB5RgwmjUEQUt4RTQpjPCeDpDuGrWCmoIu1l0KOwcYFV4a94vUpiEkdWDX6Unk7TwDli3_mDer_9ByW7AYV3Fw53tZGPFr2CtYe7kGN98vT77zAgz_Q?width=257&height=199&cropmode=none" width="257" height="199"><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><img src="https://xxieug.sn.files.1drv.com/y4mV7z9IED3U2-RuaC77dpA_qaz48SE2AJLRpGFoz4eSjYCGW5tN4cyAhgi_RP9oIqt-v_-PIZJi9-7eUX4g30-_aLLAr35aHwuMNnc_vKz9tlJaUpULP-OSR9x3tr9jHHLzWicjDyd3Tm5Yb-6EvNK3ETo49v_ISx01tVx3XgrC7kPD-H2v6fGc_d7m1z3chDnKwSJ3gGhmDSQ7lNKTfofoQ?width=1920&height=873&cropmode=none" width="1920" height="873"><h1 id="Histogram-直方图"><a href="#Histogram-直方图" class="headerlink" title="Histogram(直方图)"></a>Histogram(直方图)</h1><p>展示内存中所有类的对象个数以及所有对象的大小总和<br><img src="https://x3k5xg.sn.files.1drv.com/y4mY6iHjHwsPi89cJQV8WIp2M9AuaR74_4y_qg-F7UQ_ns_yPF6CF6phpMM-xUncrS4F24_ta6HXw98T2cTaZWKRwCexHL7V1e1Ba8nkPiK517TZYsqebZZaTtY4bQtsvCH1mkjozVUAm10it5oUlXnEzlvUqorETA7-a02MF_PyEl3v-zFmochqNtwq3kVQDmfZPgh6rrRb-QoOO9qoeryNA?width=788&height=720&cropmode=none" width="788" height="720"></p><h1 id="Dominator-Tree-支配树"><a href="#Dominator-Tree-支配树" class="headerlink" title="Dominator Tree(支配树)"></a>Dominator Tree(支配树)</h1><p>展示内存中所有对象的大小以及内存占比<br><img src="https://vxk5xg.sn.files.1drv.com/y4meTmpu-EG8p_Yy2gBa4WFdzI3tX3hqtP63mB0gj2UmRo_rL3hRH1GekAqNfNWB_EwXDdYaQvEittB-zVMnejFhEpBWm8FK_nqnQxZKAVlam8z0Vj_bqVrc6Mb1oXRJ11bg-xiTHpyyujODgRQERGEXJWykFTjIhFJggL7B9fvJrM4kTR5DB9zHoMKj1gY66wQXMZAdOLcx2N4Kg0viLXxSw?width=828&height=715&cropmode=none" width="828" height="715"></p><h1 id="Top-Consumers"><a href="#Top-Consumers" class="headerlink" title="Top Consumers"></a>Top Consumers</h1><p>通过饼图的方式展示内存中所有对象的大小以及内存占比<br><img src="https://w3ieug.sn.files.1drv.com/y4mamX4OtVxRsSSvXbZ8bwLNhAOeP8kE0ES1G8xtANsVFcNkQUVa9_QdAZKt0jiAtGUxuD5uhf7zbK1vzyy4nVdz6cevN115jRUNGzXW9Kr54X1FYPBhTGx6rIx-RrqoBIXfRwquWu25yhd1_fXpYQY0kXveOu2jyxehJ94OH1D-Nkh_faSyv8rcEm-dNUCkhvj19AXNmCpNrDlk-L5cQiotA?width=849&height=696&cropmode=none" width="849" height="696"></p><h1 id="Leak-Suspects"><a href="#Leak-Suspects" class="headerlink" title="Leak Suspects"></a>Leak Suspects</h1><p>MAT内存泄漏分析，可自动分析内存泄漏可疑点<br><img src="https://vhk5xg.sn.files.1drv.com/y4mJs_zt8mOLqv8h0yIPGvGNuxbz5QM-BVSLXB78iJ-7xUedxtjqD_cHhMvMGKTlXYIKCudyRHjyUKvtBGi_tlOK0n7I--Wndi7xuUpnVkr5hH6UKDxad9luVbCTxZrCovEA4EbrlasY0ylM9lYm1-SjVfDKQbiNWevUkJFmujdCy65tZ7OnTkLIcDN-_0q1aOp_93tqOkjX6cfnbzLOmI7SQ?width=865&height=691&cropmode=none" width="865" height="691"></p><h1 id="Thread-Overview"><a href="#Thread-Overview" class="headerlink" title="Thread Overview"></a>Thread Overview</h1><p>展示正在运行中所有的线程基本信息，以及线程栈<br><img src="https://wnieug.sn.files.1drv.com/y4mZvmUw-Sv-TEqzvXGHfzdQFjISqOe_1NWfDDu1FbqmfSPKIAIU_9nyab2qMT3Q3pq_zhsUmx-Zyz8ysv8gWLGm2JY9vuRDiEDNmIKcN2c3whvDD4wYe0oCScPcyK1vwiTP0WG_LIYdGdtUUhCMNGwc7WRbCV8zaDyCO-axO52ChFByCXO3eGmgO95UbpMp4H264vq9eV31LNNtUb-yLmctw?width=1256&height=607&cropmode=none" width="1256" height="607"></p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Shallow-Heap"><a href="#Shallow-Heap" class="headerlink" title="Shallow Heap"></a>Shallow Heap</h2><p>就是对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和;</p><h2 id="Retained-Heap"><a href="#Retained-Heap" class="headerlink" title="Retained Heap"></a>Retained Heap</h2><p>是该对象自己的Shallow Heap，加上从该对象能直接或间接访问到对象的Shallow Heap之和。Retained Heap是该对象被GC之后所能回收到内存的总和。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 工具 </tag>
            
            <tag> 内存分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="What-什么是设计模式？"><a href="#What-什么是设计模式？" class="headerlink" title="What?什么是设计模式？"></a>What?什么是设计模式？</h1><p>设计模式是对面向对象设计中反复出现问题的解决方案</p><h1 id="Why-问什么要用设计模式？"><a href="#Why-问什么要用设计模式？" class="headerlink" title="Why?问什么要用设计模式？"></a>Why?问什么要用设计模式？</h1><p>设计模式是对面向对象设计中反复出现问题的解决方案</p><h1 id="设计模式7大原则"><a href="#设计模式7大原则" class="headerlink" title="设计模式7大原则"></a>设计模式7大原则</h1><ul><li><h2 id="开放封闭原则-OCP（Open-Close-Principle）"><a href="#开放封闭原则-OCP（Open-Close-Principle）" class="headerlink" title="开放封闭原则 OCP（Open Close Principle）"></a>开放封闭原则 OCP（Open Close Principle）</h2><ul><li>由”Bertrand Meyer”提出的。Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification</li><li>面向扩展开放（Open For Extension），也就是说模块的行为是能够被扩展的。当应用程序的需求变化时，我们可以使模块表现出全新的或与以往不同的行为，以满足新的需求</li><li>面向修改封闭（Closed For Modification），模块的源代码是不能被侵犯的，任何人都不允许修改已有源代码</li><li>看起来两个特性是冲突的，通常扩展一个模块的功能就是修改它的代码，而一个不被经常修改的模块的功能是相对固定的</li><li>抽象（Abstract）是将此两种冲突的特性相结合的关键</li></ul></li><li><h2 id="依赖倒置原则-DIP（Dependency-Inversion-Principle）"><a href="#依赖倒置原则-DIP（Dependency-Inversion-Principle）" class="headerlink" title="依赖倒置原则 DIP（Dependency Inversion Principle）"></a>依赖倒置原则 DIP（Dependency Inversion Principle）</h2><ul><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象。High level modules should not depend upon low level modules. Both should depend upon abstractions</li><li>抽象不应该依赖于具体实现细节，而具体实现细节应该依赖于抽象。Abstractions should not depend upon details. Details should depend upon abstraction</li><li>依赖倒置原则是很多面向对象技术的根基。它特别适合应用于构建可复用的软件框架，其对于构建弹性地易于变化的代码也特别重要。并且，因为抽象和细节已经彼此隔离，代码也变得更易维护</li></ul></li><li><h2 id="单一职责原则-SRP（Single-Responsibility-Principle）"><a href="#单一职责原则-SRP（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则 SRP（Single Responsibility Principle）"></a>单一职责原则 SRP（Single Responsibility Principle）</h2><ul><li>一个类应该有且只有一个变化的原因。There should never be more than one reason for a class to change</li><li>不仅仅是类，每个函数也都应该只负责一个具体的功能</li></ul></li><li><h2 id="接口分离原则-ISP（The-Interface-Segregation-Principle）"><a href="#接口分离原则-ISP（The-Interface-Segregation-Principle）" class="headerlink" title="接口分离原则 ISP（The Interface Segregation Principle）"></a>接口分离原则 ISP（The Interface Segregation Principle）</h2><ul><li>子类不应被强迫实现那些它们不需要的接口。Clients should not be forced to depend upon interfaces that they do not use</li><li>接口污染（Interface Pollution）是指一个基类包含了非必要的接口，接口污染与接口分离相互对立</li><li>解决接口污染的方案<ul><li>通过委托进行分离（Separation through Delegation）</li><li>通过多继承进行分离（Separation through Multiple Inheritance）</li></ul></li><li>胖接口使本应该被隔离的客户类之间产生了耦合。通过应用 Adapter 设计模式，采用委托（delegation）或多继承方式，胖接口可以被分离成多个抽象的基类接口，从而打破客户类之间的不必要的耦合</li></ul></li><li><h2 id="里氏代换原则-LSP（Liskov-Substitution-Principle）"><a href="#里氏代换原则-LSP（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则 LSP（Liskov Substitution Principle）"></a>里氏代换原则 LSP（Liskov Substitution Principle）</h2><ul><li>使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象。Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it</li><li>如若可以成功调用一个父类对象的函数，那么把父类对象替换成子类对象，调用依然可行</li><li>里氏替换原则（Liskov Substitution Principle）则是实现 OCP 原则的重要方式。只有当衍生类能够完全替代它们的基类时，使用基类的函数才能够被安全的重用，然后衍生类也可以被放心的修改了</li></ul></li><li><h2 id="最少知识原则-LKP（Least-Knowledge-Principle）-迪米特法则（Law-of-Demeter）"><a href="#最少知识原则-LKP（Least-Knowledge-Principle）-迪米特法则（Law-of-Demeter）" class="headerlink" title="最少知识原则 LKP（Least Knowledge Principle）- 迪米特法则（Law of Demeter）"></a>最少知识原则 LKP（Least Knowledge Principle）- 迪米特法则（Law of Demeter）</h2><ul><li>类应该与其协作类进行交互但无需了解它们的内部结构。A class should interact directly with its collaborators and be shielded from understanding their internal structure</li><li>现代面向对象程序设计语言通常使用”.”作为访问标识，LoD 可以被简化为”仅使用一个点（use only one dot）”</li><li>优点：遵守 Law of Demeter 将降低模块间的耦合，提升了软件的可维护性和可重用性。</li><li>缺点：应用 Law of Demeter 可能会导致不得不在类中设计出很多用于中转的包装方法（Wrapper Method），这会提升类设计的复杂度。</li></ul></li><li><h2 id="合成复用原则-CRP（Composite-Reuse-Principle）"><a href="#合成复用原则-CRP（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则 CRP（Composite Reuse Principle）"></a>合成复用原则 CRP（Composite Reuse Principle）</h2><ul><li>在模块复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</li><li>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承</li><li>修改基类某些代码会导致所有的子类都需要修改，从而带来了不必要的风险</li></ul></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li><h2 id="创建型-Creational-模式"><a href="#创建型-Creational-模式" class="headerlink" title="创建型 (Creational) 模式"></a>创建型 (Creational) 模式</h2><ul><li>工厂方法 - Factory Method</li><li>抽象工厂模式 - Abstract Factory</li><li>建造者模式 - Builder</li><li>原型模式 - Prototype</li><li>单例模式 - Singleton</li></ul></li><li><h2 id="结构型-Structural-模式"><a href="#结构型-Structural-模式" class="headerlink" title="结构型 (Structural) 模式"></a>结构型 (Structural) 模式</h2><ul><li>适配器模式 - Adapter</li><li>桥接模式 - Bridge</li><li>组合模式 - Composite</li><li>装饰模式 - Decorator</li><li>外观模式 - Facade</li><li>享元模式 - Flyweight</li><li>代理模式 - Proxy</li></ul></li><li><h2 id="行为型-Behavioral-模式"><a href="#行为型-Behavioral-模式" class="headerlink" title="行为型 (Behavioral) 模式"></a>行为型 (Behavioral) 模式</h2><ul><li>解释器模式 - Interpreter</li><li>模板方法模式 - Template Method</li><li>职责链模式 - Chain of Responsibility</li><li>命令模式 - Command</li><li>迭代器模式 - Iterator</li><li>中介者模式 - Mediator</li><li>备忘录模式 - Memento</li><li>观察者模式 - Observer</li><li>状态模式 - State</li><li>策略模式 - Strategy</li><li>访问者模式 - Visitor</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis入门</title>
      <link href="/posts/MyBatis%E5%85%A5%E9%97%A8/"/>
      <url>/posts/MyBatis%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>MyBatis配置文件：配置全局设置，数据库连接信息等<br>SQL Mapper文件：需要执行的SQL语句</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>添加maven依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置MyBatis</p></li><li><p>获取SqlSessionFactory</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></li><li><p>获取SqlSession（需要关闭）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure></li><li><p>获取Mapper</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mapper mapper = session.getMapper(Mapper.class);</span><br></pre></td></tr></table></figure></li></ul><h1 id="Mybatis配置文件"><a href="#Mybatis配置文件" class="headerlink" title="Mybatis配置文件"></a>Mybatis配置文件</h1><h2 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h2><p>properties配置，可以引入外部配置也可以在标签内设置<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">MyBatisXML:properties</a></p><h2 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h2><p>全局设置，配置MyBatis的行为<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">MyBatisXML:settings</a></p><h2 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h2><p>指定类的别名<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases" target="_blank" rel="noopener">MyBatisXML:typeAliases</a></p><h2 id="typeHanglers标签"><a href="#typeHanglers标签" class="headerlink" title="typeHanglers标签"></a>typeHanglers标签</h2><p>类型处理器，用于SQL执行时以及结果返回时<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">MyBatisXML:typeHandlers</a></p><h2 id="objectFactory标签"><a href="#objectFactory标签" class="headerlink" title="objectFactory标签"></a>objectFactory标签</h2><p>对象工厂，用于创建持久化对象<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#objectFactory" target="_blank" rel="noopener">MyBatisXML:objectFactory</a></p><h2 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h2><p>插件，类似于AOP、Filter、Intercept<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">MybatisXML:plugins</a></p><h2 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h2><p>数据库连接配置，可以区分不同的环境<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#environments" target="_blank" rel="noopener">MyBatisXML:environments</a></p><h2 id="databaseIdProvider标签"><a href="#databaseIdProvider标签" class="headerlink" title="databaseIdProvider标签"></a>databaseIdProvider标签</h2><p>MyBatis 可以根据不同的数据库厂商执行不同的语句<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider" target="_blank" rel="noopener">MyBatisXML:databaseIdProvider</a></p><h2 id="mapper标签"><a href="#mapper标签" class="headerlink" title="mapper标签"></a>mapper标签</h2><p>SQL映射文件<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">MyBatisXML:mappers</a></p><h1 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h1><p>namespace属性：命名空间，值为对应接口的完全限定名</p><h2 id="主要标签"><a href="#主要标签" class="headerlink" title="主要标签"></a>主要标签</h2><ul><li>resultMap – 返回值映射关系</li><li>sql – 可被其他语句引用的可重用语句块</li><li>insert – 映射插入语句</li><li>update – 映射更新语句</li><li>delete – 映射删除语句</li><li>select – 映射查询语句</li></ul><h2 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h2><p>查询语句</p><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td></tr><tr><td>resultType</td><td>从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。</td></tr></tbody></table><p>详见：<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#select" target="_blank" rel="noopener">Mapper:select</a></p><h2 id="insert-update-delete标签"><a href="#insert-update-delete标签" class="headerlink" title="insert,update,delete标签"></a>insert,update,delete标签</h2><p>插入，更新，删除</p><h3 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>命名空间中的唯一标识符，可被用来代表这条语句。</td></tr><tr><td>parameterType</td><td>将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td></tr></tbody></table><p>详见：<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#insert_update_and_delete" target="_blank" rel="noopener">Mapper:insert,update,delete</a></p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>当参数名和对应接口中的参数名相同时可以在接口中省略@Param，且MyBatis会根据参数名智能匹配自定义数据类型的成员变量<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Parameters" target="_blank" rel="noopener">Mapper:Parameters</a></p><h2 id="Result-Maps"><a href="#Result-Maps" class="headerlink" title="Result Maps"></a>Result Maps</h2><p>若数据库中字段名与Java中实体类中成员变量名完全吻合，MyBatis可以智能匹配并注入结果，若不吻合，则需要开发者自定以Result Map，以实现数据库查询结果到实体类的映射<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Parameters" target="_blank" rel="noopener">Mapper:Result Maps</a></p><h1 id="注解配置Mapper"><a href="#注解配置Mapper" class="headerlink" title="注解配置Mapper"></a>注解配置Mapper</h1><p>对于注解配置MyBatis，不推荐使用，注解写在Java源代码中，失去了原有的灵活性，若是需要修改，必须修改源文件，增加了风险，已经确定不会改变的可以使用注解配置<br>详见：<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps" target="_blank" rel="noopener">MyBatis:Java Api</a></p><h1 id="Spring集成MyBatis"><a href="#Spring集成MyBatis" class="headerlink" title="Spring集成MyBatis"></a>Spring集成MyBatis</h1><ul><li><p>添加maven依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据源dataSource</p></li><li><p>配置SqlSessionFactoryBean</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  详见：<a href="http://www.mybatis.org/spring/zh/factorybean.html" target="_blank" rel="noopener">MyBatis-Spring:SqlSessionFactoryBean</a></p></li><li><p>配置自动包扫描MapperScannerConfigurer</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.spring.sample.mapper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  详见：<a href="http://www.mybatis.org/spring/zh/mappers.html#MapperScannerConfigurer" target="_blank" rel="noopener">MyBatis-Spring:MapperScannerConfigurer</a></p></li><li><p>配置事务</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  详见：<a href="http://www.mybatis.org/spring/zh/transactions.html" target="_blank" rel="noopener">MyBatis-Spring:Transactions</a></p></li></ul><h1 id="SpringBoot集成MyBatis"><a href="#SpringBoot集成MyBatis" class="headerlink" title="SpringBoot集成MyBatis"></a>SpringBoot集成MyBatis</h1><p>详见：<a href="http://www.mybatis.org/spring-boot-starter/" target="_blank" rel="noopener">MyBatis:Spring Boot Starter</a></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="配置MyBatis"><a href="#配置MyBatis" class="headerlink" title="配置MyBatis"></a>配置MyBatis</h2><ul><li>传统xml方式<br>  在application.properties中添加：mybatis.config-location，值为MyBatis配置xml文件位置</li><li>SpringBoot方式<br>  在application.properties中添加：<br>  mybatis.configuration.*，基本属性配置<br>  mybatis.type-handlers-package，类型处理器所在包</li><li>扫描Dao（即mapper）包<br>  使用注解 @MapperScan(package path)</li></ul><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>详见：<a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">Mybatis:DynamicSQL</a></p><h2 id="if标签："><a href="#if标签：" class="headerlink" title="if标签："></a>if标签：</h2><p>若属性test中表达式为true则拼接</p><h2 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose,when,otherwise标签"></a>choose,when,otherwise标签</h2><p>类似于Java的Switch</p><h2 id="trim-where-set标签"><a href="#trim-where-set标签" class="headerlink" title="trim,where,set标签"></a>trim,where,set标签</h2><p>trim 自定义拼接<br>where,set MyBatis提供的自定义拼接，可以去除头部多余的 “AND|OR”，及尾部 “,”</p><h2 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h2><p>循环处理，可以指定开始符与结束符（栗：’(‘ | ‘)’ ）</p><h2 id="Multi-db-vendor-support-多数据库支持"><a href="#Multi-db-vendor-support-多数据库支持" class="headerlink" title="Multi-db vendor support - 多数据库支持"></a>Multi-db vendor support - 多数据库支持</h2><p>需配置databaseIdProvider</p><h2 id="typeHandle"><a href="#typeHandle" class="headerlink" title="typeHandle"></a>typeHandle</h2><ul><li><p>继承：<br>  BaseTypeHandler<t> </t></p></li><li><p>重写：<br>  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType)<br>  public String getNullableResult(ResultSet rs, String columnName)<br>  public String getNullableResult(ResultSet rs, int columnIndex)<br>  public String getNullableResult(CallableStatement cs, int columnIndex) </p></li></ul><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>MyBatis 允许使用插件来拦截的方法调用包括：<br>    * Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br>    * ParameterHandler (getParameterObject, setParameters)<br>    * ResultSetHandler (handleResultSets, handleOutputParameters)<br>    * StatementHandler (prepare, parameterize, batch, update, query)</p><h3 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">    type= Executor.class, <span class="comment">//想要拦截的类</span></span><br><span class="line">    method = <span class="string">"update"</span>, <span class="comment">//想要拦截的方法</span></span><br><span class="line">    args = &#123;MappedStatement.class,Object.class&#125;</span><br><span class="line">)&#125;)</span><br></pre></td></tr></table></figure></code></pre><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><pre><code>Interceptor</code></pre><h3 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h3><pre><code>public Object intercept(Invocation invocation) public Object plugin(Object target) public void setProperties(Properties properties)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据源 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat简介</title>
      <link href="/posts/Tomcat%E7%AE%80%E4%BB%8B/"/>
      <url>/posts/Tomcat%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Tomcat是一款免费的开源并实现了Java Servlet、Java Server Pages、Java Expression Language 以及 Web Socket 等技术的 Web 应用服务器</p><ul><li>Web服务器</li><li>Servlet容器</li><li>基于Servlet规范</li></ul><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>bin</li><li>config</li><li>logs</li><li>temp</li><li>webapps</li><li>work</li></ul><h2 id="Servlet-Web应用开发步骤"><a href="#Servlet-Web应用开发步骤" class="headerlink" title="Servlet Web应用开发步骤"></a>Servlet Web应用开发步骤</h2><p>Java环境搭建 → Tomcat环境搭建 → 建立Web目录结构 → Coding → 发布</p><h2 id="Tomcat配置server-xml"><a href="#Tomcat配置server-xml" class="headerlink" title="Tomcat配置server.xml"></a>Tomcat配置server.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Resource</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Container容器"><a href="#Container容器" class="headerlink" title="Container容器"></a>Container容器</h2><ul><li>Engine：定义一些基本关联</li><li>Host：Engine子容器，代表一个虚拟主机，负责运行多个应用</li><li>Context：Host子容器，代表Servlet的Context，具备运行Servlet的基本环节</li><li>Wrapper：代表一个Servlet，负责管理Servlet生命周期</li></ul><h1 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h1><h2 id="字符集（常用）"><a href="#字符集（常用）" class="headerlink" title="字符集（常用）"></a>字符集（常用）</h2><ul><li>ASCII（单字节编码，128字符）</li><li>ISO-8859-1（单字节编码，256字符）</li><li>UTF-16（统一编码双字节编码，所有字符）</li><li>UTF-8（变长编码）</li><li>GB2312（汉子双字节编码，6736个汉字）</li><li>GBK（兼容GB2312,23940个汉字）</li></ul><h2 id="POST设置字符集"><a href="#POST设置字符集" class="headerlink" title="POST设置字符集"></a>POST设置字符集</h2><p>request.setCharacterEncoding在第一次调用getParameter()之前设置</p><h2 id="Response设置编码字符集"><a href="#Response设置编码字符集" class="headerlink" title="Response设置编码字符集"></a>Response设置编码字符集</h2><ul><li>response.setCharacterEncoding</li><li><meta http-equiv="“Content-Type"" content="text/html;charset=" utf-8"></li></ul><h2 id="数据库连接设置字符集"><a href="#数据库连接设置字符集" class="headerlink" title="数据库连接设置字符集"></a>数据库连接设置字符集</h2><p>在url的参数中添加useUnicode=true&amp;characterEncoding=UTF-8</p><h1 id="Tomcat常用配置"><a href="#Tomcat常用配置" class="headerlink" title="Tomcat常用配置"></a>Tomcat常用配置</h1><h2 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h2><p>设置connector</p><h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><ul><li>在startenv.sh中加入远程调试参数，重启Tomcat</li><li>在IDEA中新建remote启动</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Lambda Expression</title>
      <link href="/posts/Java-Lambda-Expression/"/>
      <url>/posts/Java-Lambda-Expression/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式本质"><a href="#Lambda表达式本质" class="headerlink" title="Lambda表达式本质"></a>Lambda表达式本质</h1><p>一个Lambda表达式本质上是一个匿名函数</p><h1 id="Lambda表达式出现的原因"><a href="#Lambda表达式出现的原因" class="headerlink" title="Lambda表达式出现的原因"></a>Lambda表达式出现的原因</h1><p>匿名类型最大的问题就在于其冗余的语法，而Lambda表达式提供了轻量级的语法，解决了匿名内部类代码冗余的问题。</p><h1 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h1><p>lambda表达式的语法由参数列表、箭头符号-&gt;和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p><ul><li>表达式：表达式会被执行然后返回执行结果。</li><li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——<ul><li>return语句会把控制权交给匿名方法的调用者</li><li>break和continue只能在循环中使用</li><li>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值</li></ul></li></ul><p>表达式函数体适合小型lambda表达式，它消除了return关键字，使得语法更加简洁。</p><p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y</span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line">FileFilter java = (File f) -&gt; f.getName().endsWith(<span class="string">"*.java"</span>);</span><br><span class="line">String user = doPrivileged(() -&gt; System.getProperty(<span class="string">"user.name"</span>));</span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">    connectToService();</span><br><span class="line">    sendNotification();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式的目标类型"><a href="#Lambda表达式的目标类型" class="headerlink" title="Lambda表达式的目标类型"></a>Lambda表达式的目标类型</h1><p>Lambda表达式的目标类型是由其上下文推导而来</p><p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p><p>lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T：</p><ul><li>T是一个函数式接口</li><li>lambda表达式的参数和T的方法参数在数量和类型上一一对应</li><li>lambda表达式的返回值和T的方法返回值相兼容（Compatible）</li><li>lambda表达式内所抛出的异常和T的方法throws类型相兼容</li></ul><p>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，lambda表达式的参数类型可以从目标类型中得出。</p><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());</span><br><span class="line">Callable&lt;String&gt; c = () -&gt; <span class="string">"done"</span>;</span><br><span class="line">PrivilegedAction&lt;String&gt; a = () -&gt; <span class="string">"done"</span>;</span><br><span class="line">Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);</span><br><span class="line">FileFilter java = f -&gt; f.getName().endsWith(<span class="string">".java"</span>);</span><br><span class="line">button.addActionListener(e -&gt; ui.dazzle(e.getModifiers()));</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式词法作用域"><a href="#Lambda表达式词法作用域" class="headerlink" title="Lambda表达式词法作用域"></a>Lambda表达式词法作用域</h1><p>在内部类中使用变量名（以及this）非常容易出错。内部类中通过继承得到的成员（包括来自Object的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的this引用会指向内部类自己而非外部类。</p><p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，’this’关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p><p>也就是说在内部类中的 this 是有可能有歧义的，而Lambda表达式中的 this 和表达式外部 this 予以相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    Runnable r1 = () -&gt; &#123; System.out.println(<span class="keyword">this</span>);&#125;;</span><br><span class="line">    Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Hello, world"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">        <span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h1><p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。对于lambda表达式和内部类，允许在其中捕获那些符合有效只读（Effectively final）的局部变量，尽管放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止。</p><p>简单的说在内部类中捕获的外部变量必须是final修饰的变量，儿Lambda表达式内捕获外部变量时不要求变量的final属性，但是依然不能修改。</p><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Callable&lt;String&gt; <span class="title">helloCallable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    String hello = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; (hello + <span class="string">", "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用和lambda表达式拥有相同的特性，不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person[] people = ...</span><br><span class="line">Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);</span><br><span class="line">Arrays.sort(people, byName);</span><br><span class="line"></span><br><span class="line">Consumer&lt;Integer&gt; b1 = System::exit; <span class="comment">// void exit(int status)</span></span><br><span class="line">Consumer&lt;String[]&gt; b2 = Arrays:sort; <span class="comment">// void sort(Object[] a)</span></span><br><span class="line">Consumer&lt;String&gt; b3 = MyProgram::main; <span class="comment">// void main(String... args)</span></span><br><span class="line">Runnable r = Myprogram::mapToInt <span class="comment">// void main(String... args)</span></span><br></pre></td></tr></table></figure><h1 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h1><p>方法引用有很多种，它们的语法如下：</p><ul><li>静态方法引用：ClassName::methodName</li><li>实例上的实例方法引用：instanceReference::methodName</li><li>超类上的实例方法引用：super::methodName</li><li>类型上的实例方法引用：ClassName::methodName</li><li>构造方法引用：Class::new</li><li>数组构造方法引用：TypeName[]::new</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 8 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>又称规则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）</p><p>通常被用来检索、替换那些符合某个模式(规则)的文本</p><h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>正则表达式由一些 普通字符 和一些 元字符（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义</p><p>以下是元字符表</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于o{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次（大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]</td></tr><tr><td>.点</td><td>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到。要匹配圆括号字符，请使用“\(”或“\)”。</td></tr><tr><td>(?:pattern)</td><td>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry</td></tr><tr><td>(?=pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。\n这个地方不正确，有问题。此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配。</td></tr><tr><td>x|y</td><td>匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。\n注意:只有连字符在字符组内部时，并且出现在两个字符之间时，才能表示字符的范围; 如果出字符组的开头，则只能表示连字符本身。</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td>\s</td><td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何可见字符。等价于[^\f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td></tr><tr><td>\xn</td><td>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。</td></tr><tr><td>\num</td><td>匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td></tr><tr><td>\un</td><td>匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。</td></tr><tr><td>\p{P}</td><td>小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。\n其他六个属性：\nL：字母；\nM：标记符号（一般不会单独出现）；\nZ：分隔符（比如空格、换行等）；\nS：符号（比如数学符号、货币符号等）；\nN：数字（比如阿拉伯数字、罗马数字等）；\nC：其他字符。\n\*注：此语法部分语言不支持，例：javascript。</td></tr><tr><td>\&lt;\n\&gt;</td><td>匹配词（word）的开始（\&lt;）和结束（\&gt;）。例如正则表达式\&lt;the\&gt;能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。</td></tr></tbody></table><p>|( )|将 ( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。|<br>|||将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。|</p><h1 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h1><ul><li>?等价于匹配长度{0,1}</li><li>*等价于匹配长度{0,} </li><li>+等价于匹配长度{1,}</li><li>\d等价于[0-9]</li><li>\D等价于[^0-9]</li><li>\w等价于[A-Za-z_0-9]</li><li>\W等价于[^A-Za-z_0-9]</li></ul><h1 id="常用运算符与表达式"><a href="#常用运算符与表达式" class="headerlink" title="常用运算符与表达式"></a>常用运算符与表达式</h1><ul><li>^ 开始</li><li>() 域段</li><li>[] 包含,默认是一个字符长度</li><li>[^] 不包含,默认是一个字符长度</li><li>{n,m} 匹配长度 </li><li>. 任何单个字符(\. 字符点)</li><li>| 或</li><li>\ 转义</li><li>$ 结尾</li><li>[A-Z] 26个大写字母</li><li>[a-z] 26个小写字母</li><li>[0-9] 0至9数字</li><li>[A-Za-z0-9] 26个大写字母、26个小写字母和0至9数字</li><li>, 分割<br>语法与释义<br>基础语法 “^([]{})([]{})([]{})$”</li></ul><p>正则字符串 = “开始（[包含内容]{长度}）（[包含内容]{长度}）（[包含内容]{长度}）结束”</p><p>支持情况<br>|命令或环境|.|[ ]|^|$|\( \)|\{ \}|?|+|||( )|<br>|—|—|—|—|—|—|—|—|—|—|—|<br>|vi|√|√|√|√|√||||||<br>|Visual C++|√|√|√|√|√||||||<br>|awk|√|√|√|√|awk是支持该语法的，只是要在命令行加入 –posix or –re-interval参数即可，可见man awk中的interval expression|√|√|√|√|<br>|sed|√|√|√|√|√|√|||||<br>|delphi|√|√|√|√|√||√|√|√|√|<br>|python|√|√|√|√|√|√|√|√|√|√|<br>|java|√|√|√|√|√|√|√|√|√|√|[3]|<br>|javascript|√|√|√|√|√||√|√|√|√|<br>|php|√|√|√|√|√||||||<br>|perl|√|√|√|√|√||√|√|√|√|<br>|C#|√|√|√|√|||√|√|√|√|</p><h1 id="Java中的应用"><a href="#Java中的应用" class="headerlink" title="Java中的应用"></a>Java中的应用</h1><h2 id="java-util-regex-Pattern"><a href="#java-util-regex-Pattern" class="headerlink" title="java.util.regex.Pattern"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">java.util.regex.Pattern</a></h2><ul><li>static Pattern compile(String regex) 使用regex构造一个正则表达式</li><li>static Pattern compile(String regex, int flags) 使用regex和标志flags构造一个正则表达式</li><li>int flags() 返回正则表达式的标示</li><li>Matcher matcher(CharSequence input) 创建一个input关于正则表达式的Matcher</li><li>static boolean matches(String regex, CharSequence input) 判断input是否匹配regex，效果同input.matches(regex)</li><li>String pattern(\ 返回一个正则表达式字符串</li><li>static String quote(String s) 返回一个字符串的正则表达式字符串</li><li>String[] split(CharSequence input) 字符串分割同String.split()</li><li>String[] split(CharSequence input, int limit) 字符串分割同String.split()</li><li>Stream&lt;String&gt; splitAsStream(CharSequence input) 把字符串分割为流</li></ul><h2 id="java-util-regex-Matcher"><a href="#java-util-regex-Matcher" class="headerlink" title="java.util.regex.Matcher"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html" target="_blank" rel="noopener">java.util.regex.Matcher</a></h2><ul><li>boolean matches() 尝试进行一次匹配</li><li>String group() 返回匹配的子串</li><li>String group(int group) 返回匹配到的第g个组</li><li>String replaceAll(String replacement) 替换所有匹配项</li><li>String replaceFirst(String replacement) 替换第一个匹配项</li><li>Matcher reset() 重置</li><li>Matcher reset(CharSequence input) 重置匹配字符串</li><li>Matcher usePattern(Pattern newPattern) 以新的模式创建一个新的Matcher</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去哪儿2018校招在线考试-编程题一</title>
      <link href="/posts/%E5%8E%BB%E5%93%AA%E5%84%BF2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E5%8E%BB%E5%93%AA%E5%84%BF2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-最少转机"><a href="#题目-最少转机" class="headerlink" title="题目 最少转机"></a>题目 最少转机</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>去哪儿网将机票业务扩展到了大魏国，宇文玥和楚乔都是去哪儿网的忠实用户，经常坐飞机双宿双飞，现在已知大魏国有n个城市，共有m条国内航线，航线都是可往返的，已知他们所居住的城市和他们想要达到的城市，请给出最小转机次数。如果两城市间不可到达，则返回DISCONNECTED</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一行两个数n，m（2≤n≤100，1≤m≤100） ; 紧随其后的是两个城市的名称，代表居住城市和想要到达的城市接下来m行，分别为各个航线间的两个城市（城市名称间以空格隔开）</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出最少转机次数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>5 5 LuoYang JinLingChangAn LuoYangLuoYang JianKangLuoYang LangYeJianKang LangYeJianKang JinLing</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ul><li>使用邻接矩阵存储机票</li><li>因为只需要计算转机数,所以计边的权重为 1</li><li>所有边的权重相同,则可采用 BFS 解决最短路问题</li><li>时间复杂度 O(n),空间复杂度 O(n^2)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,orgC,desC;</span><br><span class="line"><span class="built_in">string</span> org,des;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;city;</span><br><span class="line"><span class="keyword">bool</span> route[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> minDis[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; cQueue;</span><br><span class="line">    cQueue.push(orgC);</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">while</span>(cQueue.size())</span><br><span class="line">    &#123;</span><br><span class="line">        now=cQueue.front();</span><br><span class="line">        <span class="keyword">if</span>(now==desC)<span class="keyword">return</span> ;</span><br><span class="line">        cQueue.pop();</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(route[now][i]&amp;&amp;!vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cQueue.push(i);</span><br><span class="line">                minDis[i]=minDis[now]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(route,<span class="number">0</span>,<span class="keyword">sizeof</span> route);</span><br><span class="line">    <span class="built_in">memset</span>(minDis,<span class="number">0</span>,<span class="keyword">sizeof</span> minDis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmp1,tmp2;</span><br><span class="line">    <span class="keyword">int</span> cIndex=<span class="number">0</span>,tmpI1,tmpI2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;org&gt;&gt;des;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tmp1&gt;&gt;tmp2;</span><br><span class="line">        <span class="keyword">if</span>(!city.count(tmp1))</span><br><span class="line">            city[tmp1]=cIndex++;</span><br><span class="line">        <span class="keyword">if</span>(!city.count(tmp2))</span><br><span class="line">            city[tmp2]=cIndex++;</span><br><span class="line">        tmpI1=city[tmp1],tmpI2=city[tmp2];</span><br><span class="line">        route[tmpI1][tmpI2]=<span class="number">1</span>;</span><br><span class="line">        route[tmpI2][tmpI1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    orgC=city[org],desC=city[des];</span><br><span class="line"></span><br><span class="line">    minDistance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(minDis[desC])</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;minDis[desC];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"DISCONNECTED"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 去哪儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 去哪儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去哪儿2018校招在线考试-编程题三</title>
      <link href="/posts/%E5%8E%BB%E5%93%AA%E5%84%BF2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/"/>
      <url>/posts/%E5%8E%BB%E5%93%AA%E5%84%BF2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-弃程的妙用"><a href="#题目-弃程的妙用" class="headerlink" title="题目 弃程的妙用"></a>题目 弃程的妙用</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>一张机票的价格是由多个因素决定的，它通常与飞行距离没有直接的关系。许多旅行者于是在这方面变得非常有创意，当飞机在多个城市停靠时，只是用机票的一部分，以实现低花费的旅行。例如：    北京到温哥华的机票可能卖8000元人民币，但是，北京-温哥华-西雅图的机票可能卖7500元，    如果用户的目的地是温哥华，那么用户会选择买北京-温哥华-西雅图的机票，    当他乘坐完北京-温哥华的航段后，会放弃乘坐温哥华到西雅图的航段。然而，航空公司也了解这种行为，并通常要求一张机票所包含的站点必须要按顺序旅行，而且不允许中途加入其他路线。例如：    你手中有一张从北京到温哥华然后再到西雅图的机票，你不能仅使用机票中温哥华到西雅图的部分，    你必须从机票上的第一个城市北京出发；    此外，也不允许你从城市北京到城市温哥华，然后去一些其他地方如多伦多并返回温哥华，    再继续你从温哥华到西雅图的旅途。给出一组优惠的机票，以及一条或多条旅游路线，你要确定为了使旅行费用最少，应该如何购买机票。现假设：优惠机票航线不多于10条，每组优惠机票的测试用例旅行路线不多于10条，每张机票的航段数不多于5个，每个优惠航线票价不高于10000元</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>包含一组测试用例，测试用例中描述一组优惠机票和一组旅行路线每组测试用例由4部分组成：第1行为优惠机票航线有多少条（n）第2行~第2+n-1行描述优惠机票编号，每张优惠机票的价格、航段数和航段顺序第2+n行描述了测试用例的旅行路线</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>对于每条旅行路线，输出两行，包括路线的最小花费；然后按使用顺序输出本次旅行所使用的机票编号，具体输出格式见样例，保证答案唯一。如果输入参数不合法，则返回Error。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>31 700 2 HongKong Seattle2 700 3 Beijing Seattle Vancouver3 1400 3 Beijing HongKong Vancouver3 Beijing HongKong Seattle</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>21003 1</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>最短路径的变异题,每条边上有一个起点,一个终点,多个途经点</li><li>由于给了路径,所以难度降低,Dijkstra 算法变形即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> org;</span><br><span class="line">    <span class="keyword">int</span> fare;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; des;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;city;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;trip;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tripC;</span><br><span class="line"><span class="keyword">int</span> minFare[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> passRoute[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">vector</span>&lt;route&gt;&amp;routes,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(routes[j].org==tripC[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> next=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;routes[j].des.size();++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(routes[j].des[k]==tripC[i+next])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!minFare[i+next]||minFare[i+next]&gt;minFare[i]+routes[j].fare)</span><br><span class="line">                    &#123;</span><br><span class="line">                        minFare[i+next]=minFare[i]+routes[j].fare;</span><br><span class="line">                        passRoute[i+next]=j+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">vector</span>&lt;route&gt;&amp;routes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tripC.size()<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        update(routes,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> i,cIndex=<span class="number">0</span>,tmpI,index,tFare;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;route&gt;routes(n);</span><br><span class="line"></span><br><span class="line">    i=n;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;index&gt;&gt;tFare&gt;&gt;tmpI&gt;&gt;tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmpI&gt;<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!city.count(tmp))</span><br><span class="line">            city[tmp]=cIndex++;</span><br><span class="line">        routes[index<span class="number">-1</span>].org=city[tmp];</span><br><span class="line">        routes[index<span class="number">-1</span>].fare=tFare;</span><br><span class="line">        <span class="keyword">while</span>(--tmpI)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            <span class="keyword">if</span>(!city.count(tmp))</span><br><span class="line">                city[tmp]=cIndex++;</span><br><span class="line">            routes[index<span class="number">-1</span>].des.push_back(city[tmp]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;tmpI;</span><br><span class="line">    <span class="built_in">memset</span>(minFare,<span class="number">0</span>,<span class="keyword">sizeof</span> minFare);</span><br><span class="line">    <span class="built_in">memset</span>(passRoute,<span class="number">0</span>,<span class="keyword">sizeof</span> passRoute);</span><br><span class="line">    trip.clear();</span><br><span class="line">    tripC.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tmpI--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">        <span class="keyword">if</span>(!city.count(tmp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        trip.push_back(tmp);</span><br><span class="line">        tripC.push_back(city[tmp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDistance(routes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(minFare[tripC.size()<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;minFare[tripC.size()<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> preRoute=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;trip.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(passRoute[i]!=preRoute)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(preRoute) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                preRoute=passRoute[i];</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;preRoute;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 去哪儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 去哪儿 </tag>
            
            <tag> 最短距离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去哪儿2018校招在线考试-编程题二</title>
      <link href="/posts/%E5%8E%BB%E5%93%AA%E5%84%BF2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E5%8E%BB%E5%93%AA%E5%84%BF2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-逆序字符串的最长公共子序列长度"><a href="#题目-逆序字符串的最长公共子序列长度" class="headerlink" title="题目 逆序字符串的最长公共子序列长度"></a>题目 逆序字符串的最长公共子序列长度</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>同学们，我们刚刚经历了十一和中秋双节假期，让我们一起预祝我们的祖国繁荣富强，同学们每个中秋与家人共赏明月，也期待同学们能够加入去哪儿网，为大家的出游和回家团圆尽一份力量。我们的第二题是这样的，给出一个以空格作为分隔符的字符串，求其与其空格分隔的逆序字符串的最长公共子序列长度。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>例如：输入 2017 11 02其逆序字符串为 02 11 2017</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>6(2 11 2)</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>2017 11 02</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>6</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>常见的题型不多说</li><li>时间复杂度 O(n^2),空间复杂度 O(n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str1,str2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmp;</span><br><span class="line"></span><br><span class="line">    ss&gt;&gt;tmp;</span><br><span class="line">    str2=tmp.append(str2);</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        str2=tmp.append(<span class="string">" "</span>).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len=str1.length();</span><br><span class="line">    <span class="keyword">int</span> res[len+<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span> res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i]==str2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res[j+<span class="number">1</span>]=res[j]+<span class="number">1</span>;</span><br><span class="line">                maxLen=max(maxLen,res[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[j+<span class="number">1</span>]=max(res[j],res[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 去哪儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 去哪儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018秋招总结</title>
      <link href="/posts/2018%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
      <url>/posts/2018%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>作者从七月份开始,就开始复习准备秋招,开始疯狂的投简历的旅程<br><br>秋招已经过去大半了,是时候总结一下今年的秋招了<br><br>作者投的一般是 C++ 开发,也会投 Java 开发</p><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul><li>对于复习呢,最多的当然是专业课<ul><li>最重要的当然是 &lt;&lt;数据结构&gt;&gt;</li><li>再就是开发语言了,投的啥就复习啥,比如,C++,Java…(作者主要是C++,也可以做Java所以就先写这俩)</li><li>接下来就是 &lt;&lt;设计模式&gt;&gt;,&lt;&lt;计算机网络&gt;&gt;,&lt;&lt;数据库原理&gt;&gt;,&lt;&lt;操作系统&gt;&gt;,&lt;&lt;计算机组成原理&gt;&gt;…(按重要性排序,大家懂得)</li><li>除了上边提到的这些还有开发语言的各种细节问题,以及语言的内部实现,Linux知识点啊等等,最好看一下</li></ul></li><li>刷题 刷题 刷题,一定要刷题<ul><li>不管是编程题也好,还是选择填空以及简答</li><li>尤其是编程题,很重要</li><li>当这次秋招结束,你会发现自己的编程能力提升很大(当然仅限于作者这样的渣渣)</li></ul></li><li>还有数学系,高数,离散,概率,线性代数,不要问我为什么,说多了全是泪</li></ul><h2 id="简历投递"><a href="#简历投递" class="headerlink" title="简历投递"></a>简历投递</h2><p>简历投递呢也是有技巧</p><ul><li>大厂是一定要投的,不管有没有希望,总得试试嘛,也许就进了呢(大佬们就很容易进了)</li><li>综合各个平台,像牛客,赛码,掘金,知乎(顺序不分先后)这些网站,看一看大家的评论,以及每年的笔试题的难度,适当的投递简历</li><li>对于双非同学,包括本科生及学历断代的硕士生,最好不要投递国企,除非你的能力非常非常强,血淋淋的教训</li><li>千万不要投多,千万不要投多,千万不要投多,很累,很累,很累</li><li>建议大厂 3<del>4 个,中大厂 3</del>4 个,中小厂 3~4 个,一般这样就可以了,要是实在不放心,可以再加几个小厂,大中小厂怎么区分啊,IT 企业排名吧,根据自己的情况选择,不要纠结于大厂</li></ul><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><ul><li><p>选择,填空一般就是前面说的复习的专业基础里的知识点了,会根据投递岗位的不同变化,但是复习过的基础肯定会考的</p></li><li><p>简答题呢,很魔性,出简答题的公司不多,一般是设计题,也会有应用解方程(别问我为啥会有这个,我真的不知道),对于设计题(其实作者对设计题呢是非常讨厌的,嗯,所以每次设计题都是随便写写)</p><ul><li>首先是设计方案与思路</li><li>再就是优缺点(最好有两个以上不同的方案进行比较)</li><li>最后可行性,当然可行性也是优缺点里的,但是可行性很重要,单独拿出来,时间,空间,资源,资金等等可行性的分析</li></ul></li><li><p>最后就是重头戏 编程题 了,编程题大体可以分三种</p><ul><li><p>不能本地,不能线上运行调试</p></li><li><p>不能本地,但是能线上运行调试</p></li><li><p>可以使用本地 IDE</p><p>对于不同判题方式,采用不同的方案</p></li><li><p>第一种,一般此类题并不是难,人工判题,看的侧重点其实是代码的风格,比如 C++,使用 new 之后有没有用 delete,又如代码缩进,++i 还是 i++…等等,所以在做对的前提下尽量提高代码可读性</p></li><li><p>第二种其实是最难的,不能跳出界面,只能在页面里写,比如 AMCAT,尽量一次通过,否则调试很麻烦</p></li><li><p>第三种,自己的主场啊,那必须嘿嘿嘿,各种顺手,当然难题还是费劲的</p><p>大体说一下解题方法(ACMer 略过就好了)</p></li><li><p>先看懂题,看不懂题还做个啥子</p></li><li><p>先想个暴力解法</p><ul><li>若是时间复杂度是 O(2^n),果断放弃,找状态转移方程吧,动态规划可以压缩到 O(n^2)~O(n)(很少见)</li><li>若是 O(n^k),看 n 和 k 的范围,若不大,就直接暴力吧,若 n 过大,最好想想别的方法压缩成 O(nlogn),比如把冒泡排序换成快排,</li><li>若是 O(n),直接暴力</li></ul></li><li><p>对于空间复杂度,一般是不会超出限制的,但是有时也会超出限制,大部分的动态规划是可以把空间压缩到 O(n) 的,有一些可以使用状态压缩,比如把 bool 数组压缩为 bit 位存储</p></li><li><p>常用的解题方法</p><ul><li>无权图中找最短路-BFS,图中验证存在某路径-DFS,两点之间最短距-Dijkstra 算法(无负权),任意两点之间距离-Floyd-Warshall 算法,两点之间最短距-Bellman-Ford 算法(含负权)</li><li>可离线区间问题-莫队算法,一维二维都可以</li><li>第 k 大问题-分治,前 k 大问题-堆</li><li>递归剪枝,二分查找,</li><li>动态规划,状态压缩等等</li></ul></li><li><p>注意代码的鲁棒性,注意数据极限值</p><p>暂时就想起这些来</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2></li></ul></li><li><p>一面,讲真,一面应该是问基础才对,然而我最近三次一面都是怼我项目…我也很无奈啊,难道是因为我是计算机专业的原因?不科学啊…</p><ul><li>数据结构,这个就不说了,各种常用的数据结构,及其相关算法,排序及查询算法</li><li>网络相关,TCP/IP 协议,三次握手,四次挥手啥的,HTTP 协议…好好复习</li><li>操作系统,操作体统课程基础内容自己复习,都可能问的到,以及 Windows 及 Linux 问题(一般作为加分项,不会没啥关系,最好了解一下)</li><li>语言相关,投的 C++ 就是去看看 <a href="/posts/常见C-面试题/"> C++ 常见面试题</a>,Java 的在<a href="/posts/Java方向如何准备BAT技术面试答案-转/">这里</a></li><li>项目相关,把自己做过的项目里用过的框架,技术,协议等等的深入了解一下</li></ul></li><li><p>二面,一般来说应该是以项目为切入点</p><ul><li>有可能和一面一样深挖应聘者对项目所用技术的掌握程度</li><li>从项目的某个问题切入来挖掘应聘者的某些品质,比如,创新思维,责任感,解决问题的能力等等,回答的时候一定要体现出自己的优点</li><li>当然大佬们的二面不一定是这样的,或许会有一大堆我们这些渣渣看不懂的问题,关键还是自己的知识储备量</li></ul></li><li><p>三面,传说中的 HR 面,作者只面过三面,没有到四面的时候,这或许就是渣渣与大佬的区别吧</p><ul><li>一定要放开胆子说,一定要和 HR 沟通,一句话不说的童鞋,除非是大佬,被挂了很正常</li><li>对自己褒贬有度,不能一味的炫耀自己,人非圣贤,谁信你一点缺点都没有啊,诚实点,说出来没什么问题,对自己有个客观的判断</li><li>不能让 HR 把主动权全部攥在手里,你也去抢一抢啊,人家 HR 问一句,你答一句,明显不是很会交流啊,但也不能把话语权全给抢过来,有个 20% ~ 30% 的话语权就行了</li><li>在 HR 谈薪资之前,千万别提,当问薪资的时候,底气要足(作者脑残要少了),但不要太过分</li></ul></li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>以上呢就是作者这三个月来,尤其是近一个月来的经验,作者是渣渣,也只能写到这里了,希望可以帮一下大家,希望每个人收到自己心仪的 Offer,不要过分追求大厂,当务之急是拿到 Offer,当然大佬们就尽情的收割 Offer 吧😃</p>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米2018校招在线考试-编程题一</title>
      <link href="/posts/%E5%B0%8F%E7%B1%B32018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E5%B0%8F%E7%B1%B32018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-名称转换"><a href="#题目-名称转换" class="headerlink" title="题目 名称转换"></a>题目 名称转换</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>在C++头文件中可以使用include guard以避免头文件被重复include，譬如：#ifndef MYHEADER_H_#define MYHEADER_H_ ...#endif 现在我希望你编写一个程序，将类名按照某种规则转换为include guard所使用的宏。类名会包含namespace前缀，使用“.”作为分隔符。被分隔符分开的各个部分称之为组件，组件只会包含大小写字母和数字，且不能以数字开头。转换规则：* 在开头和结尾都添加下划线；* 将“.”转化为下划线；* 根据下面的规则识别出组件中的单词，并使用下划线将单词进行分隔（具体参照输入输出样例）：    * 第一个大写字母与后面连续的小写字母一起识别为一个单词，如果不以大写字母开头，则直接将连续的小写字母识别为一个单词；    * 连续的大写字母一起识别为一个单词，但是如果最后一个大写字母后面跟着小写字母，则最后一个大写字母不包含在内；    * 连续的数字一起识别为一个单词；</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>多行字符串，每行是一个类名</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>多行字符串，每行是一个转化后的include guard宏，与输入对应</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>amy.ABCsimple.HelloServiceMY.ASTParser12</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>_A__MY_ABC__SIMPLE_HELLO_SERVICE__MY_AST_PARSER_12_</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>暴力,注意替换和添加’_’的条件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!i) tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]&gt;=<span class="string">'A'</span>&amp;&amp;str[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i &amp;&amp; tmp[j<span class="number">-1</span>]!=<span class="string">'_'</span> &amp;&amp;</span><br><span class="line">                   ( str[i<span class="number">-1</span>]&lt;<span class="string">'A'</span>||str[i<span class="number">-1</span>]&gt;<span class="string">'Z'</span> ||</span><br><span class="line">                     str[i<span class="number">-1</span>]&gt;=<span class="string">'A'</span>&amp;&amp;str[i<span class="number">-1</span>]&lt;=<span class="string">'Z'</span> &amp;&amp;</span><br><span class="line">                     str[i+<span class="number">1</span>]&gt;=<span class="string">'a'</span>&amp;&amp;str[i+<span class="number">1</span>]&lt;=<span class="string">'z'</span></span><br><span class="line">                    )</span><br><span class="line">                   )</span><br><span class="line">                    tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">                tmp[j++]=str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]&gt;=<span class="string">'a'</span>&amp;&amp;str[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; tmp[j<span class="number">-1</span>]!=<span class="string">'_'</span> &amp;&amp;</span><br><span class="line">                   ( str[i<span class="number">-1</span>]&lt;<span class="string">'A'</span> || str[i<span class="number">-1</span>]&gt;<span class="string">'Z'</span> &amp;&amp;</span><br><span class="line">                     str[i<span class="number">-1</span>]&lt;<span class="string">'a'</span> || str[i<span class="number">-1</span>]&gt;<span class="string">'z'</span></span><br><span class="line">                    )</span><br><span class="line">                   )</span><br><span class="line">                    tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">                tmp[j++]=str[i]<span class="number">-32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; tmp[j<span class="number">-1</span>]!=<span class="string">'_'</span> &amp;&amp;</span><br><span class="line">                   ( str[i<span class="number">-1</span>]&lt;<span class="string">'0'</span>||str[i<span class="number">-1</span>]&gt;<span class="string">'9'</span> )</span><br><span class="line">                   )</span><br><span class="line">                    tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">                tmp[j++]=str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]=<span class="string">'_'</span>&amp;&amp;tmp[j<span class="number">-1</span>]!=<span class="string">'_'</span>)</span><br><span class="line">                tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[j<span class="number">-1</span>]!=<span class="string">'_'</span>)</span><br><span class="line">                    tmp[j++]=<span class="string">'_'</span>;</span><br><span class="line">                tmp[j++]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 小米 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 小米 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米2018校招在线考试-编程题三</title>
      <link href="/posts/%E5%B0%8F%E7%B1%B32018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/"/>
      <url>/posts/%E5%B0%8F%E7%B1%B32018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-密码破译"><a href="#题目-密码破译" class="headerlink" title="题目 密码破译"></a>题目 密码破译</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>我们来做一个简单的密码破译游戏。破译的规则很简单，将数字转换为字母，1转化为a，2转化为b，依此类推，26转化为z。现在输入的密码是一串数字，输出的破译结果是该数字串通过转换规则所能产生的所有字符串。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>多行数据，每行为一个数字串。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>多行数据，每行对应输出通过数字串破译得到的所有字符串，并按照字符串顺序排列，字符串之间用单个空格分隔。每行开头和结尾不允许有多余的空格。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>112123</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>aab labc aw lc</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li>神搜+剪枝</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==str.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count)<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val=str[i]-<span class="string">'0'</span>;</span><br><span class="line">    s.push_back((<span class="keyword">char</span>)(val+<span class="string">'a'</span><span class="number">-1</span>));</span><br><span class="line">    dfs(str,i+<span class="number">1</span>);</span><br><span class="line">    s.pop_back();</span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;str.length())</span><br><span class="line">    &#123;</span><br><span class="line">        val=val*<span class="number">10</span>+str[i+<span class="number">1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;=<span class="number">26</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push_back((<span class="keyword">char</span>)(val+<span class="string">'a'</span><span class="number">-1</span>));</span><br><span class="line">            dfs(str,i+<span class="number">2</span>);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        dfs(str,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 小米 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 小米 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米2018校招在线考试-编程题二</title>
      <link href="/posts/%E5%B0%8F%E7%B1%B32018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E5%B0%8F%E7%B1%B32018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-路径匹配"><a href="#题目-路径匹配" class="headerlink" title="题目 路径匹配"></a>题目 路径匹配</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>每个路径都形如&quot;/a/b...&quot;,不会以 &quot;/&quot; 结尾路径 &quot;/a/b&quot; 为路径 &quot;/a/b/c&quot; 的前缀路径,而并非 &quot;/a/bc&quot; 的前缀路径给出已知路径及编号,求某个路径的最大前缀路径的编号若不存在,输出 0</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>从第 1 行开始,直到某一行出现 &quot;-&quot; 为止,每行有两个字符串,第一个为路径,第二个为路径编号接下来每行一个路径</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>每行输出对应的路径的最大前缀路径的编号</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>/a 1/a/b 2/a/b/c 3/a/b/cde 4-/a/a/b/a/b/c/d/a/b/cd/b</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>12320</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><ul><li>root 结点编号为 0</li><li>若匹配完成或无法继续匹配,当前结点编号即为所求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,node*&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs,<span class="keyword">int</span> num,node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *tmp;</span><br><span class="line">    <span class="keyword">int</span> chnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        chnum=root-&gt;child.count(strs[i]);</span><br><span class="line">        <span class="keyword">if</span>(!chnum)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=<span class="keyword">new</span> node;</span><br><span class="line">            tmp-&gt;num=root-&gt;num;</span><br><span class="line">            root-&gt;child[strs[i]]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=root-&gt;child[strs[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        root=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;num=num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findway</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs,node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> chnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=strs.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==strs.size())</span><br><span class="line">            <span class="keyword">return</span> root-&gt;num;</span><br><span class="line">        chnum=root-&gt;child.count(strs[i]);</span><br><span class="line">        <span class="keyword">if</span>(!chnum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root=root-&gt;child[strs[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *root=<span class="keyword">new</span> node;</span><br><span class="line">    <span class="built_in">string</span> line,tmp;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    root-&gt;num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;line&amp;&amp;line[<span class="number">0</span>]!=<span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">        strs.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=line.length();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==line.length()||line[i]==<span class="string">'/'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                strs.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(line[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        build(strs,num,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;line)</span><br><span class="line">    &#123;</span><br><span class="line">        strs.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=line.length();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==line.length()||line[i]==<span class="string">'/'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                strs.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(line[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;findway(strs,root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 小米 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 小米 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人人公司2017校园招聘在线考试-编程一</title>
      <link href="/posts/%E4%BA%BA%E4%BA%BA%E5%85%AC%E5%8F%B82017%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E4%B8%80/"/>
      <url>/posts/%E4%BA%BA%E4%BA%BA%E5%85%AC%E5%8F%B82017%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-伪随机数"><a href="#题目-伪随机数" class="headerlink" title="题目-伪随机数"></a>题目-伪随机数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有一天小M得到了一个随机数生成器，它是这样工作的：* 首先你需要输入一个正整数n表示你要生成的随机数的位数。* 然后它会生成一个n位的不包含前导0的正十进制数。* 但是小M发现这个生成器有一个性质，它生成的数在第i位上(从左向右数)的数字永远不等于i。比如生成位数长度为1的数，那么它不会生成0和1；如果生成位数长度为2的数，它不会生成10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 22, 32, 42, 52, 62, 72, 82和92。现在小M想知道对于一个给定的输入n，它一共可能生成多少种不同的数？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一行包含一个整数n。1&lt;=n&lt;=100</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出对应的答案。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>1</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>8</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>递推公式 f(1)=8,f(n)=f(n-1)<em>10-f(n-1) (n&lt;=9),f(n)=f(9)</em>10^(n-9) (n&gt;9)</li><li>注意 n 的范围<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> c=<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=min(<span class="number">9</span>,n);++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c=<span class="number">10</span>*c-c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min(<span class="number">9</span>,n)+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> language </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中兴C++软件开发技术面试</title>
      <link href="/posts/%E4%B8%AD%E5%85%B4C-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/"/>
      <url>/posts/%E4%B8%AD%E5%85%B4C-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>今天早晨 10 点多突然接到了中兴面试通知,好激动好激动,<br><br>然后准备各种材料,四级成绩单丢了,,弄得很难受,六级差 14 分,很尴尬<br><br>匆匆忙忙买了高铁票,生怕迟到,结果证明,担心是多余的,早知道买火车<br><br>不过也还好,去得早面的早,回来的也早😂<br></p><p>面试过程如下,<br><br>两位面试官,并没有小姐姐,意料之中<br><br>面试官第一句话就是,???你不是山大的???,<br><br>楼主当然不是,要是山大,就成收割机了,要不这才校招第一面呢,<br><br>渣渣的心里阴影面积啊,,<br><br>让我自我介绍,学校,专业,巴拉巴拉的,<br><br>楼主心想,你不会自己看嘛,都在简历上,<br><br>楼主是真紧张,之前有个 IBM 电面,已经过去久远了,也是紧张的不行,<br><br>到也还能控制住,没太崩<br><br>来个自我介绍吧<br><br>说了说我那渣渣 SRT项目兼课题(当然不是我的课题,一个副教授的,智慧农业,谁让我是在农大)<br><br>又说了说我的渣渣竞赛,蓝桥杯,当时早知道还不如报个 PAT,那个气啊<br><br>面试官并没有问关于项目的事情,难道是因为我报的 C++ 然后项目是用 Java 做的原因?<br><br>有补充了自己最近在写的 HTTP 服务器,因为项目太少,决定拿这些协议的服务器充充数,<br><br>面试官问 了解堆和栈吗?说一下他们的区别吧,<br><br>楼主巴拉巴拉,有点紧张,说的有些浅,楼主加温了一句要不要说一下操作系统层面的那个栈,就是那个 SP 指向的栈,<br><br>面试官说不用了,就这些就行,其实我还想问,大根堆小根堆还要不要巴拉,<br><br>面试官让看两段代码,找一下,错误或不合适之处<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a=&apos;a&apos;;</span><br><span class="line">char *str=&amp;a;</span><br><span class="line">strcpy(str,&quot;Hello&quot;);</span><br><span class="line">printf(&quot;%s&quot;,str);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *str=&quot;abcde&quot;;</span><br><span class="line">str[0]=&apos;x&apos;;</span><br><span class="line">printf(&quot;%s&quot;,str);</span><br></pre></td></tr></table></figure><p>具体代码是啥记不清了,大约是这个样子的,<br><br>楼主直接忽略了细节问题,直接说的字符数组和字符指针,对就这样,<br><br>然后面试官就没再说啥,<br><br>面试官又问数据结构熟悉吗,我说当然熟悉啊,复习了一个星期呢😂,在七月份复习的<br><br>那来写一下压栈和出栈的函数实现吧,不要用C/C++的函数,<br><br>楼主傻傻的问了一句,数据类型需要自己定义吗,,,ԾㅂԾ,,,—是的<br><br>当时楼主默认用的 int 类型,现在想起来应该用模板,<br><br>由于考虑到在面试,就用了顺序表作为栈的存储空间,用链表得写老长时间了,还是顺序表快,<br><br>还好这次想着判断栈空栈满了,要不有后悔了,<br><br>就这样,手撕代码完了,<br><br>两位面试官看了,左边的那位问右边的那位好了吗,右边那位说好了又问左边的,<br><br>他俩统一了之后,跟渣楼说,好了面试就到这了,你可以回去等我们消息了,<br><br>楼主怯生生的问了句,我这个能过吗,面试官又重复了一边让我等消息,贼尴尬<br><br>然后我的十分钟面试就结束啦,<br><br>对了,面试官留了一份简历<br><br>在我之前的一个研究生大哥也是C++,面了也是二十分钟左右吧,<br><br>插一条,面试官还问我投了多少公司,我怎么可能说实话😂<br></p><p>PS:面试官挺好的,没有刁难人,比较舒服</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 中兴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 中兴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人人公司2017校园招聘在线考试-编程三</title>
      <link href="/posts/%E4%BA%BA%E4%BA%BA%E5%85%AC%E5%8F%B82017%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E4%B8%89/"/>
      <url>/posts/%E4%BA%BA%E4%BA%BA%E5%85%AC%E5%8F%B82017%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-液晶屏"><a href="#题目-液晶屏" class="headerlink" title="题目-液晶屏"></a>题目-液晶屏</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>小B就职于一家著名的液晶屏生产企业，随着消费电子品的爆发增长，公司的液晶产品供不应求。其中最受欢迎的产品型号为ABC001，产品的大小是a*b厘米。由于生产的原因，液晶屏的长宽都必须是整数。然而，流行的趋势总是不断变化的。近年来，随着消费用户群体的变化，液晶屏的长宽比也在变化，近期客户的大量订单都是x:y比例的。因此，公司计划将ABC001产品的长宽比变更为x:y的，同时希望显示总的显示区域面积尽可能的大。公司把这个任务交给小B。小B希望你能帮她解决这个问题，找出合适的屏幕尺寸，或者说明无法进行变更。你能帮助她吗？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>测试数据有多组，每组测试数据的包含四个整数a, b, x和y（1=&lt; a, b, x, y &lt;=2*10^9）。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>对每组测试数据，在单独的行中输出结果。若可以进行尺寸变更，输出变更后的屏幕尺寸，否则输出“0 0”。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>800 600 4 31920 1200 16 91 1 1 2</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>800 6001920 10800 0</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>直接 a/x,b/y 取最两结果最小值 m</li><li>m<em>x,m</em>y 就是答案</li><li>切记 x/y 一定要约分,不要问为啥</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;x)swap(x,y);</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        t=y,y=x%y,x=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,x,y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> com=comm(x,y);</span><br><span class="line">        x/=com,y/=com;</span><br><span class="line">        <span class="keyword">int</span> t=min(a/x,b/y);</span><br><span class="line">        <span class="keyword">if</span>(t)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x*t&lt;&lt;<span class="string">" "</span>&lt;&lt;y*t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0 0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> language </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人人公司2017校园招聘在线考试-编程二</title>
      <link href="/posts/%E4%BA%BA%E4%BA%BA%E5%85%AC%E5%8F%B82017%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E4%BA%8C/"/>
      <url>/posts/%E4%BA%BA%E4%BA%BA%E5%85%AC%E5%8F%B82017%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-最长子串"><a href="#题目-最长子串" class="headerlink" title="题目-最长子串"></a>题目-最长子串</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>小M得到了一个由小写英文字符构成的字符串，她想从中挑选出一个美丽的子串。一个字符串的子串是由其一段区间的字符所构成的字符串。小M不喜欢重复，所以她认为一个字符串是美丽的当且仅当它至多只包含Ca个字符’a’，Cb个字符’b’，…，Cz个字符’z’。请你帮她找出一个最长的美丽的子串。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一行包含一个字符串s。1≤s的长度≤10^5第二行包含26个整数表示0≤Ca，Cb……Cz≤10^9</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出最长的美丽子串的长度。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>aabaacaa10 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>5</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历字符串,统计每个字符出现的个数,类似于滑动窗口</li><li>如果符合,就继续扩大右端</li><li>若不符合,就缩小左端</li><li>更新最大长度</li><li>时间复杂度 O(n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100005</span>],n;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">26</span>],cnt[<span class="number">100005</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">        <span class="keyword">int</span> temp[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="keyword">sizeof</span> temp);</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;str[j];++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ++temp[str[j]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(temp[str[j]-<span class="string">'a'</span>]&gt;c[str[j]-<span class="string">'a'</span>])</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;=j;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                --temp[str[i]-<span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span>(str[j]==str[i])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=max(maxlen,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;maxlen&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> language </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯2018校招软件开发在线笔试-编程题二</title>
      <link href="/posts/%E8%85%BE%E8%AE%AF2018%E6%A0%A1%E6%8B%9B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E8%85%BE%E8%AE%AF2018%E6%A0%A1%E6%8B%9B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有两个数 a,b 只能进行以下操作* +1* *2现有 a,b,A,B 四个数,对 a,b 同时进行以上同样的操作,求最少多少步可以 a 变为 A,b 变为 B若不行则输出 -1</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>1 行 4 个数 a,b,A,B</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>最少步数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li>当 A 小于 a 或 B 小于 b,不可达</li><li>当 A 为偶数,可由 A/2 或 A-1 得到,A 为奇数,只能由 A-1 得到</li><li>对于其中 A,B 中只要有一个奇数,则只由 A-1,B-1 得到</li><li>优先搜索 *2 的情况,再搜索 +1 情况,若是搜索不到输出-1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 腾讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯2018校招软件开发在线笔试-编程题一</title>
      <link href="/posts/%E8%85%BE%E8%AE%AF2018%E6%A0%A1%E6%8B%9B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E8%85%BE%E8%AE%AF2018%E6%A0%A1%E6%8B%9B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给定一个 n 阶无向完全图,求第 1 个节点到第 2 个节点的最短距离,其中可以把 k 条边的距离减半</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第 1 行 n,k ,n-节点个数,k-可减半的边的条数2 到 n+1 行,包含 n 个 0-9 数字的字符串,为第 i 个节点到各个节点的距离对于所有合法的 i ,dis[i][i]=0;</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>1 行,最短路径</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li>无负权值,两点之间最短距离,Dijkstra算法,这是看到这个题的想法,然而,不对!</li><li>用 stack 记录路径,同时用 set 记录路径权值 , ksum 记录前 k 大权值和,sum 记录全路径权值和, </li><li>深搜全部路径,求出最小值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 腾讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 最短距离 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 无向图 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法</title>
      <link href="/posts/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
      <url>/posts/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>莫队算法可以解决一类可离线且在得到区间 [l,r] 的答案后可在 O(1) 或 O(log2 n) 的时间复杂度内得到 [l-1,r] 和 [l,r+1] 区间内的答案的问题</p><h3 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h3><p>对于区间 [l1,r1],[l2,r2] 从 [l1,r1] 到 [l2,r2] 的复杂度为 O(|l1-l2|+|r1-r2|),若把两个区间看成平面上的两个点,则复杂度为两点之间的曼哈顿距离</p><p>若是有 n 个区间,则可把 n 个区间看成 n 个点,所以,最小的花费就是连通这 n 个点的曼哈顿距离之和,即最小曼哈顿生成树</p><p>求曼哈顿最小生成树略麻烦,换一种方法</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>把查询区间按照左端点排序</li><li>把查询区间按照右端点排序</li><li>从左到右计算区间 [l,r] 内的解</li><li>调整 l,r 并修改</li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度 O(n*sqrt(n))</li><li>空间复杂度视情况而定</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>讲的不是很透彻,应该比较通俗,有不懂的可以看<a href="http://www.cnblogs.com/hzf-sbit/p/4056874.html" target="_blank" rel="noopener">莫队算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 区间问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日头条2018校园招聘后端方向-编程题一</title>
      <link href="/posts/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有一条手链上有 n 个串珠,每个串珠有不同的颜色,也可以是无色,颜色一共有 c 种,但是有个规定,在连续的 m 个串珠里颜色不能能重复,求重复的颜色有多少</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第 1 行 n,m,c第 2 到 n+1 行,每行第一个数为串珠的颜色数 ci,后跟 ci 个数为串珠的颜色1&lt;=n&lt;=10000,1&lt;=m&lt;=1000,1&lt;=c&lt;=50</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>重复的颜色的种类数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>5 2 33 1 2 302 2 31 21 3</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul><li>颜色转为二进制存储</li><li>使用滑动窗口遍历,窗口大小为 m,判断窗口内的重复情况</li><li>时间复杂度 O(n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,c,tc,tt,bad;</span><br><span class="line">ll balls[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;c;</span><br><span class="line">    <span class="built_in">memset</span>(balls,<span class="number">0</span>,<span class="keyword">sizeof</span> balls);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tc);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tc;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line">            balls[i]|=(<span class="number">1</span>&lt;&lt;tt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll badCF=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;m&gt;n?r&lt;n:l&lt;n;++r%=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((r-l+n)%n+<span class="number">1</span>&gt;m)</span><br><span class="line">                flag^=balls[l],++l;</span><br><span class="line">            badCF|=(flag&amp;balls[r]);</span><br><span class="line">            flag^=balls[r];</span><br><span class="line">        &#125;</span><br><span class="line">        bad=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(badCF)</span><br><span class="line">            badCF&amp;=(badCF<span class="number">-1</span>),++bad;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;bad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 今日头条 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 今日头条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日头条2018校园招聘后端方向-编程题二</title>
      <link href="/posts/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>一个数列长度为 n,现给出一个区间 [l,r] 及一个值 k,求区间内 k 值的个数</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第 1 行,一个数 n第 2 行,数列中的 n 个元素第 3 行,给定的区间数 q第 4 到 q+3 行,每行三个数 分别为 l,r,k</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>n 行,每个区间 qk 的个数, 和输入顺序相同</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>51 2 3 3 531 2 22 3 13 5 3</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>102</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h3><ul><li>读入所有查询区间,对区间排序,</li><li>莫队算法,用 map 维护 qk 出现的次数</li><li>时间复杂度 O(q<em>log q+n</em>log n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">301024</span>],n,q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,k,i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> question q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;q.l||l==q.l&amp;&amp;r&lt;q.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;questions[<span class="number">301024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> question q1,<span class="keyword">const</span> question q2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q1.i&lt;q2.i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;questions[i].l,&amp;questions[i].r,&amp;questions[i].k);</span><br><span class="line">        questions[i].i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(questions+<span class="number">1</span>,questions+q+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;kNum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=questions[<span class="number">1</span>].l;i&lt;=questions[<span class="number">1</span>].r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++kNum[k[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    questions[<span class="number">1</span>].k=kNum[questions[<span class="number">1</span>].k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(</span><br><span class="line">            <span class="keyword">int</span> l=questions[i<span class="number">-1</span>].l,r=questions[i<span class="number">-1</span>].r;</span><br><span class="line">            l!=questions[i].l||r!=questions[i].r;</span><br><span class="line">            )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;questions[i].l)</span><br><span class="line">                --kNum[k[l]],++l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;questions[i].l)</span><br><span class="line">                ++kNum[k[r]],--l;</span><br><span class="line">            <span class="keyword">if</span>(r&gt;questions[i].r)</span><br><span class="line">                --kNum[k[r]],--r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;questions[i].r)</span><br><span class="line">                ++kNum[k[r]],++r;</span><br><span class="line">        &#125;</span><br><span class="line">        questions[i].k=kNum[questions[i].k];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(questions+<span class="number">1</span>,questions+q+<span class="number">1</span>,comp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,questions[i].k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 今日头条 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 今日头条 </tag>
            
            <tag> 莫队算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日头条2018校园招聘后端方向-附加编程题</title>
      <link href="/posts/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91-%E9%99%84%E5%8A%A0%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/posts/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91-%E9%99%84%E5%8A%A0%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有一个字符串,只包含 26 个小写字母,相邻两个字母可以交换,给定一个字符串 str 及交换次数 m,试问在交换次数不超 m 的情况下,连续相同的字符长度最大是多少</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>1 行,一个字符串 str 及交换次数 m</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>最大连续相同的字符长度</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>abacaa 3</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>作者：桐ヶ谷和人</li><li>原文: <a href="https://www.nowcoder.com/discuss/39775" target="_blank" rel="noopener">今日头条2018校招编程题思路</a></li><li>枚举每种字母，计算该字母在字符串中出现的位置。</li><li>再枚举以该字符每个位置为中心点，两边的字符往这个中心靠拢，计算一个距离的前缀和， 再枚举左端点，二分找右端点。</li><li>复杂度O(26*|s|*|s|*log(|s|))</li></ul><iframe frameborder="0" src="http://paste.ubuntu.com/25506324/" width="120%" height="1250px" margin="20px -10% 20px -10%" scrolling="no"></iframe>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 今日头条 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 今日头条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巨人网络2018校招在线笔试-编程题一</title>
      <link href="/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>把 36 分为 3 个互不相同整数的乘积,并降序输出每个因子,中间以空格隔开</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>无</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>降序输出每个因子,中间以空格隔开</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>9 2 2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>神.推理.题</li><li>因为说是和某家的门牌号相同,而且还需要别的信息说明有多组对应一个门牌号</li><li>年龄最大的狗狗有点矮,说明年龄最大的狗狗年龄不重复</li></ul><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 巨人网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 推理 </tag>
            
            <tag> 巨人网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巨人网络2018校招在线笔试-编程题三</title>
      <link href="/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/"/>
      <url>/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>数列 1...n 当数列中的个数大于 1 时进行以下操作删除以一个元素,把新第一个元素放到末尾</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>一个数 n</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>最后剩余的 一个数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>3</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>队列</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>)</span><br><span class="line">q.pop(),q.push(q.front()),q.pop();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;q.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 巨人网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 巨人网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巨人网络2018校招在线笔试-代码题</title>
      <link href="/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
      <url>/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给定一个三角形 ABC,一点 P,求 P 是否在三角形 ABC 内部</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>点 P 和点 C 在 向量 AB 同侧</li><li>点 P 和点 B 在 向量 AC 同侧</li><li>点 P 和点 A 在 向量 BC 同侧</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">crossPro</span><span class="params">(<span class="keyword">int</span> o[<span class="number">2</span>],<span class="keyword">int</span> p1[<span class="number">2</span>],<span class="keyword">int</span> p2[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u[]=&#123;p1[<span class="number">0</span>]-o[<span class="number">0</span>],p1[<span class="number">1</span>]-o[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> v[]=&#123;p2[<span class="number">0</span>]-o[<span class="number">0</span>],p2[<span class="number">1</span>]-o[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">return</span> u[<span class="number">0</span>]*v[<span class="number">1</span>]-u[<span class="number">1</span>]*v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sameSide</span><span class="params">(<span class="keyword">int</span> ls[<span class="number">2</span>],<span class="keyword">int</span> le[<span class="number">2</span>],<span class="keyword">int</span> p1[<span class="number">2</span>],<span class="keyword">int</span> p2[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cP[<span class="number">2</span>];</span><br><span class="line">    cP[<span class="number">0</span>]=crossPro(ls,le,p1);</span><br><span class="line">    cP[<span class="number">1</span>]=crossPro(ls,le,p2);</span><br><span class="line">    <span class="keyword">return</span> cP[<span class="number">0</span>]*cP[<span class="number">1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inner</span><span class="params">(<span class="keyword">int</span> triangle[<span class="number">3</span>][<span class="number">2</span>],<span class="keyword">int</span> p[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sS[<span class="number">3</span>];</span><br><span class="line">    sS[<span class="number">0</span>]=sameSide(triangle[<span class="number">0</span>],triangle[<span class="number">1</span>],triangle[<span class="number">2</span>],p);</span><br><span class="line">    sS[<span class="number">1</span>]=sameSide(triangle[<span class="number">0</span>],triangle[<span class="number">2</span>],triangle[<span class="number">1</span>],p);</span><br><span class="line">    sS[<span class="number">2</span>]=sameSide(triangle[<span class="number">1</span>],triangle[<span class="number">2</span>],triangle[<span class="number">0</span>],p);</span><br><span class="line">    <span class="keyword">return</span> sS[<span class="number">0</span>]&amp;&amp;sS[<span class="number">1</span>]&amp;&amp;sS[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 巨人网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 巨人网络 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巨人网络2018校招在线笔试-编程题二</title>
      <link href="/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C2018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给定一个字符串,仅包括 A,L,O 三个字符,若 A 的个数大于 1,则字符串不符合规则若连续的 L 的个数大于 2,则字符串不符合规则</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>一个字符串</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>若符合规则输出 YES若不符合输出 NO</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>LLOLALL</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>YES</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>统计字符数…</li></ul><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 巨人网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 巨人网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴滴出行2018校园招聘网申笔试-研发工程师-编程题二</title>
      <link href="/posts/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C2018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%BD%91%E7%94%B3%E7%AC%94%E8%AF%95-%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C2018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%BD%91%E7%94%B3%E7%AC%94%E8%AF%95-%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>N</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>第 N 个丑数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>7</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>8</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>剑指offer 原题</li><li>定义 m2,m3,m5,c,now 分别为 2 的倍数,3 的倍数,5 的倍数,已找到的丑数个数,当前的丑数,</li><li>第 i 个丑数取 m2,m3,m5 三者中的最小值,然后更新 m2,m3,m5,c</li><li>时间复杂度 O(n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m2,m3,m5,c,now;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    now=c=<span class="number">1</span>;</span><br><span class="line">    m2=<span class="number">2</span>,m3=<span class="number">3</span>,m5=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        now=min(m2,min(m3,m5));</span><br><span class="line">        <span class="keyword">if</span>(m2==now) m2+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(m3==now) m3+=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(m5==now) m5+=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 滴滴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 滴滴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴滴出行2018校园招聘网申笔试-研发工程师-编程题一</title>
      <link href="/posts/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C2018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%BD%91%E7%94%B3%E7%AC%94%E8%AF%95-%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C2018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%BD%91%E7%94%B3%E7%AC%94%E8%AF%95-%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给出 n 个数字 a[i],,,a[n],问最多有多少不重复的非空区间,使得每个区间 内数字的 xor 都等于 0即找出最大的 k,使得存在 k 个区间 (l[i],r[i]),满足 1&lt;=l[i]&lt;=r[i]&lt;=n (1&lt;=i&lt;=k),r[i]&lt;l[i+1] (1&lt;=i&lt;=k)且 a[l[i]] xor a[l[i]+1] xor...xora[r[i]]=0 (1&lt;=i&lt;=k)</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第 1 行一个整数 n,第 2 行 n 个整数 a[i]...a[n]</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>1 个整数表示最多区间的个数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>43 0 2 2</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul><li>记开始处为 s=1,计数器 c=0</li><li>寻找第一个满足条件的连续子序列,假设为 i~j (s&lt;=i&lt;=j=n)</li><li>计数器 c=c+1</li><li>从 j+1 处开始,即 s=j+1,继续 2,3 步</li><li>最终计数器 c 即为所求</li><li>时间复杂度 O(n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1000010</span>],n,c;</span><br><span class="line"><span class="keyword">bool</span> bef_ext[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,s;</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bef_ext,<span class="number">0</span>,<span class="keyword">sizeof</span> bef_ext);</span><br><span class="line">    bef_ext[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,arr+i);</span><br><span class="line">        arr[i]^=arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(bef_ext[arr[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            ++c;</span><br><span class="line">            <span class="built_in">memset</span>(bef_ext,<span class="number">0</span>,<span class="keyword">sizeof</span> bef_ext);</span><br><span class="line">            bef_ext[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bef_ext[arr[i]]=<span class="number">1</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 滴滴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 滴滴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京东2018校招C++工程师笔试题-编程题二</title>
      <link href="/posts/%E4%BA%AC%E4%B8%9C2018%E6%A0%A1%E6%8B%9BC-%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E4%BA%AC%E4%B8%9C2018%E6%A0%A1%E6%8B%9BC-%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>一个十进制数字的各个位上的数若可以分成两部分 p1,p2,且两分内的元素之和 sum(p1)=sum(p2),则称这个数为神奇数 ,例如 242,可以分为 {2,2} 与 {4},且两部分元素之和都为 4,则 242 为神奇数.</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>1 行,两个数 l,r</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出 [l,r] 内神奇数的个数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>1 55</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>4</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h3><ul><li>对于每个数,穷举每个组合,判断是否为神奇数</li><li>判断是否是神奇数使用 dp</li><li>时间复杂度 O((l-r)<em>(log n)</em>(log r)) (log r &lt;= 9)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos[<span class="number">10</span>],nz=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=n%<span class="number">10</span>;</span><br><span class="line">        sum+=t;</span><br><span class="line">        <span class="keyword">if</span>(t)</span><br><span class="line">            pos[++nz]=t;</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sum&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> *dp=<span class="keyword">new</span> <span class="keyword">bool</span>[sum+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sort(pos+<span class="number">1</span>,pos+nz+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos[nz]&gt;sum)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nz;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=pos[i];--j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=dp[j]|dp[j-pos[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[sum])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[]dp;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] dp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r,l,c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        c+=check(l++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 京东 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 京东 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京东2018校招C++工程师笔试题-编程题一</title>
      <link href="/posts/%E4%BA%AC%E4%B8%9C2018%E6%A0%A1%E6%8B%9BC-%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E4%BA%AC%E4%B8%9C2018%E6%A0%A1%E6%8B%9BC-%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有一无限序列 arr 为 1,2,2,3,3,3,4,4,4,4,5,5,5,5,5......起始序号为 1,给出一个数字 n,求此无限序列的第 n 个数是多少</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>1 行, n, 1 &lt;= n &lt;= 1E+18</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出 arr(n)</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>15</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>13</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>假设此数列为一个对称矩阵的下三角</li><li>则必存在 i,j (1&lt;=j&lt;=i) 满足 n=i*(i-1)/2+j</li><li>整理得 i<em>i-i+2 &lt;= 2</em>n = i<em>i-i+2</em>j -&gt; i^2-i-2n+2&lt;=0</li><li>最终,整数 i 的值为 (1+√(8*n-7))/2 取整</li><li>时间复杂度 O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    r=(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">8</span>*n<span class="number">-7</span>))/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 京东 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 京东 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-分苹果</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E5%88%86%E8%8B%B9%E6%9E%9C/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E5%88%86%E8%8B%B9%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>每个输入包含一个测试用例。每个测试用例的第一行包含一个整数 n（1 &lt;= n &lt;= 100），接下来的一行包含 n 个整数 ai（1 &lt;= ai &lt;= 100）。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出一行表示最少需要移动多少次可以平分苹果，如果方案不存在则输出 -1。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>47 15 9 5</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>因为每次只能移动两个苹果,所以苹果的个数要么全为奇数,要么全为偶数,</li><li>苹果总数 sum 必须可以被奶牛数量 n 整除;</li><li>每个奶牛平均得到的苹果数的奇偶性应该和苹果初始的奇偶性相同</li><li>满足以上条件方案存在,计算输出最小移动次数;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> apples[<span class="number">101</span>],n,odd,even,sum,avg,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(apples,<span class="number">0</span>,<span class="keyword">sizeof</span> apples);</span><br><span class="line">        cnt=sum=odd=even=avg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;apples[i];</span><br><span class="line">            <span class="keyword">if</span>(apples[i]&amp;<span class="number">1</span>)++odd;</span><br><span class="line">            <span class="keyword">else</span> ++even;</span><br><span class="line">            sum+=apples[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(odd&amp;&amp;even)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        avg=sum/n;</span><br><span class="line">        <span class="keyword">if</span>(avg&amp;<span class="number">1</span>&amp;&amp;even||!(avg&amp;<span class="number">1</span>)&amp;&amp;odd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(apples[i]&gt;avg)</span><br><span class="line">                cnt+=apples[i]-avg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(cnt&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-地牢逃脱</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E5%9C%B0%E7%89%A2%E9%80%83%E8%84%B1/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E5%9C%B0%E7%89%A2%E9%80%83%E8%84%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给定一个 n 行 m 列的地牢，其中 &apos;.&apos; 表示可以通行的位置，&apos;X&apos; 表示不可通行的障碍，牛牛从 (x0 , y0 ) 位置出发，遍历这个地牢，和一般的游戏所不同的是，他每一步只能按照一些指定的步长遍历地牢，要求每一步都不可以超过地牢的边界，也不能到达障碍上。地牢的出口可能在任意某个可以通行的位置上。牛牛想知道最坏情况下，他需要多少步才可以离开这个地牢。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 50），表示地牢的长和宽。接下来的 n 行，每行 m 个字符，描述地牢，地牢将至少包含两个 &apos;.&apos;。接下来的一行，包含两个整数 x0, y0，表示牛牛的出发位置（0 &lt;= x0 &lt; n, 0 &lt;= y0 &lt; m，左上角的坐标为 （0, 0），出发位置一定是 &apos;.&apos;）。之后的一行包含一个整数 k（0 &lt; k &lt;= 50）表示牛牛合法的步长数，接下来的 k 行，每行两个整数 dx, dy 表示每次可选择移动的行和列步长（-50 &lt;= dx, dy &lt;= 50）</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出一行一个数字表示最坏情况下需要多少次移动可以离开地牢，如果永远无法离开，输出 -1。以下测试用例中，牛牛可以上下左右移动，在所有可通行的位置.上，地牢出口如果被设置在右下角，牛牛想离开需要移动的次数最多，为3次。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>3 3.........0 141 00 1-1 00 -1</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ul><li>辅助数组 dis[x][y],记录起点 p0 到 (x,y) 最小的距离, 值为 -1 表示不可达, 值为 0 表示 p0</li><li>辅助结构体 point,表示状态</li><li>辅助队列 points,记录状态</li><li>从起点开始广度搜索,记录状态,更新 dis</li><li>遍历 dis,其中最大不为 0 的值为距离 (已包含不可达状态)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,x,y,d,dir[<span class="number">50</span>][<span class="number">2</span>],dis[<span class="number">50</span>][<span class="number">50</span>],maxd;</span><br><span class="line"><span class="keyword">bool</span> unar=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> maps[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,deep;</span><br><span class="line">    point()&#123;&#125;;</span><br><span class="line">    point(<span class="keyword">int</span> x_,<span class="keyword">int</span> y_,<span class="keyword">int</span> d_)</span><br><span class="line">    &#123;</span><br><span class="line">        x=x_,y=y_,deep=d_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">point <span class="title">ahead</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point(x+dir[i][<span class="number">0</span>],y+dir[i][<span class="number">1</span>],deep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;maps[x][y]==<span class="string">'.'</span>&amp;&amp;(dis[x][y]&lt;<span class="number">0</span>||dis[x][y]&gt;deep));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point p,tp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;point&gt;points;</span><br><span class="line">    points.push(point(x,y,<span class="number">0</span>));</span><br><span class="line">    dis[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(points.size())</span><br><span class="line">    &#123;</span><br><span class="line">        p=points.front();</span><br><span class="line">        points.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d&amp;&amp;p.deep&lt;=dis[p.x][p.y];++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tp=p.ahead(i);</span><br><span class="line">            <span class="keyword">if</span>(tp.available())</span><br><span class="line">            &#123;</span><br><span class="line">                dis[tp.x][tp.y]=tp.deep;</span><br><span class="line">                points.push(tp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;t)&amp;&amp;t!=<span class="string">'.'</span>&amp;&amp;t!=<span class="string">'X'</span>);</span><br><span class="line">            maps[i][j]=t;</span><br><span class="line">            dis[i][j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;d);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;d;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;dir[i][<span class="number">0</span>],&amp;dir[i][<span class="number">1</span>]);</span><br><span class="line">    bfs();</span><br><span class="line">    maxd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]&gt;maxd)maxd=dis[i][j];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j]&lt;<span class="number">0</span>&amp;&amp;maps[i][j]==<span class="string">'.'</span>)unar=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!unar&amp;&amp;maxd)<span class="built_in">printf</span>(<span class="string">"%d"</span>,maxd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-分田地</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E5%88%86%E7%94%B0%E5%9C%B0/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E5%88%86%E7%94%B0%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>牛牛和 15 个朋友来玩打土豪分田地的游戏，牛牛决定让你来分田地，地主的田地可以看成是一个矩形，每个位置有一个价值。分割田地的方法是横竖各切三刀，分成 16 份，作为领导干部，牛牛总是会选择其中总价值最小的一份田地， 作为牛牛最好的朋友，你希望牛牛取得的田地的价值和尽可能大，你知道这个值最大可以是多少吗？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m（1 &lt;= n, m &lt;= 75），表示田地的大小，接下来的 n 行，每行包含 m 个 0-9 之间的数字，表示每块位置的价值。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出一行表示牛牛所能取得的最大的价值</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>4 43332323333322323</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><ul><li>定义数组 soil[i][j] 为第 0-i 行,0-j 列范围内的土地的总价值,</li><li>所以可以获得的最高价值 ans 一定在 (0,soil[n][m]) 内,</li><li>二分区间,判断中间值 mid 是否小于等于某一种分法中的最小价值,并进行二分区间变换</li><li>若是更新 ans</li><li>判断是否是最小值的方法是<ul><li>遍历所有横切 3 刀的情况<ul><li>纵切第 1 刀若判断是否是此列的最小值,</li><li>若是切下一刀,</li><li>若不是后移这一刀,继续判断</li><li>若始终无法纵向切下一刀,则继续遍历横向切法</li><li>若对于纵切 3 刀,形成的 4 列,mid 都满足价值最小的条件,返回 true</li></ul></li><li>若所有情况都不满足,返回 false</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> soil[<span class="number">76</span>][<span class="number">76</span>],m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> soil[x2][y2]-soil[x2][y1]-soil[x1][y2]+soil[x1][y1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMin</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-1</span>;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>,cnt=<span class="number">0</span>,pre=<span class="number">0</span>;k&lt;n;++k,cnt=<span class="number">0</span>,pre=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=m;++l)</span><br><span class="line">                    <span class="keyword">if</span>(getSum(<span class="number">0</span>,pre,i,l)&gt;=num&amp;&amp;</span><br><span class="line">                       getSum(i,pre,j,l)&gt;=num&amp;&amp;</span><br><span class="line">                       getSum(j,pre,k,l)&gt;=num&amp;&amp;</span><br><span class="line">                       getSum(k,pre,m,l)&gt;=num)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>((++cnt)==<span class="number">4</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        pre=l;</span><br><span class="line">                    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(soil,<span class="number">0</span>,<span class="keyword">sizeof</span> soil);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">                soil[i][j]=soil[i<span class="number">-1</span>][j]+soil[i][j<span class="number">-1</span>]-soil[i<span class="number">-1</span>][j<span class="number">-1</span>]+c-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=soil[m][n],mid,ans;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(isMin(mid))</span><br><span class="line">                l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-幸运的袋子</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E5%B9%B8%E8%BF%90%E7%9A%84%E8%A2%8B%E5%AD%90/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E5%B9%B8%E8%BF%90%E7%9A%84%E8%A2%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>一个袋子里面有n个球，每个球上面都有一个号码(拥有相同号码的球是无区别的)。如果一个袋子是幸运的当且仅当所有球的号码的和大于所有球的号码的积。例如：如果袋子里面的球的号码是{1, 1, 2, 3}，这个袋子就是幸运的，因为1 + 1 + 2 + 3 &gt; 1 * 1 * 2 * 3你可以适当从袋子里移除一些球(可以移除0个,但是别移除完)，要使移除后的袋子是幸运的。现在让你编程计算一下你可以获得的多少种不同的幸运的袋子。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一行输入一个正整数n(n ≤ 1000)第二行为n个数正整数xi(xi ≤ 1000)</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出可以产生的幸运的袋子数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>31 1 1</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>若 x,y 满足 x+y&gt;x*y,则 x/(x-1)&gt;y 或 y/(y-1)&gt;x,即 x=1 或 y=1;</li><li>所以想要满足幸运条件,1 的个数必须大于等于 1;</li><li>分情况讨论<ul><li>假设一共有 z 个 1 ( z&gt;=1 );</li><li>则全是 1 时,一共有 z-1 种情况;</li><li>从非 1 序列里选择任意数量数字,分别求其和 s 与积 p,(选择数字用 递归 实现)</li><li>若 p-s &gt; z-1,则说明不能构成幸运袋子</li><li>若 p-s &lt;= z-1,则可以构成 (z-(p-s)) 个幸运袋子</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1001</span>],one,n,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luckyPag</span><span class="params">(<span class="keyword">int</span> next,<span class="keyword">int</span> sum,ll product)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ts=sum+arr[next],tp=product*arr[next];</span><br><span class="line">    <span class="keyword">if</span>(tp-ts&lt;one)</span><br><span class="line">    &#123;</span><br><span class="line">        c+=one-tp+ts;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=next+<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            luckyPag(i,ts,tp);</span><br><span class="line">            <span class="keyword">while</span>(arr[i]==arr[i+<span class="number">1</span>])</span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    one=c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">1</span>)</span><br><span class="line">          ++one;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr,arr+n);</span><br><span class="line">    <span class="keyword">if</span>(one)</span><br><span class="line">    &#123;</span><br><span class="line">        c+=one<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=one;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            luckyPag(i,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(arr[i]==arr[i+<span class="number">1</span>])</span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-合唱团</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E5%90%88%E5%94%B1%E5%9B%A2/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E5%90%88%E5%94%B1%E5%9B%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;= n &lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;= ai &lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &lt;= k &lt;= 10, 1 &lt;= d &lt;= 50)。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出一行表示最大的乘积。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>37 4 72 50</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>49</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>定义 minstate(i,j),maxstate(i,j) 为从第 1 到第 j 个学生中选取 i 个学生后得到的乘积的最小与最大值,第 j 个学生必选;</li><li>因为能力值可能为负,所以必须维护最大值与最小值;</li><li>max(maxstate(m,x)) (m =&lt; x &lt;= n) 即为所求</li><li>状态转移方程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minstate(i,j) = |-&gt; min(minstate(i-1,x))*student(i)  ( student(i)&gt;=0 , j-m &lt;= x &lt;=j-1 )</span><br><span class="line">                |-&gt; max(maxstate(i-1,x))*student(i)  ( student(i)&lt;0 , j-m &lt;= x &lt;=j-1 )</span><br><span class="line"></span><br><span class="line">maxstate(i,j) = |-&gt; max(maxstate(i-1,x))*student(i)  ( student(i)&gt;=0 , j-m &lt;= x &lt;=j-1 )</span><br><span class="line">                |-&gt; min(minstate(i-1,x))*student(i)  ( student(i)&lt;0 , j-m &lt;= x &lt;=j-1 )</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line">ll *student,*minstate,*maxstate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,l,left,right;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    student=<span class="keyword">new</span> ll[n];</span><br><span class="line">    maxstate=<span class="keyword">new</span> ll[n];</span><br><span class="line">    minstate=<span class="keyword">new</span> ll[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;student[i]);</span><br><span class="line">        minstate[i]=maxstate[i]=student[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=n-m+i;j&gt;=i;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            left=max(i<span class="number">-1</span>,j-k),right=j<span class="number">-1</span>;</span><br><span class="line">            maxstate[j]=max(maxstate[j<span class="number">-1</span>]*student[j],minstate[j<span class="number">-1</span>]*student[j]);</span><br><span class="line">            minstate[j]=min(maxstate[j<span class="number">-1</span>]*student[j],minstate[j<span class="number">-1</span>]*student[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=right<span class="number">-1</span>;l&gt;=left;--l)</span><br><span class="line">            &#123;</span><br><span class="line">                maxstate[j]=max(maxstate[j],max(maxstate[l]*student[j],minstate[l]*student[j]));</span><br><span class="line">                minstate[j]=min(minstate[j],min(maxstate[l]*student[j],minstate[l]*student[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t=maxstate[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-2</span>;i&gt;=m;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxstate[i]&gt;t)t=maxstate[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,t);</span><br><span class="line">    <span class="keyword">delete</span>[] maxtate,<span class="keyword">delete</span>[] minstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-数列还原</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E6%95%B0%E5%88%97%E8%BF%98%E5%8E%9F/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E6%95%B0%E5%88%97%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>牛牛的作业薄上有一个长度为 n 的排列 A，这个排列包含了从1到n的n个数，但是因为一些原因，其中有一些位置（不超过 10 个）看不清了，但是牛牛记得这个数列顺序对的数量是 k，顺序对是指满足 i &lt; j 且 A[i] &lt; A[j] 的对数，请帮助牛牛计算出，符合这个要求的合法排列的数目。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>每个输入包含一个测试用例。每个测试用例的第一行包含两个整数 n 和 k（1 &lt;= n &lt;= 100, 0 &lt;= k &lt;= 1000000000），接下来的 1 行，包含 n 个数字表示排列 A，其中等于0的项表示看不清的位置（不超过 10 个）。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出一行表示合法的排列数目。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>5 54 0 0 2 0</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>计算已有序列的顺序对数 extPairs,</li><li>对于看不清的数字,进行全排列,</li><li>对于每一种全排列,<ul><li>计算此序列的顺序对数 newPairs </li><li>计算添加新的数字之后,已知序列增加的顺序对数 addPairs</li><li>若 extPairs+newPairs+addPairs==k 则合法排列数目 +1</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,m,o,arr[<span class="number">100</span>],add[<span class="number">100</span>],pos[<span class="number">100</span>],i,j,t,p,c;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">countPairs</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">                ++t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">countPairs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;o;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pos[i];++j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;add[i])</span><br><span class="line">                ++t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=pos[i];j&lt;m;++j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;add[i])</span><br><span class="line">                ++t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll extPair,newPair,addPair;</span><br><span class="line">    <span class="keyword">bool</span> flag[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span> flag);</span><br><span class="line">        c=p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=m=o=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">            <span class="keyword">if</span>(t)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[m++]=t;</span><br><span class="line">                flag[t]=<span class="number">1</span>;</span><br><span class="line">                p=m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pos[o++]=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                add[j++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        extPair=countPairs(arr,m);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            newPair=countPairs(add,o);</span><br><span class="line">            addPair=countPairs();</span><br><span class="line">            <span class="keyword">if</span>(extPair+newPair+addPair==k)</span><br><span class="line">                ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(next_permutation(add,add+o));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-混合颜料</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E6%B7%B7%E5%90%88%E9%A2%9C%E6%96%99/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E6%B7%B7%E5%90%88%E9%A2%9C%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>你就是一个画家！你现在想绘制一幅画，但是你现在没有足够颜色的颜料。为了让问题简单，我们用正整数表示不同颜色的颜料。你知道这幅画需要的n种颜色的颜料，你现在可以去商店购买一些颜料，但是商店不能保证能供应所有颜色的颜料，所以你需要自己混合一些颜料。混合两种不一样的颜色A和颜色B颜料可以产生(A XOR B)这种颜色的颜料(新产生的颜料也可以用作继续混合产生新的颜色,XOR表示异或操作)。本着勤俭节约的精神，你想购买更少的颜料就满足要求，所以兼职程序员的你需要编程来计算出最少需要购买几种颜色的颜料？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一行为绘制这幅画需要的颜色种数n (1 ≤ n ≤ 50)第二行为n个数xi(1 ≤ xi ≤ 1,000,000,000)，表示需要的各种颜料.</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出最少需要在商店购买的颜料颜色种数，注意可能购买的颜色不一定会使用在画中，只是为了产生新的颜色</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>31 7 3</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>类似求矩阵的秩,这里把 加减 操作换成了 异或 操作</li><li>用集合模板 set 来模拟矩阵的 初等变换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHighPos</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>,++c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t,c;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;need;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">        need.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> g=prev(need.end()),l=prev(g);</span><br><span class="line">    <span class="keyword">while</span>(need.size()&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(getHighPos(*g)==getHighPos(*l))</span><br><span class="line">        &#123;</span><br><span class="line">            need.insert((*g)^(*l));</span><br><span class="line">            g=prev(need.end()),l=prev(g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        g=prev(need.erase(g));</span><br><span class="line">        l=prev(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c+need.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客-星际穿越</title>
      <link href="/posts/%E7%89%9B%E5%AE%A2-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/"/>
      <url>/posts/%E7%89%9B%E5%AE%A2-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x2 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>每个输入包含一个测试用例。每个测试用例包含一行一个整数 h （1 &lt;= h &lt;= 10^18）</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出一行一个整数表示结果</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>10</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>2</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><ul><li>二分的范围为 [le,re], le=1, re=min(n,1E+9)</li><li>若 中点 m,m 满足 m*m+m==n ,结束二分;</li><li>若不满足,继续二分 直到 le&gt;re 为止</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,now,le,re,m,tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        le=<span class="number">1</span>,re=min(n,<span class="number">1000000000L</span>L);</span><br><span class="line">        <span class="keyword">while</span>(le&lt;=re)</span><br><span class="line">        &#123;</span><br><span class="line">            m=m=(le+re)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            tmp=m*m+m;</span><br><span class="line">            <span class="keyword">if</span>(tmp==n) </span><br><span class="line">            &#123;</span><br><span class="line">                now=m;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                now=m;</span><br><span class="line">                le=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                re=m<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;now&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数法"><a href="#函数法" class="headerlink" title="函数法"></a>函数法</h3><ul><li>假设发射消耗 x,则 x+x*x &lt;= n;</li><li>一元二次不等式求解得 x &lt;= (-1+sqrt(1+4n))/2</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,now,le,re,m,tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)(<span class="number">-1</span>+<span class="built_in">sqrt</span>(<span class="number">1</span>+<span class="number">4</span>*n))/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客 </category>
          
          <category> 2017校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 牛客 </tag>
            
            <tag> 2017校招 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜狗2018校招在线考试-编程题</title>
      <link href="/posts/%E6%90%9C%E7%8B%972018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/posts/%E6%90%9C%E7%8B%972018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>在一个圆上选定任意一点为原点 O,圆上任意一点的坐标为此点与原点 O 的顺时针夹角,即任意点的坐标区间为[0,360),定义两个点之间的距离为两点之间与圆心形成的最大圆心劣角的大小,现在给出 n 个圆上的点,求出这些点之间的最大距离,且保留至小数点后 8 位</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>n+1 行,第 1 行 n 为点的个数第 2 行到第 n+1 行为每个点的坐标</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>1 行,这些点之间的最大距离</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>410.00000000180.00000000183.00000000198.00000000</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>173.00000000</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>记录当前开始位置 s,终止位置 e</li><li>初始值 s=0,e=1</li><li>依次增大 e ,计算 s,e 之间的距离 d</li><li>当 s,e 之间的距离小于等于 180 时<ul><li>用 d 更新最大距离 maxd</li><li>向后移动 e</li></ul></li><li>若大于 180<ul><li>用 360-d 更新maxd</li><li>向后移动 s</li></ul></li><li>若 e&lt;n-1 重复 3-6 </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">double</span> *points=<span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;points[i];</span><br><span class="line">    sort(points,points+n);</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> d=<span class="number">0</span>,maxd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(e&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        d=points[e]-points[s];</span><br><span class="line">        <span class="keyword">if</span>(d&lt;=<span class="number">180</span>)</span><br><span class="line">            maxd=max(maxd,d),++e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxd=max(maxd,<span class="number">360</span>-d),++s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">8</span>)&lt;&lt;maxd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 搜狗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 搜狗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见C++面试题</title>
      <link href="/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/posts/%E5%B8%B8%E8%A7%81C-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>本文包含三篇转自互联网的文章</li><li>不同文章中有可能出现相同问题,也许解释相似,或许不同,建议仔细推敲,暂时因时间关系无法筛选</li><li>文章中或许有未解释问题,若别的文章里没有,有空时我会更新</li><li>略有改动,不影响阅读</li></ul><h3 id="C-面试出现频率最高的-30-道题目"><a href="#C-面试出现频率最高的-30-道题目" class="headerlink" title="C++ 面试出现频率最高的 30 道题目"></a>C++ 面试出现频率最高的 30 道题目</h3><ul><li>作者:<a href="http://my.csdn.net/shihui512" target="_blank" rel="noopener">王世晖</a></li><li>原文: <ul><li><a href="http://blog.csdn.net/wangshihui512/article/details/9092439" target="_blank" rel="noopener">C++ 面试出现频率最高的 30 道题目（一）</a></li><li><a href="http://blog.csdn.net/wangshihui512/article/details/9098655" target="_blank" rel="noopener">C++ 面试出现频率最高的 30 道题目（二）</a></li><li><a href="http://blog.csdn.net/wangshihui512/article/details/9182107" target="_blank" rel="noopener">C++ 面试出现频率最高的 30 道题目（三）</a></li></ul></li></ul><h4 id="new、delete、malloc、free-关系"><a href="#new、delete、malloc、free-关系" class="headerlink" title="new、delete、malloc、free 关系"></a>new、delete、malloc、free 关系</h4><ul><li>delete 会调用对象的析构函数,和 new 对应 free 只会释放内存，new 调用构造函数。</li><li>malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++ 的运算符。</li><li>它们都可用于申请动态内存和释放内存。</li><li>对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。</li><li>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。</li><li>由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。</li><li>因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。</li><li>注意 new/delete 不是库函数。</li></ul><h4 id="delete-与-delete-区别"><a href="#delete-与-delete-区别" class="headerlink" title="delete 与 delete[]区别"></a>delete 与 delete[]区别</h4><ul><li>delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。</li><li>在 More Effective C++ 中有更为详细的解释：“当 delete 操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operator delete 来释放内存。”</li><li>delete 与 new 配套，delete[] 与 new[] 配套</li><li>delete 和 delete[] 功能是相同的。对于自定义的复杂数据类型，delete 和 delete[]不能互用。delete[] 删除一个数组，delete 删除一个指针。</li><li>简单来说，用 new 分配的内存用 delete 删除；用 new[] 分配的内存用 delete[] 删除。elete[] 会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用 delete 时没用括号，delete 就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</li></ul><h4 id="C-有哪些性质（面向对象特点）"><a href="#C-有哪些性质（面向对象特点）" class="headerlink" title="C++有哪些性质（面向对象特点）"></a>C++有哪些性质（面向对象特点）</h4><p>封装，继承和多态。</p><h4 id="子类析构时要调用父类的析构函数吗？"><a href="#子类析构时要调用父类的析构函数吗？" class="headerlink" title="子类析构时要调用父类的析构函数吗？"></a>子类析构时要调用父类的析构函数吗？</h4><ul><li>析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。</li><li>定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。</li></ul><h4 id="多态，虚函数，纯虚函数"><a href="#多态，虚函数，纯虚函数" class="headerlink" title="多态，虚函数，纯虚函数"></a>多态，虚函数，纯虚函数</h4><ul><li>多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：<ul><li>在程序运行时的多态性通过继承和虚函数来体现；</li><li>在程序编译时多态性体现在函数和运算符的重载上；</li></ul></li><li>虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。</li><li>纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。<ul><li>从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。</li><li>抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。</li></ul></li></ul><h4 id="求下面函数的返回值（微软）"><a href="#求下面函数的返回值（微软）" class="headerlink" title="求下面函数的返回值（微软）"></a>求下面函数的返回值（微软）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> countx = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(x) </span><br><span class="line">    &#123; </span><br><span class="line">        countx ++; </span><br><span class="line">        x = x&amp;(x<span class="number">-1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> countx; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假定 x = 9999。 答案：8<br>思路：将 x 转化为 2 进制，看含有的 1 的个数。</p><h4 id="什么是“引用”？申明和使用“引用”要注意哪些问题？"><a href="#什么是“引用”？申明和使用“引用”要注意哪些问题？" class="headerlink" title="什么是“引用”？申明和使用“引用”要注意哪些问题？"></a>什么是“引用”？申明和使用“引用”要注意哪些问题？</h4><ul><li>引用就是某个目标变量的“别名” (alias)，对应用的操作与对变量直接操作效果完全相同。</li><li>申明一个引用的时候，切记要对其进行初始化。</li><li>引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。</li><li>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。</li><li>不能建立数组的引用。</li></ul><h4 id="将“引用”作为函数参数有哪些特点？"><a href="#将“引用”作为函数参数有哪些特点？" class="headerlink" title="将“引用”作为函数参数有哪些特点？"></a>将“引用”作为函数参数有哪些特点？</h4><ol><li>传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</li><li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</li><li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</li></ol><h4 id="在什么时候需要使用“常引用”？"><a href="#在什么时候需要使用“常引用”？" class="headerlink" title="在什么时候需要使用“常引用”？　"></a>在什么时候需要使用“常引用”？　</h4><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。<br><br>常引用声明方式：const 类型标识符 &amp;引用名 = 目标变量名；</p><ul><li>例1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ra=a;</span><br><span class="line">ra=<span class="number">1</span>; <span class="comment">//错误</span></span><br><span class="line">a=<span class="number">1</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>例2</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>;</span><br></pre></td></tr></table></figure><p>那么下面的表达式将是非法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar(foo());</span><br><span class="line">bar(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>原因在于 foo() 和 “hello world” 串都会产生一个临时对象，而在 C++ 中，这些临时对象都是 const 类型的。因此上面的表达式就是试图将一个 const 类型的对象转换为非 const 类型，这是非法的。引用型参数应该在能被定义为 const 的情况下，尽量定义为 const。</p><h4 id="将“引用”作为函数返回值类型的格式、好处和需要遵守的规则"><a href="#将“引用”作为函数返回值类型的格式、好处和需要遵守的规则" class="headerlink" title="将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?"></a>将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?</h4><ul><li>格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 }</li><li>好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! </li><li>注意事项：<ul><li>不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</li><li>不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。</li><li>可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</li></ul></li><li>流操作符重载返回值申明为“引用”的作用：<ul><li>流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。</li><li>可选的其它方案包括：返回一个流对象和返回一个流对象指针。</li><li>但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 </li></ul></li><li>赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">＃include&lt;iostream&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> vals[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> error=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">put(<span class="number">0</span>)=<span class="number">10</span>; <span class="comment">//以put(0)函数值作为左值，等价于vals[0]=10; </span></span><br><span class="line">put(<span class="number">9</span>)=<span class="number">20</span>; <span class="comment">//以put(9)函数值作为左值，等价于vals[9]=20; </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vals[<span class="number">0</span>]; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vals[<span class="number">9</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&gt;=<span class="number">0</span> &amp;&amp; n&lt;=<span class="number">9</span> ) <span class="keyword">return</span> vals[n]; </span><br><span class="line"><span class="keyword">else</span> &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"subscript error"</span>; <span class="keyword">return</span> error; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1] 的 Item23 详细的讨论了这个问题。主要原因是这四个操作符没有 side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个 new 分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第 2、3 两个方案都被否决了。静态对象的引用又因为 ((a+b)==(c+d)) 会永远为 true 而导致错误。所以可选的只剩下返回一个对象了。</li></ul><h4 id="结构与联合有和区别？"><a href="#结构与联合有和区别？" class="headerlink" title="结构与联合有和区别？"></a>结构与联合有和区别？</h4><ol><li>结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 </li><li>对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</li></ol><h4 id="试写出程序结果："><a href="#试写出程序结果：" class="headerlink" title="试写出程序结果："></a>试写出程序结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  a=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;    a=a+x;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(t)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a = 9</span></span><br><span class="line">    f(t)=<span class="number">20</span>;<span class="comment">//a = 20</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(t)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//t = 5,a = 20 -&gt; a = 25</span></span><br><span class="line">    t=f(t);<span class="comment">//a = 30 t = 30</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(t)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//t = 60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重载-overload-和重写-overried，有的书也叫做“覆盖”）的区别？"><a href="#重载-overload-和重写-overried，有的书也叫做“覆盖”）的区别？" class="headerlink" title="重载 ( overload ) 和重写( overried，有的书也叫做“覆盖”）的区别？"></a>重载 ( overload ) 和重写( overried，有的书也叫做“覆盖”）的区别？</h4><ul><li><p>从定义上来说：</p><ul><li>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</li><li>重写：是指子类重新定义父类虚函数的方法。</li></ul></li><li><p>从实现原理上来说：</p><ul><li>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！</li><li>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。</li></ul></li></ul><h4 id="有哪几种情况只能用-intialization-list-而不能用-assignment"><a href="#有哪几种情况只能用-intialization-list-而不能用-assignment" class="headerlink" title="有哪几种情况只能用 intialization list 而不能用 assignment ?"></a>有哪几种情况只能用 intialization list 而不能用 assignment ?</h4><p>当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。</p><h4 id="C-是不是类型安全的？"><a href="#C-是不是类型安全的？" class="headerlink" title="C++ 是不是类型安全的？"></a>C++ 是不是类型安全的？</h4><p>不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。</p><h4 id="main-函数执行以前，还会执行什么代码？"><a href="#main-函数执行以前，还会执行什么代码？" class="headerlink" title="main 函数执行以前，还会执行什么代码？"></a>main 函数执行以前，还会执行什么代码？</h4><p>全局对象的构造函数会在main 函数之前执行。</p><h4 id="描述内存分配方式以及它们的区别"><a href="#描述内存分配方式以及它们的区别" class="headerlink" title="描述内存分配方式以及它们的区别?"></a>描述内存分配方式以及它们的区别?</h4><ol><li>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。</li><li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。</li><li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</li></ol><h4 id="分别写出-bool-int-float-指针类型的变量-a-与“零”的比较语句。"><a href="#分别写出-bool-int-float-指针类型的变量-a-与“零”的比较语句。" class="headerlink" title="分别写出 bool,int,float,指针类型的变量 a 与“零”的比较语句。"></a>分别写出 bool,int,float,指针类型的变量 a 与“零”的比较语句。</h4><ul><li>bool : if(!a) or if(a)</li><li>int : if(a==0) 或 if(!a)</li><li>float : const EXPRESSION EXP=0.000001  if (a&lt;EXP &amp;&amp; a&gt;-EXP)</li><li>pointer : if (a != NULL) or if(a == NULL)</li></ul><h4 id="请说出-const-与-define-相比，有何优点？"><a href="#请说出-const-与-define-相比，有何优点？" class="headerlink" title="请说出 const 与 #define 相比，有何优点？"></a>请说出 const 与 #define 相比，有何优点？</h4><p>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p><ol><li>const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</li><li>有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</li></ol><h4 id="简述数组与指针的区别？"><a href="#简述数组与指针的区别？" class="headerlink" title="简述数组与指针的区别？"></a>简述数组与指针的区别？</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p><ol><li><p>修改内容上的差别</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”;</span><br><span class="line">a[<span class="number">0</span>] = ‘X’;</span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，运行时错误</span></span><br></pre></td></tr></table></figure></li><li><p>用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br><span class="line"><span class="comment">//计算数组和指针的内存容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="int-s-10-int-表示的是什么？"><a href="#int-s-10-int-表示的是什么？" class="headerlink" title="int (*s[10])(int) 表示的是什么？"></a>int (*s[10])(int) 表示的是什么？</h4><p>int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。</p><h4 id="栈内存与文字常量区"><a href="#栈内存与文字常量区" class="headerlink" title="栈内存与文字常量区"></a>栈内存与文字常量区</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str7 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *str8 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str1 == str2 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str3 == str4 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str5 == str6 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str7 == str8 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br></pre></td></tr></table></figure><ul><li>结果是：0 0 1 1</li><li>解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。</li></ul><h4 id="将程序跳转到指定内存地址"><a href="#将程序跳转到指定内存地址" class="headerlink" title="将程序跳转到指定内存地址"></a>将程序跳转到指定内存地址</h4><p>要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)( ))<span class="number">0x100000</span>) ( );</span><br><span class="line"><span class="comment">//首先要将0x100000强制转换成函数指针,即:</span></span><br><span class="line">(<span class="keyword">void</span> (*)())<span class="number">0x100000</span></span><br><span class="line"><span class="comment">//然后再调用它:</span></span><br><span class="line">*((<span class="keyword">void</span> (*)())<span class="number">0x100000</span>)();</span><br><span class="line"><span class="comment">//用typedef可以看得更直观些:</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*)</span><span class="params">()</span> voidFuncPtr</span>;</span><br><span class="line">*((voidFuncPtr)<span class="number">0x100000</span>)();</span><br></pre></td></tr></table></figure><h4 id="int-id-sizeof-unsigned-long-这个对吗？为什么？"><a href="#int-id-sizeof-unsigned-long-这个对吗？为什么？" class="headerlink" title="int id[sizeof(unsigned long)]; 这个对吗？为什么？"></a>int id[sizeof(unsigned long)]; 这个对吗？为什么？</h4><p>正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。</p><h4 id="引用与指针有什么区别？"><a href="#引用与指针有什么区别？" class="headerlink" title="引用与指针有什么区别？"></a>引用与指针有什么区别？</h4><ol><li>引用必须被初始化，指针不必。</li><li>引用初始化以后不能被改变，指针可以改变所指的对象。</li><li>不存在指向空值的引用，但是存在指向空值的指针。</li></ol><h4 id="const-与-define-的比较，const有什么优点"><a href="#const-与-define-的比较，const有什么优点" class="headerlink" title="const 与 #define 的比较，const有什么优点?"></a>const 与 #define 的比较，const有什么优点?</h4><ol><li>const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。</li><li>有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</li></ol><h4 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * ( * (*fp1)(<span class="keyword">int</span>))[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">float</span> (*(* fp2)(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>))(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (* ( * fp3)())[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure><p>分别表示什么意思？</p><ol><li><p>void * ( * (*fp1)(int))[10];</p><p> fp1是一个指针，指向一个函数，这个函数的参数为int型，<br> 函数的返回值是一个指针，这个指针指向一个数组，<br> 这个数组有10个元素，每个元素是一个void*型指针。</p></li><li><p>float (<em>(</em> fp2)(int,int,int))(int);</p><p> fp2是一个指针，指向一个函数，这个函数的参数为3个int型，<br> 函数的返回值是一个指针，这个指针指向一个函数，<br> 这个函数的参数为int型，函数的返回值是float型。</p></li><li><p>int (* ( * fp3)())[10]();</p><p> fp3是一个指针，指向一个函数，这个函数的参数为空，<br> 函数的返回值是一个指针，这个指针指向一个数组，<br> 这个数组有10个元素，每个元素是一个指针，指向一个函数，<br> 这个函数的参数为空，函数的返回值是int型。</p></li></ol><h4 id="内存的分配方式有几种"><a href="#内存的分配方式有几种" class="headerlink" title="内存的分配方式有几种?"></a>内存的分配方式有几种?</h4><ol><li>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</li><li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</li></ol><h4 id="基类的析构函数不是虚函数，会带来什么问题？"><a href="#基类的析构函数不是虚函数，会带来什么问题？" class="headerlink" title="基类的析构函数不是虚函数，会带来什么问题？"></a>基类的析构函数不是虚函数，会带来什么问题？</h4><p>派生类的析构函数用不上，会造成资源的泄漏。</p><h4 id="全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"><a href="#全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？" class="headerlink" title="全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"></a>全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</h4><p>生命周期不同：</p><ul><li>全局变量随主程序创建和创建，随主程序销毁而销毁；</li><li>局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</li></ul><p>使用方式不同：</p><ul><li>通过声明后全局变量程序的各个部分都可以用到；</li><li>局部变量只能在局部使用；分配在栈区。 </li></ul><p>操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p><h3 id="C-面试集锦-面试被问到的问题"><a href="#C-面试集锦-面试被问到的问题" class="headerlink" title="C++面试集锦( 面试被问到的问题 )"></a>C++面试集锦( 面试被问到的问题 )</h3><ul><li>作者:<a href="http://www.cnblogs.com/Y1Focus" target="_blank" rel="noopener">Y1</a></li><li>原文:<a href="http://www.cnblogs.com/Y1Focus/p/6707121.html" target="_blank" rel="noopener">C++面试集锦( 面试被问到的问题 )</a></li></ul><h4 id="C-和-C-区别"><a href="#C-和-C-区别" class="headerlink" title="C 和 C++ 区别"></a>C 和 C++ 区别</h4><ul><li>C 语言是面向过程的语言</li><li>C++ 是基于 C 语言开发的面向对象的语言,兼具面向对象与面向过程</li></ul><h4 id="const-有什么用途"><a href="#const-有什么用途" class="headerlink" title="const 有什么用途"></a>const 有什么用途</h4><p>主要有三点：</p><ol><li>定义只读变量，即常量</li><li>修饰函数的参数和函数的返回值 </li><li>修饰函数的定义体，这里的函数为类的成员函数，被 const 修饰的成员函数代表不修改成员变量的值</li></ol><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol><li>引用是变量的一个别名，内部实现是只读指针</li><li>引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变</li><li>引用不能为 NULL，指针可以为 NULL</li><li>引用变量内存单元保存的是被引用变量的地址</li><li>“sizeof 引用” = 指向变量的大小 ， “sizeof 指针”= 指针本身的大小</li><li>引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址</li><li>引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址</li></ol><h4 id="C-中有了-malloc-free-为什么还需要-new-delete"><a href="#C-中有了-malloc-free-为什么还需要-new-delete" class="headerlink" title="C++中有了 malloc/free , 为什么还需要 new/delete"></a>C++中有了 malloc/free , 为什么还需要 new/delete</h4><ol><li>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。</li><li>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。<ol><li>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。</li><li>由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。</li></ol></li><li>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。</li></ol><h4 id="编写类-String-的构造函数，析构函数，拷贝构造函数和赋值函数"><a href="#编写类-String-的构造函数，析构函数，拷贝构造函数和赋值函数" class="headerlink" title="编写类 String 的构造函数，析构函数，拷贝构造函数和赋值函数"></a>编写类 String 的构造函数，析构函数，拷贝构造函数和赋值函数</h4><h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><h4 id="单链表的逆置"><a href="#单链表的逆置" class="headerlink" title="单链表的逆置"></a>单链表的逆置</h4><h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><p>一个由c/C++编译的程序占用的内存分为以下几个部分</p><ol><li><p>栈区（stack）― 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </p></li><li><p>堆区（heap）― 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。</p><p> 注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</p></li><li><p>全局区（静态区）（static）― 全局变量和静态变量的存储是strcpy放在一块的，</p><p> 初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域<br> 程序结束后有系统释放 </p></li><li><p>文字常量区 ― 常量字符串就是放在这里的。 程序结束后由系统释放 </p></li><li><p>程序代码区―存放函数体的二进制代码。</p></li></ol><h4 id="不调用-C-C-的字符串库函数，编写-strcpy"><a href="#不调用-C-C-的字符串库函数，编写-strcpy" class="headerlink" title="不调用 C/C++ 的字符串库函数，编写 strcpy"></a>不调用 C/C++ 的字符串库函数，编写 strcpy</h4><p><a href="http://www.cnblogs.com/chenyg32/p/3739564.html" target="_blank" rel="noopener">strcpy函数的实现</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * strDest,<span class="keyword">const</span> <span class="keyword">char</span> * strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((strDest==<span class="literal">NULL</span>)||strSrc==<span class="literal">NULL</span>))                     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">char</span> * strDestCopy=strDest; </span><br><span class="line">    <span class="keyword">while</span> ((*strDest++=*strSrc++)!=<span class="string">'\0'</span>); </span><br><span class="line">    *strDest = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键字-static-的作用"><a href="#关键字-static-的作用" class="headerlink" title="关键字 static 的作用"></a>关键字 static 的作用</h4><ol><li>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</li><li>在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li><li>在模块内的 static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内</li><li>在类的 static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝</li><li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量</li></ol><p>介绍它最重要的一条：隐藏。（static函数，static变量均可） –&gt; 对应上面的 2、3 项<br><br>当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。<br><br>举例来说明。同时编译两个源文件，一个是 a.c，另一个是 main.c。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//a.c</span><br><span class="line">char a = &apos;A&apos;;// global variable</span><br><span class="line">void msg()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//main.c</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    extern char a;// extern variable must be declared before use</span><br><span class="line">    printf(&quot;%c &quot;, a);</span><br><span class="line">    (void)msg();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果是：</span><br><span class="line">A Hello</span><br></pre></td></tr></table></figure><p>为什么在 a.c 中定义的全局变量 a 和函数 msg能在 main.c 中使用？</p><ul><li>前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a 是全局变量，msg是函数，并且都没有加 static 前缀，</li><li>因此对于另外的源文件 main.c 是可见的。</li><li>如果加了 static，就会对其它源文件隐藏。例如在 a 和 msg 的定义前加上 static，main.c 就看不到它们了。</li><li>利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏</li></ul><h4 id="在-C-程序中调用被-C-编译器编译后的函数，为什么要加-extern-“C”"><a href="#在-C-程序中调用被-C-编译器编译后的函数，为什么要加-extern-“C”" class="headerlink" title="在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”"></a>在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”</h4><p>C++语言支持函数重载，C语言不支持函数重载，函数被C++编译器编译后在库中的名字与C语言的不同<br><br>假设某个函数原型为：</p><pre><code>void foo(int x, inty);</code></pre><ul><li>该函数被C编译器编译后在库中的名字为:  _foo</li><li>而C++编译器则会产生像: _foo_int_int 之类的名字。</li><li>为了解决此类名字匹配的问题，C++提供了C链接交换指定符号 extern “C”。</li></ul><h4 id="头文件种的-ifndef-define-endif-是干什么用的"><a href="#头文件种的-ifndef-define-endif-是干什么用的" class="headerlink" title="头文件种的 ifndef/define/endif 是干什么用的"></a>头文件种的 ifndef/define/endif 是干什么用的</h4><p>防止头文件被重复包含</p><h4 id="线程和进程的联系和区别"><a href="#线程和进程的联系和区别" class="headerlink" title="线程和进程的联系和区别"></a>线程和进程的联系和区别</h4><p><a href="http://blog.csdn.net/morewindows/article/details/7392749" target="_blank" rel="noopener">秒杀多线程第一篇 多线程笔试面试题汇总</a></p><h4 id="线程有哪几种状态"><a href="#线程有哪几种状态" class="headerlink" title="线程有哪几种状态"></a>线程有哪几种状态</h4><p><a href="http://blog.csdn.net/morewindows/article/details/7392749" target="_blank" rel="noopener">秒杀多线程第一篇 多线程笔试面试题汇总</a></p><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>管道、有名管道、信号、共享内存、消息队列、信号量、套接字、文件.</p><h4 id="线程同步和线程互斥的区别"><a href="#线程同步和线程互斥的区别" class="headerlink" title="线程同步和线程互斥的区别"></a>线程同步和线程互斥的区别</h4><p><a href="http://blog.csdn.net/morewindows/article/details/7392749" target="_blank" rel="noopener">秒杀多线程第一篇 多线程笔试面试题汇总</a></p><h4 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h4><p>Linux: 互斥锁、条件变量和信号量<br><br><a href="http://blog.csdn.net/zsf8701/article/details/7844316" target="_blank" rel="noopener">Linux 线程同步的三种方法</a></p><h4 id="网络七层"><a href="#网络七层" class="headerlink" title="网络七层"></a>网络七层</h4><p>物理层-数据链路层-网络层-运输层-会话层-表示层-应用层</p><h4 id="TCP-和-UDP-有什么区别"><a href="#TCP-和-UDP-有什么区别" class="headerlink" title="TCP 和 UDP 有什么区别"></a>TCP 和 UDP 有什么区别</h4><ul><li>TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。<ul><li>当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。</li><li>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</li></ul></li><li>UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。<ul><li>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</li><li>由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</li></ul></li></ul><h4 id="编写-Socket-套接字的步骤"><a href="#编写-Socket-套接字的步骤" class="headerlink" title="编写 Socket 套接字的步骤"></a>编写 Socket 套接字的步骤</h4><h4 id="TCP-三次握手和四次挥手-以及各个状态的作用"><a href="#TCP-三次握手和四次挥手-以及各个状态的作用" class="headerlink" title="TCP 三次握手和四次挥手, 以及各个状态的作用"></a>TCP 三次握手和四次挥手, 以及各个状态的作用</h4><p><a href="http://www.cnblogs.com/zmlctt/p/3690998.html" target="_blank" rel="noopener">TCP三次握手四次挥手详解</a></p><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><ul><li>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，</li><li>HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</li><li>TCP 和 HTTP区别：<a href="http://blog.csdn.net/lemonxuexue/article/details/4485877" target="_blank" rel="noopener">TCP和Http的区别</a></li></ul><h4 id="使用过的-shell-命令"><a href="#使用过的-shell-命令" class="headerlink" title="使用过的 shell 命令"></a>使用过的 shell 命令</h4><ul><li>pwd ,man ,cd</li><li>cp ,mv ,rm ,mkdir ,touch ,ls ,cat ,tail ,less ,df ,du ,find</li><li>top ,kill ,sudo  </li></ul><h4 id="使用过的-vim-命令"><a href="#使用过的-vim-命令" class="headerlink" title="使用过的 vim 命令"></a>使用过的 vim 命令</h4><ul><li>wq!, dd , dw , yy , p , i</li><li>%s/old/new/g<ul><li>/abc 向后搜索字符串ab</li><li>?abc 向前搜索字符串abc</li></ul></li></ul><h4 id="使用过的-gdb-命令"><a href="#使用过的-gdb-命令" class="headerlink" title="使用过的 gdb 命令"></a>使用过的 gdb 命令</h4><p><a href="http://blog.csdn.net/dadalan/article/details/3758025" target="_blank" rel="noopener">比较全面的gdb调试命令</a></p><h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><p>快速排序、堆排序和归并排序</p><ul><li><a href="http://blog.csdn.net/xiaoxiaoxuewen/article/details/7570621" target="_blank" rel="noopener">堆排序原理及算法实现（最大堆）</a></li><li><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">白话经典算法系列之六 快速排序 快速搞定</a></li><li><a href="http://baike.baidu.com/link?url=ueoZ3sNIOvMNPrdCKbd8mhfebC85B4nRc-7hPEJWi-hFo5ROyWH2Pxs9RtvLFRJL" target="_blank" rel="noopener">排序算法稳定性</a></li></ul><h4 id="C-库函数实现"><a href="#C-库函数实现" class="headerlink" title="C 库函数实现"></a>C 库函数实现</h4><h4 id="静态链表和动态链表的区别"><a href="#静态链表和动态链表的区别" class="headerlink" title="静态链表和动态链表的区别"></a>静态链表和动态链表的区别</h4><p><a href="http://blog.csdn.net/toonny1985/article/details/4868786" target="_blank" rel="noopener">静态链表和动态链表</a></p><h4 id="大并发-epoll"><a href="#大并发-epoll" class="headerlink" title="大并发 (epoll)"></a>大并发 (epoll)</h4><ul><li>优点:<a href="http://blog.csdn.net/sunyurun/article/details/8194979" target="_blank" rel="noopener">深入linux网络编程（三）：异步阻塞IO —— epoll</a></li><li>实例：<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324974.html" target="_blank" rel="noopener">Linux IO多路复用之epoll网络编程(含源码)</a></li></ul><h4 id="海量数据处理的知识点（Hash表，Hash统计）"><a href="#海量数据处理的知识点（Hash表，Hash统计）" class="headerlink" title="海量数据处理的知识点（Hash表，Hash统计）"></a>海量数据处理的知识点（Hash表，Hash统计）</h4><ul><li><a href="http://www.cnblogs.com/dolphin0520/archive/2012/09/28/2700000.html" target="_blank" rel="noopener">hash表</a></li><li><a href="http://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="noopener">教你如何迅速秒杀掉：99%的海量数据处理面试题</a></li></ul><h4 id="什么时候要用虚析构函数"><a href="#什么时候要用虚析构函数" class="headerlink" title="什么时候要用虚析构函数"></a>什么时候要用虚析构函数</h4><p>通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚的。否则其删除效果将无法实现。<br><br>一般情况下，这样的删除只能够删除基类对象，而不能删除子类对象，形成了删除一半形象，从而千万内存泄漏。<br><br>原因：</p><pre><code>在公有继承中，基类对派生类及其对象的操作，只能影响到那些从基类继承下来的成员。如果想要用基类对非继承成员进行操作，则要把基类的这个操作（函数）定义为虚函数。那么，析构函数自然也应该如此：如果它想析构子类中的重新定义或新的成员及对象，当然也应该声明为虚的。</code></pre><p>注意：</p><pre><code>如果不需要基类对派生类及对象进行操作，则不能定义虚函数（包括虚析构函数），因为这样会增加内存开销。</code></pre><h4 id="C-怎样让返回对象的函数不调用拷贝构造函数"><a href="#C-怎样让返回对象的函数不调用拷贝构造函数" class="headerlink" title="C++ 怎样让返回对象的函数不调用拷贝构造函数"></a>C++ 怎样让返回对象的函数不调用拷贝构造函数</h4><p>拷贝构造函数前加 “explicit” 关键字</p><h4 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h4><p><a href="http://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程-总结</a></p><h4 id="请用简单的语言告诉我-C-是什么？"><a href="#请用简单的语言告诉我-C-是什么？" class="headerlink" title="请用简单的语言告诉我 C++ 是什么？"></a>请用简单的语言告诉我 C++ 是什么？</h4><ul><li>C++ 是在 C 语言的基础上开发的一种面向对象编程语言，应用广泛。</li><li>C++ 支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。</li><li>其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一</li><li>支持类、封装、重载等特性!</li></ul><h4 id="C-和-C-的区别？"><a href="#C-和-C-的区别？" class="headerlink" title="C 和 C++ 的区别？"></a>C 和 C++ 的区别？</h4><ul><li>C++ 在 C 的基础上增添类，C 是一个结构化语言，它的重点在于算法和数据结构。</li><li>C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）</li><li>而对于 C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。<h4 id="什么是面向对象（OOP）？"><a href="#什么是面向对象（OOP）？" class="headerlink" title="什么是面向对象（OOP）？"></a>什么是面向对象（OOP）？</h4>面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。</li></ul><h4 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h4><ul><li>多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。</li><li>不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。</li></ul><h4 id="设计模式懂嘛，简单举个例子？"><a href="#设计模式懂嘛，简单举个例子？" class="headerlink" title="设计模式懂嘛，简单举个例子？"></a>设计模式懂嘛，简单举个例子？</h4><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><ul><li><p>比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>  适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p></li><li><p>比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p>  适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p></li></ul><h4 id="STL-库用过吗？常见的STL容器有哪些？算法用过哪几个？"><a href="#STL-库用过吗？常见的STL容器有哪些？算法用过哪几个？" class="headerlink" title="STL 库用过吗？常见的STL容器有哪些？算法用过哪几个？"></a>STL 库用过吗？常见的STL容器有哪些？算法用过哪几个？</h4><p>STL 包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）</p><ul><li>容器，即存放数据的地方。比如 array 等。<ul><li>在 STL 中，容器分为两类：序列式容器和关联式容器。</li><li>序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；</li><li>关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。</li><li>下面各选取一个作为说明。<ul><li>vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。</li><li>set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。</li></ul></li></ul></li><li>算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。</li><li>迭代器是STL的精髓，我们这样描述它：<br>  迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。<br>  它将容器和算法分开，好让这二者独立设计。</li></ul><h4 id="数据结构会吗？项目开发过程中主要用到那些？"><a href="#数据结构会吗？项目开发过程中主要用到那些？" class="headerlink" title="数据结构会吗？项目开发过程中主要用到那些？"></a>数据结构会吗？项目开发过程中主要用到那些？</h4><p>数据结构中主要会用到数组，链表，树（较少），也会用到栈和队列的思想。</p><h4 id="const-知道吗？解释其作用。"><a href="#const-知道吗？解释其作用。" class="headerlink" title="const 知道吗？解释其作用。"></a>const 知道吗？解释其作用。</h4><ol><li>const 修饰类的成员变量，表示成员常量，不能被修改。</li><li>const 修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。</li><li>如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。</li><li>const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。</li><li>类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。。</li></ol><h4 id="类的-static-变量在什么时候初始化？函数的-static-变量在什么时候初始化？"><a href="#类的-static-变量在什么时候初始化？函数的-static-变量在什么时候初始化？" class="headerlink" title="类的 static 变量在什么时候初始化？函数的 static 变量在什么时候初始化？"></a>类的 static 变量在什么时候初始化？函数的 static 变量在什么时候初始化？</h4><p>类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的 static 变量在执行此函数时进行初始化。</p><h4 id="堆和栈的区别？堆和栈的生命周期？"><a href="#堆和栈的区别？堆和栈的生命周期？" class="headerlink" title="堆和栈的区别？堆和栈的生命周期？"></a>堆和栈的区别？堆和栈的生命周期？</h4><ol><li>堆栈空间分配区别：<ol><li>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈</li><li>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表</li></ol></li><li>堆栈缓存方式区别：<ol><li>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放</li><li>堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些</li></ol></li><li>堆栈数据结构区别：<ol><li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序</li><li>栈（数据结构）：一种先进后出的数据结构</li></ol></li></ol><h4 id="解释下封装、继承和多态？"><a href="#解释下封装、继承和多态？" class="headerlink" title="解释下封装、继承和多态？"></a>解释下封装、继承和多态？</h4><ol><li>封装：<ol><li>封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）</li><li>封装的意义在于保护或者防止代码（数据）被我们无意中破坏</li></ol></li><li>继承：<ol><li>继承主要实现重用代码，节省开发时间</li><li>子类可以继承父类的一些东西</li></ol></li><li>多态<ol><li>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果</li><li>在运行时，可以通过指向基类的指针，来调用实现派生类中的方法</li></ol></li></ol><h4 id="指针和引用的区别？"><a href="#指针和引用的区别？" class="headerlink" title="指针和引用的区别？"></a>指针和引用的区别？</h4><ol><li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；</li><li>引用使用时无需解引用(*)，指针需要解引用；</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li><li>引用没有 const，指针有 const；</li><li>引用不能为空，指针可以为空；</li><li>“sizeof 引用” 得到的是所指向的变量(对象)的大小，而 “sizeof 指针” 得到的是指针本身的大小；</li><li>指针和引用的自增 (++) 运算意义不一样；</li><li>指针可以有多级，但是引用只能是一级（int **p 合法 而 int &amp;&amp;a 是不合法的）</li><li>从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</li></ol><h4 id="什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？"><a href="#什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？" class="headerlink" title="什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？"></a>什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？</h4><ul><li>用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。</li><li>使用的时候要记得指针的长度。</li><li>malloc 的时候得确定在那里 free.</li><li>对指针赋值的时候应该注意被赋值指针需要不需要释放.</li><li>动态分配内存的指针最好不要再次赋值.</li></ul><h4 id="常用的排序算法有哪些？简单描述几个排序算法的优缺点？"><a href="#常用的排序算法有哪些？简单描述几个排序算法的优缺点？" class="headerlink" title="常用的排序算法有哪些？简单描述几个排序算法的优缺点？"></a>常用的排序算法有哪些？简单描述几个排序算法的优缺点？</h4><p>选择、冒泡、快速、希尔、归并、堆排等。</p><ol><li>快排：是冒泡排序的一种改进。<ol><li>优点：快，数据移动少</li><li>缺点：稳定性不足</li></ol></li><li>归并：分治法排序，稳定的排序算法，一般用于对总体无序，但局部有序的数列。<ol><li>优点：效率高O(n)，稳定</li><li>缺点：比较占用内存</li><li><h4 id="new-和-malloc-的区别？"><a href="#new-和-malloc-的区别？" class="headerlink" title="new 和 malloc 的区别？"></a>new 和 malloc 的区别？</h4></li></ol></li><li>malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。</li><li>对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。</li><li>由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，以一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。</li><li>C++ 程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存。</li><li>new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void 指针。</li></ol><h4 id="TCP-和-UDP-通信的差别？什么是-IOCP？"><a href="#TCP-和-UDP-通信的差别？什么是-IOCP？" class="headerlink" title="TCP 和 UDP 通信的差别？什么是 IOCP？"></a>TCP 和 UDP 通信的差别？什么是 IOCP？</h4><ol><li>TCP 面向连接， UDP 面向无连接的</li><li>TCP 有保障的，UDP 传输无保障的</li><li>TCP 是效率低的，UDP 效率高的</li><li>TCP 是基于流的，UDP 基于数据报文</li><li>TCP 传输重要数据，UDP 传输不重要的数据</li><li>IOCP 全称I/O Completion Port，中文译为 I/O 完成端口。</li><li>IOCP 是一个异步 I/O 的 API，它可以高效地将 I/O 事件通知给应用程序。</li></ol><p>与使用 select() 或是其它异步方法不同的是，一个套接字 [socket] 与一个完成端口关联了起来，然后就可继续进行正常的 Winsock 操作了。然而，当一个事件发生的时候，此完成端口就将被操作系统加入一个队列中。然后应用程序可以对核心层进行查询以得到此完成端口。</p><h4 id="同步-IO-和异步-IO-的区别？"><a href="#同步-IO-和异步-IO-的区别？" class="headerlink" title="同步 IO 和异步 IO 的区别？"></a>同步 IO 和异步 IO 的区别？</h4><ol><li><p>同步</p><p> 所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。<br> 按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。<br> 但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。<br> 最常见的例子就是 SendMessage。<br> 该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。<br> 当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</p></li><li><p>异步</p><p> 异步的概念和同步相对。<br> 当一个异步过程调用发出后，调用者不会立刻得到结果。<br> 实际处理这个调用的部件是在调用发出后，通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p></li></ol><h4 id="解释-C-中静态函数和静态变量？"><a href="#解释-C-中静态函数和静态变量？" class="headerlink" title="解释 C++ 中静态函数和静态变量？"></a>解释 C++ 中静态函数和静态变量？</h4><ul><li>类静态数据成员在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。类静态数据成员只有一个拷贝，为所有此类的对象所共享。</li><li>类静态成员函数属于整个类，不属于某个对象，由该类所有对象共享。</li></ul><ol><li><p>static 成员变量实现了同类对象间信息共享。</p></li><li><p>static 成员类外存储，求类大小，并不包含在内。</p></li><li><p>static 成员是命名空间属于类的全局变量，存储在 data 区的 rw 段。</p></li><li><p>static 成员只能类外初始化。</p></li><li><p>可以通过类名访问（无对象生成时亦可），也可以通过对象访问。</p></li><li><p>静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</p></li><li><p>静态成员函数只能访问静态数据成员。</p><p> 原因：非静态成员函数，在调用时 this指针时被当作参数传进。而静态成员函数属于类，而不属于对象，没有 this 指针。</p></li></ol><h4 id="说下你对内存的了解？"><a href="#说下你对内存的了解？" class="headerlink" title="说下你对内存的了解？"></a>说下你对内存的了解？</h4><ol><li>栈 - 由编译器自动分配释放</li><li>堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收</li><li>全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放</li><li>另外还有一个专门放常量的地方。- 程序结束释放</li><li>程序代码区，存放 2 进制代码。</li></ol><p>在函数体中定义的变量通常是在栈上，用 malloc，calloc，realloc 等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了 static 修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的 static 变量表示在该文件中有效，不能 extern 到别的文件用，在函数体内定义的 static 表示只在该函数体内有效。另外，函数中的 “adgfdf” 这样的字符串存放在常量区。</p><h3 id="C-面试-100-经典"><a href="#C-面试-100-经典" class="headerlink" title="C++ 面试 100 经典"></a>C++ 面试 100 经典</h3><ul><li>作者:未知</li><li>链接:<a href="http://blog.csdn.net/lycnjupt/article/details/48978643" target="_blank" rel="noopener">C++面试100经典(非原文)</a></li></ul><h4 id="面向对象的程序设计思想是什么"><a href="#面向对象的程序设计思想是什么" class="headerlink" title="面向对象的程序设计思想是什么?"></a>面向对象的程序设计思想是什么?</h4><p>把数据结构和对数据结构进行操作的方法封装形成一个个的对象。</p><h4 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类?"></a>什么是类?</h4><p>把一些具有共性的对象归类后形成一个集合，也就是所谓的类。</p><h4 id="对象都具有的两方面特征是什么-分别是什么含义"><a href="#对象都具有的两方面特征是什么-分别是什么含义" class="headerlink" title="对象都具有的两方面特征是什么?分别是什么含义?"></a>对象都具有的两方面特征是什么?分别是什么含义?</h4><ul><li>对象都具有的特征是：静态特征和动态特征。</li><li>静态特征是指能描述对象的一些属性（成员变量），动态特征是指对象表现出来的行为（成员函数）</li></ul><h4 id="在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义"><a href="#在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义" class="headerlink" title="在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义?"></a>在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义?</h4><p>这样可以提高编译效率，因为分开的话只需要编译一次生成对应的 .obj 文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率。</p><h4 id="在类的内部定义成员函数的函数体，这种函数会具备那种属性"><a href="#在类的内部定义成员函数的函数体，这种函数会具备那种属性" class="headerlink" title="在类的内部定义成员函数的函数体，这种函数会具备那种属性?"></a>在类的内部定义成员函数的函数体，这种函数会具备那种属性?</h4><p>这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换。</p><h4 id="成员函数通过什么来区分不同对象的成员数据-为什么它能够区分"><a href="#成员函数通过什么来区分不同对象的成员数据-为什么它能够区分" class="headerlink" title="成员函数通过什么来区分不同对象的成员数据?为什么它能够区分?"></a>成员函数通过什么来区分不同对象的成员数据?为什么它能够区分?</h4><p>通过this指针指向对象的首地址来区分的。</p><h4 id="C-编译器自动为类产生的四个缺省函数是什么"><a href="#C-编译器自动为类产生的四个缺省函数是什么" class="headerlink" title="C++ 编译器自动为类产生的四个缺省函数是什么?"></a>C++ 编译器自动为类产生的四个缺省函数是什么?</h4><p>默认构造函数，拷贝构造函数，析构函数，赋值函数。</p><h4 id="拷贝构造函数在哪几种情况下会被调用"><a href="#拷贝构造函数在哪几种情况下会被调用" class="headerlink" title="拷贝构造函数在哪几种情况下会被调用?"></a>拷贝构造函数在哪几种情况下会被调用?</h4><ol><li>当类的一个对象去初始化该类的另一个对象时；</li><li>如果函数的形参是类的对象，调用函数进行形参和实参结合时；</li><li>如果函数的返回值是类对象，函数调用完成返回时。</li></ol><h4 id="构造函数与普通函数相比在形式上有什么不同-（构造函数的作用，它的声明形式来分析）"><a href="#构造函数与普通函数相比在形式上有什么不同-（构造函数的作用，它的声明形式来分析）" class="headerlink" title="构造函数与普通函数相比在形式上有什么不同?（构造函数的作用，它的声明形式来分析）"></a>构造函数与普通函数相比在形式上有什么不同?（构造函数的作用，它的声明形式来分析）</h4><ul><li>构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的。</li><li>构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。</li></ul><h4 id="什么时候必须重写拷贝构造函数"><a href="#什么时候必须重写拷贝构造函数" class="headerlink" title="什么时候必须重写拷贝构造函数?"></a>什么时候必须重写拷贝构造函数?</h4><p>当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。</p><h4 id="构造函数的调用顺序是什么"><a href="#构造函数的调用顺序是什么" class="headerlink" title="构造函数的调用顺序是什么?"></a>构造函数的调用顺序是什么?</h4><ol><li>先调用基类构造函数</li><li>按声明顺序初始化数据成员</li><li>最后调用自己的构造函数。</li></ol><h4 id="哪几种情况必须用到初始化成员列表"><a href="#哪几种情况必须用到初始化成员列表" class="headerlink" title="哪几种情况必须用到初始化成员列表?"></a>哪几种情况必须用到初始化成员列表?</h4><ol><li>类的成员是常量成员初始化；</li><li>类的成员是对象成员初始化，而该对象没有无参构造函数。</li><li>类的成员为引用时。</li></ol><h4 id="什么是常对象"><a href="#什么是常对象" class="headerlink" title="什么是常对象?"></a>什么是常对象?</h4><p>常对象是指在任何场合都不能对其成员的值进行修改的对象。</p><h4 id="静态函数存在的意义"><a href="#静态函数存在的意义" class="headerlink" title="静态函数存在的意义?"></a>静态函数存在的意义?</h4><ul><li>静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；</li><li>当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数。</li></ul><h4 id="在类外有什么办法可以访问类的非公有成员"><a href="#在类外有什么办法可以访问类的非公有成员" class="headerlink" title="在类外有什么办法可以访问类的非公有成员?"></a>在类外有什么办法可以访问类的非公有成员?</h4><p>友元，继承，公有成员函数。</p><h4 id="什么叫抽象类"><a href="#什么叫抽象类" class="headerlink" title="什么叫抽象类?"></a>什么叫抽象类?</h4><p>不用来定义对象而只作为一种基本类型用作继承的类。</p><h4 id="运算符重载的意义"><a href="#运算符重载的意义" class="headerlink" title="运算符重载的意义?"></a>运算符重载的意义?</h4><p>为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致。</p><h4 id="不允许重载的5个运算符是哪些"><a href="#不允许重载的5个运算符是哪些" class="headerlink" title="不允许重载的5个运算符是哪些?"></a>不允许重载的5个运算符是哪些?</h4><ol><li>.* （成员指针访问运算符号）</li><li>:: 域运算符</li><li>Sizeof 长度运算符号</li><li>?: 条件运算符号</li><li>. （成员访问符）</li></ol><h4 id="运算符重载的三种方式"><a href="#运算符重载的三种方式" class="headerlink" title="运算符重载的三种方式?"></a>运算符重载的三种方式?</h4><p>普通函数，友元函数，类成员函数。</p><h4 id="流运算符为什么不能通过类的成员函数重载-一般怎么解决"><a href="#流运算符为什么不能通过类的成员函数重载-一般怎么解决" class="headerlink" title="流运算符为什么不能通过类的成员函数重载?一般怎么解决?"></a>流运算符为什么不能通过类的成员函数重载?一般怎么解决?</h4><p>因为通过类的成员函数重载必须是运算符的第一个是自己，而对流运算的重载要求第一个参数是流对象。所以一般通过友元来解决。</p><h4 id="赋值运算符和拷贝构造函数的区别与联系"><a href="#赋值运算符和拷贝构造函数的区别与联系" class="headerlink" title="赋值运算符和拷贝构造函数的区别与联系?"></a>赋值运算符和拷贝构造函数的区别与联系?</h4><ul><li>相同点：都是将一个对象 copy 到另一个中去。</li><li>不同点：拷贝构造函数涉及到要新建立一个对象。</li></ul><h4 id="在哪种情况下要调用该类的析构函数"><a href="#在哪种情况下要调用该类的析构函数" class="headerlink" title="在哪种情况下要调用该类的析构函数?"></a>在哪种情况下要调用该类的析构函数?</h4><p>对象生命周期结束时。</p><h4 id="对象间是怎样实现数据的共享的"><a href="#对象间是怎样实现数据的共享的" class="headerlink" title="对象间是怎样实现数据的共享的?"></a>对象间是怎样实现数据的共享的?</h4><p>通过类的静态成员变量来实现对象间的数据共享。静态成员变量占有自己独立的空间不为某个对象所私有。</p><h4 id="友元关系有什么特性"><a href="#友元关系有什么特性" class="headerlink" title="友元关系有什么特性?"></a>友元关系有什么特性?</h4><p>单向的，非传递的，不能继承的。</p><h4 id="对对象成员进行初始化的次序是什么"><a href="#对对象成员进行初始化的次序是什么" class="headerlink" title="对对象成员进行初始化的次序是什么?"></a>对对象成员进行初始化的次序是什么?</h4><p>它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来决定的。</p><h4 id="类和对象之间的关系是什么"><a href="#类和对象之间的关系是什么" class="headerlink" title="类和对象之间的关系是什么?"></a>类和对象之间的关系是什么?</h4><p>类是对象的抽象，对象是类的实例。</p><h4 id="对类的成员的访问属性有什么"><a href="#对类的成员的访问属性有什么" class="headerlink" title="对类的成员的访问属性有什么?"></a>对类的成员的访问属性有什么?</h4><p>public，protected，private</p><h4 id="const-char-p和char-const-p-的区别"><a href="#const-char-p和char-const-p-的区别" class="headerlink" title="const char *p和char *  const p; 的区别"></a>const char *p和char *  const p; 的区别</h4><p>如果 const 位于星号的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果 const 位于星号的右侧，const 就是修饰指针本身，即指针本身是常量。</p><h4 id="是不是一个父类写了一个-virtual-函数，如果子类覆盖它的函数不加-virtual-也能实现多态"><a href="#是不是一个父类写了一个-virtual-函数，如果子类覆盖它的函数不加-virtual-也能实现多态" class="headerlink" title="是不是一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?"></a>是不是一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?</h4><ul><li>virtual 修饰符会被隐形继承的。</li><li>virtual 可加可不加,子类覆盖它的函数不加 virtual ,也能实现多态。</li></ul><h4 id="函数重载是什么意思-它与虚函数的概念有什么区别"><a href="#函数重载是什么意思-它与虚函数的概念有什么区别" class="headerlink" title="函数重载是什么意思?它与虚函数的概念有什么区别?"></a>函数重载是什么意思?它与虚函数的概念有什么区别?</h4><ul><li>函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。但是记住：不能仅仅通过函数返回值不同来实现函数重载。</li><li>而虚函数实现的是在基类中通过使用关键字 virtual 来申明一个函数为虚函数，含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。它体现的是一个纵向的概念，也即在基类和派生类间实现。</li></ul><h4 id="构造函数和析构函数是否可以被重载-为什么"><a href="#构造函数和析构函数是否可以被重载-为什么" class="headerlink" title="构造函数和析构函数是否可以被重载,为什么?"></a>构造函数和析构函数是否可以被重载,为什么?</h4><p>构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数。</p><h4 id="如何定义和实现一个类的成员函数为回调函数"><a href="#如何定义和实现一个类的成员函数为回调函数" class="headerlink" title="如何定义和实现一个类的成员函数为回调函数?"></a>如何定义和实现一个类的成员函数为回调函数?</h4><ul><li>所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。</li><li>定义一个类的成员函数时在该函数前加 CALLBACK 即将其定义为回调函数，函数的实现和普通成员函数没有区别。</li></ul><h4 id="虚函数是怎么实现的"><a href="#虚函数是怎么实现的" class="headerlink" title="虚函数是怎么实现的?"></a>虚函数是怎么实现的?</h4><p>简单说来使用了虚函数表.</p><h4 id="抽象类不会产生实例，所以不需要有构造函数。"><a href="#抽象类不会产生实例，所以不需要有构造函数。" class="headerlink" title="抽象类不会产生实例，所以不需要有构造函数。"></a>抽象类不会产生实例，所以不需要有构造函数。</h4><p>错</p><h4 id="从一个模板类可以派生新的模板类，也可以派生非模板类。"><a href="#从一个模板类可以派生新的模板类，也可以派生非模板类。" class="headerlink" title="从一个模板类可以派生新的模板类，也可以派生非模板类。"></a>从一个模板类可以派生新的模板类，也可以派生非模板类。</h4><p>对</p><h4 id="main-函数执行以前，还会执行什么代码"><a href="#main-函数执行以前，还会执行什么代码" class="headerlink" title="main 函数执行以前，还会执行什么代码?"></a>main 函数执行以前，还会执行什么代码?</h4><p>全局对象的构造函数会在main 函数之前执行。</p><h4 id="当一个类-A-中没有生命任何成员变量与成员函数-这时-sizeof-A-的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）"><a href="#当一个类-A-中没有生命任何成员变量与成员函数-这时-sizeof-A-的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）" class="headerlink" title="当一个类 A 中没有生命任何成员变量与成员函数,这时 sizeof(A) 的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）"></a>当一个类 A 中没有生命任何成员变量与成员函数,这时 sizeof(A) 的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）</h4><p>肯定不是零。举个反例，如果是零的话，声明一个 class A[10] 对象数组，而每一个对象占用的空间是零，这时就没办法区分 A[0],A[1]… 了。</p><h4 id="delete-与-delete-区别："><a href="#delete-与-delete-区别：" class="headerlink" title="delete 与 delete[]区别："></a>delete 与 delete[]区别：</h4><p>delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。</p><h4 id="子类析构时要调用父类的析构函数吗"><a href="#子类析构时要调用父类的析构函数吗" class="headerlink" title="子类析构时要调用父类的析构函数吗?"></a>子类析构时要调用父类的析构函数吗?</h4><p>会调用。析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了</p><h4 id="继承的优缺点。"><a href="#继承的优缺点。" class="headerlink" title="继承的优缺点。"></a>继承的优缺点。</h4><ul><li>优点<ol><li>类继承是在编译时刻静态定义的，且可直接使用，</li><li>类继承可以较方便地改变父类的实现。</li></ol></li><li>缺点<ol><li>因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现</li><li>父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为</li><li>如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</li></ol></li></ul><h4 id="解释堆和栈的区别。"><a href="#解释堆和栈的区别。" class="headerlink" title="解释堆和栈的区别。"></a>解释堆和栈的区别。</h4><ul><li>栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</li><li>堆（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。</li></ul><h4 id="一个类的构造函数和析构函数什么时候被调用-是否需要手工调用"><a href="#一个类的构造函数和析构函数什么时候被调用-是否需要手工调用" class="headerlink" title="一个类的构造函数和析构函数什么时候被调用,是否需要手工调用?"></a>一个类的构造函数和析构函数什么时候被调用,是否需要手工调用?</h4><p>构造函数在创建类对象的时候被自动调用，析构函数在类对象生命期结束时，由系统自动调用。</p><h4 id="何时需要预编译："><a href="#何时需要预编译：" class="headerlink" title="何时需要预编译："></a>何时需要预编译：</h4><ul><li>总是使用不经常改动的大型代码体。</li><li>程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</li></ul><h4 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用?"></a>多态的作用?</h4><ol><li>隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；</li><li>接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用</li></ol><h4 id="虚拟函数与普通成员函数的区别-内联函数和构造函数能否为虚拟函数"><a href="#虚拟函数与普通成员函数的区别-内联函数和构造函数能否为虚拟函数" class="headerlink" title="虚拟函数与普通成员函数的区别?内联函数和构造函数能否为虚拟函数?"></a>虚拟函数与普通成员函数的区别?内联函数和构造函数能否为虚拟函数?</h4><ul><li>区别：虚拟函数有 virtual 关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。</li><li>内联函数和构造函数不能为虚拟函数。</li></ul><h4 id="构造函数和析构函数的调用顺序-析构函数为什么要虚拟"><a href="#构造函数和析构函数的调用顺序-析构函数为什么要虚拟" class="headerlink" title="构造函数和析构函数的调用顺序? 析构函数为什么要虚拟?"></a>构造函数和析构函数的调用顺序? 析构函数为什么要虚拟?</h4><ul><li>构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；</li><li>析构函数的调用顺序与构造函数相反。</li><li>析构函数虚拟是为了防止析构不彻底，造成内存的泄漏。</li></ul><h4 id="C-中类型为-private-的成员变量可以由哪些函数访问"><a href="#C-中类型为-private-的成员变量可以由哪些函数访问" class="headerlink" title="C++ 中类型为 private 的成员变量可以由哪些函数访问?"></a>C++ 中类型为 private 的成员变量可以由哪些函数访问?</h4><p>只可以由本类中的成员函数和友元函数访问</p><h4 id="请说出类中-private，protect，public-三种访问限制类型的区别"><a href="#请说出类中-private，protect，public-三种访问限制类型的区别" class="headerlink" title="请说出类中 private，protect，public 三种访问限制类型的区别"></a>请说出类中 private，protect，public 三种访问限制类型的区别</h4><ul><li>private 是私有类型，只有本类中的成员函数访问;</li><li>protect 是保护型的，本类和继承类可以访问;</li><li>public 是公有类型，任何类都可以访问.</li></ul><h4 id="类中成员变量怎么进行初始化"><a href="#类中成员变量怎么进行初始化" class="headerlink" title="类中成员变量怎么进行初始化?"></a>类中成员变量怎么进行初始化?</h4><p>可以通过构造函数的初始化列表或构造函数的函数体实现。</p><h4 id="在什么时候需要使用“常引用”"><a href="#在什么时候需要使用“常引用”" class="headerlink" title="在什么时候需要使用“常引用”?"></a>在什么时候需要使用“常引用”?</h4><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。</p><h4 id="引用与指针有什么区别"><a href="#引用与指针有什么区别" class="headerlink" title="引用与指针有什么区别?"></a>引用与指针有什么区别?</h4><ol><li>引用必须被初始化，指针不必。</li><li>引用初始化以后不能被改变，指针可以改变所指的对象。</li><li>不存在指向空值的引用，但是存在指向空值的指针。</li></ol><h4 id="描述实时系统的基本特性"><a href="#描述实时系统的基本特性" class="headerlink" title="描述实时系统的基本特性"></a>描述实时系统的基本特性</h4><p>在特定时间内完成特定的任务，实时性与可靠性。</p><h4 id="全局变量和局部变量在内存中是否有区别-如果有，是什么区别"><a href="#全局变量和局部变量在内存中是否有区别-如果有，是什么区别" class="headerlink" title="全局变量和局部变量在内存中是否有区别?如果有，是什么区别?"></a>全局变量和局部变量在内存中是否有区别?如果有，是什么区别?</h4><p>全局变量储存在静态数据区，局部变量在堆栈中。</p><h4 id="堆栈溢出一般是由什么原因导致的"><a href="#堆栈溢出一般是由什么原因导致的" class="headerlink" title="堆栈溢出一般是由什么原因导致的?"></a>堆栈溢出一般是由什么原因导致的?</h4><p>没有回收垃圾资源</p><h4 id="什么函数不能声明为虚函数"><a href="#什么函数不能声明为虚函数" class="headerlink" title="什么函数不能声明为虚函数?"></a>什么函数不能声明为虚函数?</h4><p>构造函数（constructor）</p><h4 id="IP地址的编码分为哪俩部分"><a href="#IP地址的编码分为哪俩部分" class="headerlink" title="IP地址的编码分为哪俩部分?"></a>IP地址的编码分为哪俩部分?</h4><p>答 IP 地址由两部分组成，网络号和主机号。</p><h4 id="不能做switch-的参数类型是："><a href="#不能做switch-的参数类型是：" class="headerlink" title="不能做switch()的参数类型是："></a>不能做switch()的参数类型是：</h4><p>switch 的参数不能为实型。</p><h4 id="如何引用一个已经定义过的全局变量"><a href="#如何引用一个已经定义过的全局变量" class="headerlink" title="如何引用一个已经定义过的全局变量?"></a>如何引用一个已经定义过的全局变量?</h4><p>可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错</p><h4 id="对于一个频繁使用的短小函数-在-C-语言中应用什么实现-在-C-中应用什么实现"><a href="#对于一个频繁使用的短小函数-在-C-语言中应用什么实现-在-C-中应用什么实现" class="headerlink" title="对于一个频繁使用的短小函数,在 C 语言中应用什么实现,在 C++ 中应用什么实现?"></a>对于一个频繁使用的短小函数,在 C 语言中应用什么实现,在 C++ 中应用什么实现?</h4><p>C 用宏定义，C++ 用 inline</p><h4 id="C-是不是类型安全的"><a href="#C-是不是类型安全的" class="headerlink" title="C++ 是不是类型安全的?"></a>C++ 是不是类型安全的?</h4><p>不是。两个不同类型的指针之间可以强制转换（用 reinterpret cast)</p><h4 id="当一个类-A-中没有生命任何成员变量与成员函数-这时-sizeof-A-的值是多少，请解释一下编译器为什么没有让它为零。"><a href="#当一个类-A-中没有生命任何成员变量与成员函数-这时-sizeof-A-的值是多少，请解释一下编译器为什么没有让它为零。" class="headerlink" title="当一个类 A 中没有生命任何成员变量与成员函数,这时 sizeof(A) 的值是多少，请解释一下编译器为什么没有让它为零。"></a>当一个类 A 中没有生命任何成员变量与成员函数,这时 sizeof(A) 的值是多少，请解释一下编译器为什么没有让它为零。</h4><p>为1。举个反例，如果是零的话，声明一个 class A[10] 对象数组，而每一个对象占用的空间是零，这时就没办法区分 A[0],A[1]… 了。</p><h4 id="简述数组与指针的区别"><a href="#简述数组与指针的区别" class="headerlink" title="简述数组与指针的区别?"></a>简述数组与指针的区别?</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p><ol><li><p>修改内容上的区别</p><p> char a[] = “hello”;<br> a[0] = ‘X’;<br> char *p = “world”; // 注意p 指向常量字符串<br> p[0] = ‘X’; // 编译器不能发现该错误，运行时错误</p></li><li><p>用运算符 sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量。</p></li></ol><h4 id="C-函数中值的传递方式"><a href="#C-函数中值的传递方式" class="headerlink" title="C++ 函数中值的传递方式"></a>C++ 函数中值的传递方式</h4><p>三种方式：值传递、指针传递、引用传递</p><h4 id="内存的分配方式"><a href="#内存的分配方式" class="headerlink" title="内存的分配方式"></a>内存的分配方式</h4><p>分配方式有三种</p><ol><li>静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量。</li><li>栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限。</li><li>堆上分配，也称动态分配，如我们用 new,malloc 分配内存，用 delete,free 来释放的内存。</li></ol><h4 id="extern“C”-有什么作用"><a href="#extern“C”-有什么作用" class="headerlink" title="extern“C” 有什么作用?"></a>extern“C” 有什么作用?</h4><ul><li>Extern “C” 是由 C++ 提供的一个连接交换指定符号，用于告诉 C++ 这段代码是 C 函数。这是因为 C++ 编译后库中函数名会变得很长，与C生成的不一致，造成 C++ 不能直接调用C函数，加上 extren “c” 后，C++ 就能直接调用 C 函数了。</li><li>Extern “C” 主要使用正规DLL函数的引用和导出 和 在 C++ 包含C函数或C头文件时使用。使用时在前面加上 extern “c” 关键字即可。可以用一句话概括 extern “C” 这个声明的真实目的：实现 C++ 与 C 及其它语言的混合编程。</li></ul><h4 id="用什么函数开启新进程、线程。"><a href="#用什么函数开启新进程、线程。" class="headerlink" title="用什么函数开启新进程、线程。"></a>用什么函数开启新进程、线程。</h4><ul><li>线程：CreateThread/AfxBeginThread 等</li><li>进程：CreateProcess 等</li></ul><h4 id="SendMessage-和-PostMessage-有什么区别"><a href="#SendMessage-和-PostMessage-有什么区别" class="headerlink" title="SendMessage 和 PostMessage 有什么区别"></a>SendMessage 和 PostMessage 有什么区别</h4><ul><li>SendMessage 是阻塞的，等消息被处理后，代码才能走到 SendMessage 的下一行。</li><li>PostMessage 是非阻塞的，不管消息是否已被处理，代码马上走到 PostMessage 的下一行。</li></ul><h4 id="CMemoryState-主要功能是什么"><a href="#CMemoryState-主要功能是什么" class="headerlink" title="CMemoryState 主要功能是什么"></a>CMemoryState 主要功能是什么</h4><p>查看内存使用情况，解决内存泄露问题。</p><h4 id="include-lt-filename-h-gt-和-include-“filename-h”-有什么区别"><a href="#include-lt-filename-h-gt-和-include-“filename-h”-有什么区别" class="headerlink" title="#include &lt;filename.h&gt; 和 #include “filename.h” 有什么区别?"></a>#include &lt;filename.h&gt; 和 #include “filename.h” 有什么区别?</h4><ul><li>对于 #include &lt;filename.h&gt; ，编译器从标准库路径开始搜索 filename.h</li><li>对于 #include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h</li></ul><h4 id="处理器标识-error-的目的是什么"><a href="#处理器标识-error-的目的是什么" class="headerlink" title="处理器标识 #error 的目的是什么?"></a>处理器标识 #error 的目的是什么?</h4><p>编译时输出一条错误信息，并中止继续编译。</p><h4 id="if-defined-AFX-…-HADE-H-define-AFX-…-HADE-H-…-endif-作用"><a href="#if-defined-AFX-…-HADE-H-define-AFX-…-HADE-H-…-endif-作用" class="headerlink" title="#if!defined(AFX_…_HADE_H) #define(AFX_…_HADE_H) … #endif 作用?"></a>#if!defined(AFX_…_HADE_H) #define(AFX_…_HADE_H) … #endif 作用?</h4><p>防止该头文件被重复引用。</p><h4 id="在定义一个宏的时候要注意什么"><a href="#在定义一个宏的时候要注意什么" class="headerlink" title="在定义一个宏的时候要注意什么?"></a>在定义一个宏的时候要注意什么?</h4><p>定义部分的每个形参和整个表达式都必须用括号括起来，以避免不可预料的错误发生</p><h4 id="数组在做函数实参的时候会转变为什么类型"><a href="#数组在做函数实参的时候会转变为什么类型" class="headerlink" title="数组在做函数实参的时候会转变为什么类型?"></a>数组在做函数实参的时候会转变为什么类型?</h4><p>数组在做实参时会变成指针类型。</p><h4 id="系统会自动打开和关闭的-3-个标准的文件是"><a href="#系统会自动打开和关闭的-3-个标准的文件是" class="headerlink" title="系统会自动打开和关闭的 3 个标准的文件是?"></a>系统会自动打开和关闭的 3 个标准的文件是?</h4><ol><li>标准输入—-键盘— stdin</li><li>标准输出—-显示器— stdout</li><li>标准出错输出—-显示器— stderr</li></ol><h4 id="在-Win32-下-char-int-float-double-各占多少位"><a href="#在-Win32-下-char-int-float-double-各占多少位" class="headerlink" title="在 Win32 下 char, int, float, double 各占多少位?"></a>在 Win32 下 char, int, float, double 各占多少位?</h4><ol><li>Char     占用8位</li><li>Int      占用32位</li><li>Float    占用32位</li><li>Double   占用64位</li></ol><h4 id="strcpy-和-memcpy-的区别"><a href="#strcpy-和-memcpy-的区别" class="headerlink" title="strcpy() 和 memcpy() 的区别?"></a>strcpy() 和 memcpy() 的区别?</h4><p>strcpy() 和 memcpy() 都可以用来拷贝字符串，strcpy() 拷贝以’\0’结束，但 memcpy() 必须指定拷贝的长度。</p><h4 id="说明define和const在语法和含义上有什么不同"><a href="#说明define和const在语法和含义上有什么不同" class="headerlink" title="说明define和const在语法和含义上有什么不同?"></a>说明define和const在语法和含义上有什么不同?</h4><ol><li>#define 是 C 语法中定义符号变量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；</li><li>Const 是 C++ 语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用 sizeof 测出长度。</li></ol><h4 id="说出字符常量和字符串常量的区别，并使用运算符sizeof计算有什么不用"><a href="#说出字符常量和字符串常量的区别，并使用运算符sizeof计算有什么不用" class="headerlink" title="说出字符常量和字符串常量的区别，并使用运算符sizeof计算有什么不用?"></a>说出字符常量和字符串常量的区别，并使用运算符sizeof计算有什么不用?</h4><p>字符常量是指单个字符，字符串常量以 ‘\0’ 结束，使用运算符 sizeof 计算多占一字节的存储空间。</p><h4 id="简述全局变量的优缺点"><a href="#简述全局变量的优缺点" class="headerlink" title="简述全局变量的优缺点?"></a>简述全局变量的优缺点?</h4><p>全局变量也称为外部变量，它是在函数外部定义的变量，它属于一个源程序文件，它保存上一次被修改后的值，便于数据共享，但不方便管理，易引起意想不到的错误。</p><h4 id="总结static的应用和作用"><a href="#总结static的应用和作用" class="headerlink" title="总结static的应用和作用?"></a>总结static的应用和作用?</h4><ol><li>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</li><li>在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</li><li>在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</li><li>在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li><li>在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量。</li></ol><h4 id="总结-const-的应用和作用"><a href="#总结-const-的应用和作用" class="headerlink" title="总结 const 的应用和作用?"></a>总结 const 的应用和作用?</h4><ol><li>欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</li><li>对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；</li><li>在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li><li>对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；</li><li>对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”</li></ol><h4 id="什么是指针-谈谈你对指针的理解"><a href="#什么是指针-谈谈你对指针的理解" class="headerlink" title="什么是指针?谈谈你对指针的理解?"></a>什么是指针?谈谈你对指针的理解?</h4><ul><li>指针是一个变量，该变量专门存放内存地址；</li><li>指针变量的类型取决于其指向的数据类型，在所指数据类型前加*</li><li>指针变量的特点是它可以访问所指向的内存。</li></ul><h4 id="什么是常指针，什么是指向常变量的指针"><a href="#什么是常指针，什么是指向常变量的指针" class="headerlink" title="什么是常指针，什么是指向常变量的指针?"></a>什么是常指针，什么是指向常变量的指针?</h4><ul><li>常指针的含义是该指针所指向的地址不能变，但该地址所指向的内容可以变化，使用常指针可以保证我们的指针不能指向其它的变量，</li><li>指向常变量的指针是指该指针的变量本身的地址可以变化，可以指向其它的变量，但是它所指的内容不可以被修改。指向长变量的指针定义，</li></ul><h4 id="函数指针和指针函数的区别"><a href="#函数指针和指针函数的区别" class="headerlink" title="函数指针和指针函数的区别?"></a>函数指针和指针函数的区别?</h4><ul><li>函数指针是指向一个函数入口的指针；指针函数是函数的返回值是一个指针类型。</li></ul><h4 id="简述-Debug-版本和-Release-版本的区别"><a href="#简述-Debug-版本和-Release-版本的区别" class="headerlink" title="简述 Debug 版本和 Release 版本的区别?"></a>简述 Debug 版本和 Release 版本的区别?</h4><ul><li>Debug 版本是调试版本，Release 版本是发布给用户的最终非调试的版本，</li></ul><h4 id="指针的几种典型应用情况"><a href="#指针的几种典型应用情况" class="headerlink" title="指针的几种典型应用情况?"></a>指针的几种典型应用情况?</h4><ul><li>int *p[n]; -指针数组，每个元素均为指向整型数据的指针。</li><li>int (*)p[n]; -p为指向一维数组的指针，这个一维数组有n个整型数据。</li><li>int *p(); -函数带回指针，指针指向返回的值。</li><li>int (*)p(); -p为指向函数的指针。</li></ul><h4 id="static-函数与普通函数有什么区别"><a href="#static-函数与普通函数有什么区别" class="headerlink" title="static 函数与普通函数有什么区别?"></a>static 函数与普通函数有什么区别?</h4><p>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p><h4 id="struct-结构-和-union-联合-的区别"><a href="#struct-结构-和-union-联合-的区别" class="headerlink" title="struct (结构)和 union (联合)的区别?"></a>struct (结构)和 union (联合)的区别?</h4><ol><li>结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。</li><li>对于联合的不同成员赋值, 将会对其它成员重写,  原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</li></ol><h4 id="class-和-struct-的区别"><a href="#class-和-struct-的区别" class="headerlink" title="class 和 struct 的区别?"></a>class 和 struct 的区别?</h4><p>struct 的成员默认是公有的，而类的成员默认是私有的。</p><h4 id="简述枚举类型"><a href="#简述枚举类型" class="headerlink" title="简述枚举类型?"></a>简述枚举类型?</h4><p>枚举方便一次定义一组常量，使用起来很方便；</p><h4 id="assert-的作用"><a href="#assert-的作用" class="headerlink" title="assert() 的作用?"></a>assert() 的作用?</h4><p>ASSERT() 是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为 FALSE (0), 程序将报告错误，并终止执行。如果表达式不为 0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。</p><h4 id="局部变量和全局变量是否可以同名"><a href="#局部变量和全局变量是否可以同名" class="headerlink" title="局部变量和全局变量是否可以同名?"></a>局部变量和全局变量是否可以同名?</h4><p>能。局部会屏蔽全局。要用全局变量，需要使用 “::”(域运算符)。</p><h4 id="程序的局部变量存在于（堆栈）中，全局变量存在于（静态区-）中，动态申请数据存在于（-堆）中。"><a href="#程序的局部变量存在于（堆栈）中，全局变量存在于（静态区-）中，动态申请数据存在于（-堆）中。" class="headerlink" title="程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。"></a>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。</h4><h4 id="在什么时候使用常引用"><a href="#在什么时候使用常引用" class="headerlink" title="在什么时候使用常引用?"></a>在什么时候使用常引用?</h4><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。</p><h4 id="类的声明和实现的分开的好处"><a href="#类的声明和实现的分开的好处" class="headerlink" title="类的声明和实现的分开的好处?"></a>类的声明和实现的分开的好处?</h4><ol><li>起保护作用；</li><li>提高编译的效率。</li></ol><h4 id="windows-消息系统由哪几部分构成"><a href="#windows-消息系统由哪几部分构成" class="headerlink" title="windows 消息系统由哪几部分构成?"></a>windows 消息系统由哪几部分构成?</h4><p>3 部分组成：</p><ol><li>消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息；</li><li>消息循环：应用程序通过消息循环不断获取消息、处理消息。</li><li>消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。</li></ol><h4 id="什么是消息映射"><a href="#什么是消息映射" class="headerlink" title="什么是消息映射?"></a>什么是消息映射?</h4><p>消息映射就是让程序员指定MFC类（有消息处理能力的类）处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。</p><h4 id="什么是-UDP-和-TCP-的区别是什么"><a href="#什么是-UDP-和-TCP-的区别是什么" class="headerlink" title="什么是 UDP 和 TCP 的区别是什么?"></a>什么是 UDP 和 TCP 的区别是什么?</h4><ul><li>TCP 的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。</li><li>UDP 全称为用户报文协议，它可以提供非连接的不可靠的点到多点的通信。</li><li>用 TCP 还是 UDP，那要看你的程序注重哪一个方面?可靠还是快速?</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++开源项目汇总</title>
      <link href="/posts/C-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
      <url>/posts/C-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文暂时只附链接上,有兴趣的同学可以看一下.</p><p>由于最近忙于校招,想看些开源项目,苦于校招及其不顺,所以暂时先复习秋招</p><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><ul><li><p><a href="https://www.zhihu.com/question/28341521" target="_blank" rel="noopener">GitHub 或者其他的开源平台中是否有一些适合初学者的 C++ 项目？</a></p></li><li><p><a href="https://www.zhihu.com/question/27630564" target="_blank" rel="noopener">近年来(2005之后)，C++ 有哪些高大上的开源项目？</a></p></li><li><p><a href="https://www.zhihu.com/question/23511894" target="_blank" rel="noopener">有哪些值得推荐的c++11风格的开源项目？</a></p></li><li><p><a href="http://blog.csdn.net/wenrenhua08/article/details/40040903" target="_blank" rel="noopener">C++开源代码项目汇总</a></p></li><li><p><a href="http://www.cnblogs.com/liinux/p/5592674.html" target="_blank" rel="noopener">C++开源大全</a></p></li><li><p><a href="http://www.360doc.com/content/12/0604/23/3705007_216051195.shtml" target="_blank" rel="noopener">C++经典开源项目</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weavesilk.com -有趣的网站</title>
      <link href="/posts/weavesilk-com-%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/posts/weavesilk-com-%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h3 id="一个有趣的网站-weavesilk"><a href="#一个有趣的网站-weavesilk" class="headerlink" title="一个有趣的网站 weavesilk"></a>一个有趣的网站 <a href="http://weavesilk.com/" target="_blank" rel="noopener">weavesilk</a></h3><iframe frameborder="0" class="full-image" width="960px" height="540px" src="http://weavesilk.com/"></iframe>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GitHub Pages 托管 Hexo 博客</title>
      <link href="/posts/%E4%BD%BF%E7%94%A8-GitHub-Pages-%E6%89%98%E7%AE%A1-Hexo-%E5%8D%9A%E5%AE%A2/"/>
      <url>/posts/%E4%BD%BF%E7%94%A8-GitHub-Pages-%E6%89%98%E7%AE%A1-Hexo-%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><h3 id="搭建好的-Hexo-本地博客"><a href="#搭建好的-Hexo-本地博客" class="headerlink" title="搭建好的 Hexo 本地博客"></a>搭建好的 Hexo 本地博客</h3><p>还没有搭建好的童鞋,请看 <a href="/posts/Windows系统下搭建Hexo个人博客/">Windows系统下搭建Hexo个人博客</a></p><h3 id="GitHub-账号"><a href="#GitHub-账号" class="headerlink" title="GitHub 账号"></a>GitHub 账号</h3><p>还没有注册的童鞋,请到 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 注册</p><h2 id="GitHub-准备"><a href="#GitHub-准备" class="headerlink" title="GitHub 准备"></a>GitHub 准备</h2><h3 id="新建代码仓库"><a href="#新建代码仓库" class="headerlink" title="新建代码仓库"></a>新建代码仓库</h3><ul><li>直接在你的 GitHub 上新建 Repository,名称必须为 username.github.io</li><li>username 就是你的用户名,下同 </li></ul><h2 id="Hexo-配置准备"><a href="#Hexo-配置准备" class="headerlink" title="Hexo 配置准备"></a>Hexo 配置准备</h2><h3 id="安装-Hexo-Git-插件"><a href="#安装-Hexo-Git-插件" class="headerlink" title="安装 Hexo-Git 插件"></a>安装 Hexo-Git 插件</h3><p>在 PowerShell 或 CMD 中,运行以下命令: <br><br>(啥,你问为啥用 PowerShell 而不用 CMD ?,因为 PoweShell 更 Powerful 啊,当然,要是没有 PowerShell 那只能用 CMD 了,不过有可能出现问题,先打个预防针)<br><br>注:所有的命令均需要在你的 Hexo 项目路径下执行</p><ul><li><p>稳定版</p><p>  npm install hexo-deployer-git –save </p></li><li><p>最新版</p><p>  <code>npm install git+git@github.com:hexojs/hexo-deployer-git.git --save</code></p></li></ul><h3 id="配置-config-yml-文件"><a href="#配置-config-yml-文件" class="headerlink" title="配置 _config.yml 文件"></a>配置 _config.yml 文件</h3><p>这里只说常用几个配置详细请看 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">Hexo-deployer-git</a>,没错你没看错,就是英文的,但是都是基本词汇,不难</p><pre><code>deploy:  type: git  repo: &lt;repository url&gt;  branch: [branch]  message: [message]</code></pre><ul><li>repo: 仓库的URL,就是刚才新建的仓库地址<br></li><li>branch: 要同步的分支( 因为是用Github Pages 做服务器,分支这里必须填 master )<br></li><li>message: 提交信息.</li></ul><h2 id="发布网站到-GitHub-Pages"><a href="#发布网站到-GitHub-Pages" class="headerlink" title="发布网站到 GitHub Pages"></a>发布网站到 GitHub Pages</h2><p>一下三种之中任意一种都可以</p><h3 id="命令-I"><a href="#命令-I" class="headerlink" title="命令 I"></a>命令 I</h3><pre><code>hexo generatehexo deploy</code></pre><p>当然可以简化为</p><pre><code>hexo ghexo d</code></pre><h3 id="命令-II"><a href="#命令-II" class="headerlink" title="命令 II"></a>命令 II</h3><pre><code>hexo generate --deploy</code></pre><p>简化</p><pre><code>hexo g -d</code></pre><h3 id="命令-III"><a href="#命令-III" class="headerlink" title="命令 III"></a>命令 III</h3><pre><code>hexo deploy --generate</code></pre><p>简化</p><pre><code>hexo d -g</code></pre><h3 id="命令执行结果"><a href="#命令执行结果" class="headerlink" title="命令执行结果"></a>命令执行结果</h3><p>必须看到以下 Log 才算完全成功</p><pre><code>INFO  Deploy done:</code></pre><h2 id="查看你的博客"><a href="#查看你的博客" class="headerlink" title="查看你的博客"></a>查看你的博客</h2><p>浏览器地址栏输入 <font color="orange">username</font><font color="skyblue">.github.io</font> </p><h2 id="接下来说说把整个项目同步到-GitHub"><a href="#接下来说说把整个项目同步到-GitHub" class="headerlink" title="接下来说说把整个项目同步到 GitHub"></a>接下来说说把整个项目同步到 GitHub</h2><p>有两种方法</p><ul><li>放到 username.github.io 仓库下</li><li>放到其他仓库下( 当然是你自己建的仓库,仓库名根据自己的喜好取 )</li></ul><h3 id="username-github-io"><a href="#username-github-io" class="headerlink" title="username.github.io"></a>username.github.io</h3><ul><li><p>在你自己的 username.github.io 下新建 Branch (分支),分支名自取,例: hexo</p></li><li><p>初始化 git</p><p>  git init</p></li><li><p>新建分支 hexo (替换为你刚才在 username.github.io 下新建的分支,下同)</p><p>  git branch hexo</p></li><li><p>切换分支</p><p>  git checkout hexo</p></li><li><p>关联远程仓库</p><p>  git remote add origin <a href="https://github.com/username/username.github.io.git" target="_blank" rel="noopener">https://github.com/username/username.github.io.git</a></p></li><li><p>添加文件</p><p>  git add -A<br>  ( -A 为添加所有改动文件,也可以单独指定文件或文件夹)</p></li><li><p>提交改动</p><p>  git commit -m message<br>  ( message 为改动信息,自己填,如果有空格需要用 “ “ 引起来 )</p></li><li><p>同步到远程仓库</p><p>  git push origin hexo<br>  (注:分支名 hexo 加不加都可以,因为已经切换到 hexo 分支,若不在 hexo 必须加)</p></li></ul><h3 id="其他仓库"><a href="#其他仓库" class="headerlink" title="其他仓库"></a>其他仓库</h3><ul><li><p>在自己的 GitHub 新建一个仓库,例: hexo</p></li><li><p>初始化 git</p><p>  git init</p></li><li><p>关联远程仓库,替换 username,hexo 为自己的用户名和仓库名</p><p>  git remote add origin <a href="https://github.com/username/hexo.git" target="_blank" rel="noopener">https://github.com/username/hexo.git</a></p></li><li><p>添加文件</p><p>  git add -A<br>  ( -A 为添加所有改动文件,也可以单独指定文件或文件夹)</p></li><li><p>提交改动</p><p>  git commit -m message<br>  ( message 为改动信息,自己填,如果有空格需要用 “ “ 引起来 )</p></li><li><p>同步到远程仓库</p><p>  git push origin master<br>  (注:分支名 master 加不加都可以,因为默认在 master 分支,若不在 master 必须加)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创新工场涂鸦移动2018校园招聘测试题-软件工程师-编程题一</title>
      <link href="/posts/%E5%88%9B%E6%96%B0%E5%B7%A5%E5%9C%BA%E6%B6%82%E9%B8%A6%E7%A7%BB%E5%8A%A82018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E6%B5%8B%E8%AF%95%E9%A2%98-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E5%88%9B%E6%96%B0%E5%B7%A5%E5%9C%BA%E6%B6%82%E9%B8%A6%E7%A7%BB%E5%8A%A82018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E6%B5%8B%E8%AF%95%E9%A2%98-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>写一个算法判断某个字符串是不是一个合法的IP地址。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>1 行, 任意长度字符串</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>1 行, 若字符串为合法 IP 地址,则输出 1,否则输出 0</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>::0.0.0.0</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>1</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="据-IPv6-IPv6-判断"><a href="#据-IPv6-IPv6-判断" class="headerlink" title="据 IPv6,IPv6 判断"></a>据 IPv6,IPv6 判断</h3><ul><li>IPv4<ul><li>点分十进制表示</li><li>分四段,每段由一个值小于 256 大于等于 0 的数字组成</li></ul></li><li>IPv6<ul><li>冒分十六进制表示</li><li>分八段,每段由四位十六进制数字组成</li><li>可以省略前导 0,若连续 x 段值都为零,则可以用 :: (双冒号)来代替,若同时存在多段连续 0 段,则只能压缩其中一段</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//判断IP</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeIP</span><span class="params">(<span class="built_in">string</span> ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ipv4,ipv6分隔符</span></span><br><span class="line">    <span class="keyword">char</span> delmtr6=<span class="string">':'</span>,delmtr4=<span class="string">'.'</span>;</span><br><span class="line">    <span class="comment">//分隔符位置</span></span><br><span class="line">    <span class="keyword">int</span> d6,d4;</span><br><span class="line">    <span class="comment">//是否存在ipv4,ipv6分隔符</span></span><br><span class="line">    <span class="keyword">bool</span> isV4=<span class="number">0</span>,isV6=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得 ipv4 第一个分隔符位置,ipv6 最后一个分隔符位置</span></span><br><span class="line">    d4=ip.find(delmtr4),d6=ip.find_last_of(delmtr6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若两者都不存在,不合法</span></span><br><span class="line">    <span class="keyword">if</span>(d6==<span class="built_in">string</span>::npos&amp;&amp;d4==<span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//存在 ipv6 分隔符则可能为 ipv6</span></span><br><span class="line">    <span class="keyword">if</span>(d6!=<span class="built_in">string</span>::npos)</span><br><span class="line">        isV6=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若存在 ipv4 分隔符,则可能是 ipv4</span></span><br><span class="line">    <span class="keyword">if</span>(d4!=<span class="built_in">string</span>::npos)</span><br><span class="line">        isV4=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若两者都存在,且 ipv6 最后一个分隔符在前,ipv4 第一个分隔符在后,则有可能是兼容性 ip</span></span><br><span class="line">    <span class="keyword">if</span>(isV4&gt;isV6&amp;&amp;d6&gt;d4)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipv6 连续分隔符的个数</span></span><br><span class="line">    <span class="keyword">int</span> nearD6;</span><br><span class="line">    <span class="comment">// ipv6 连续双分隔的对数</span></span><br><span class="line">    <span class="keyword">int</span> doubleD6;</span><br><span class="line">    <span class="comment">// ipv4,ipv6 分段段数</span></span><br><span class="line">    <span class="keyword">int</span> v4Part,v6Part;</span><br><span class="line">    <span class="comment">// ipv6 分段长度</span></span><br><span class="line">    <span class="keyword">int</span> v6PL;</span><br><span class="line">    <span class="comment">// v4PL 取值为 1,10,100,用于计算 v4PV</span></span><br><span class="line">    <span class="keyword">int</span> v4PL;</span><br><span class="line">    <span class="comment">// ipv4 分段值</span></span><br><span class="line">    <span class="keyword">int</span> v4PV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=ip.length()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能为ipv4</span></span><br><span class="line">    <span class="keyword">if</span>(isV4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(v4PV=<span class="number">0</span>,v4Part=v4PL=<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前为ipv4分隔符</span></span><br><span class="line">            <span class="keyword">if</span>(ip[i]==delmtr4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//分隔符位于最后或分段值 v4PV&gt;255 ,不合法</span></span><br><span class="line">                <span class="keyword">if</span>(i==ip.length()<span class="number">-1</span>||v4PV&gt;<span class="number">255</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//分段数 v4Part+1,还原 v4PL,v4PV</span></span><br><span class="line">                ++v4Part,v4PL=<span class="number">1</span>,v4PV=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//若分段数 v4part&gt;4,则不合法</span></span><br><span class="line">                <span class="keyword">if</span>(v4Part&gt;<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算分段值 v4PV</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip[i]&gt;=<span class="string">'0'</span>&amp;&amp;ip[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                v4PV+=(ip[i]-<span class="string">'0'</span>)*v4PL,v4PL*=<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//读到 ipv6分隔符,或读到字符串首</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip[i]==<span class="string">':'</span>||i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前段的值 v4PV&gt;255,或段数不足 4,不合法</span></span><br><span class="line">                <span class="keyword">if</span>(v4PV&gt;<span class="number">255</span>||v4Part&lt;<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//ipv4 部分识别完毕</span></span><br><span class="line">                <span class="keyword">if</span>(v4Part==<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//忽略空格</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip[i]==<span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//出现除 ipv4/ipv6 分隔符,数字 0-9,空格,之外的字符,不合法</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能为兼容性 ip 或 ipv6</span></span><br><span class="line">    <span class="keyword">if</span>(isV6)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前字符的后一个非 空格 字符</span></span><br><span class="line">        <span class="keyword">char</span> nextC=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//ipv6初始化</span></span><br><span class="line">        v6Part=<span class="number">1</span>,nearD6=doubleD6=<span class="number">0</span>,v6PL=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//兼容ip初始化</span></span><br><span class="line">        <span class="keyword">if</span>(isV4)</span><br><span class="line">            v6Part=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前为 ipv6 分隔符</span></span><br><span class="line">            <span class="keyword">if</span>(ip[i]==delmtr6)</span><br><span class="line">            &#123;</span><br><span class="line">                nextC=ip[i];</span><br><span class="line">                <span class="comment">//当前字符的后一个字符同为 ipv6 分隔符</span></span><br><span class="line">                <span class="keyword">if</span>(nextC==delmtr6)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//连续分隔符的长度 nearD6+1</span></span><br><span class="line">                    ++nearD6;</span><br><span class="line">                    <span class="comment">//若连续分隔符长度 nearD6&gt;2,则不合法</span></span><br><span class="line">                    <span class="keyword">if</span>(nearD6&gt;<span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//若连续长度为 2,则连续双分隔的对数 doubleD6+1</span></span><br><span class="line">                    <span class="keyword">if</span>(nearD6==<span class="number">2</span>)</span><br><span class="line">                        ++doubleD6;</span><br><span class="line">                    <span class="comment">//若连续双分隔的对数 doubleD6&gt;1,不合法</span></span><br><span class="line">                    <span class="keyword">if</span>(doubleD6&gt;<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//分段数 v6Part+1,还原 v6PL,统计下个分段</span></span><br><span class="line">                ++v6Part,v6PL=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//分段数 v6Part&gt;8,不合法</span></span><br><span class="line">                <span class="keyword">if</span>(v6Part&gt;<span class="number">8</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断十六进制</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip[i]&gt;=<span class="string">'0'</span>&amp;&amp;ip[i]&lt;=<span class="string">'9'</span>||ip[i]&gt;=<span class="string">'A'</span>&amp;&amp;ip[i]&lt;=<span class="string">'F'</span>||ip[i]&gt;=<span class="string">'a'</span>&amp;&amp;ip[i]&lt;=<span class="string">'f'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextC=ip[i];</span><br><span class="line">                <span class="comment">//分段长度 v6PL&gt;4,不合法</span></span><br><span class="line">                <span class="keyword">if</span>(v6PL&gt;<span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//分段长度 v6Part+1</span></span><br><span class="line">                ++v6PL;</span><br><span class="line">                <span class="comment">//清除连续分隔符的长度 nearD6</span></span><br><span class="line">                nearD6=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//忽略空格</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ip[i]==<span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//出现除了 ipv6 分隔符,十六进制数 (0-9,a-f,A-F),空格 之外的字符,不合法</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无简化全 0 分组但分段数 v6Part&lt;8,不合法</span></span><br><span class="line">        <span class="keyword">if</span>((!doubleD6)&amp;&amp;v6Part&lt;<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ip;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ip)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;judgeIP(ip)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用-Windows-或-Linux-API-间接判断"><a href="#调用-Windows-或-Linux-API-间接判断" class="headerlink" title="调用 Windows 或 Linux API 间接判断"></a>调用 Windows 或 Linux API 间接判断</h3><ul><li>通过 IP 地址转换函数函数 int inet_pton(int af, const char *src, void *dst) 进行判断<ul><li>af 为地址簇,IPv4 取 AF_INET,IPv6 取 AF_INET6</li><li>src 为 IP 字符数组</li><li>dst 为用来存储转化后的 IP 地址的对象,IPv4 为 in_addr 结构体对象,IPv6 为 in6_addr 结构体对象</li><li>若返回值为 1 则说明IP合法,0 说明参数 af 指定的地址族或 src 格式不对,&lt;0 说明函数出错</li></ul></li><li>Windows 和 Linux 系统下的函数名相同,但是实现不同,需要包含不同的头文件<ul><li>Windows</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br></pre></td></tr></table></figure><pre><code>* Linux</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//判断IP</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeIP</span><span class="params">(<span class="keyword">char</span>* ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//IPv4地址对象</span></span><br><span class="line">    in_addr dist4;</span><br><span class="line">    <span class="comment">//IPv6地址对象</span></span><br><span class="line">    in6_addr dist6;</span><br><span class="line">    <span class="comment">//IPv4,IPv6 转换返回值</span></span><br><span class="line">    <span class="keyword">int</span> res4,res6;</span><br><span class="line">    <span class="comment">//获取 IPv4,IPv6 转换返回值</span></span><br><span class="line">    res4=inet_pton(AF_INET, ip, (<span class="keyword">void</span> *)&amp;dist4);</span><br><span class="line">    res6=inet_pton(AF_INET6, ip, (<span class="keyword">void</span> *)&amp;dist6);</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">return</span> res4&gt;<span class="number">0</span>||res6&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ip)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;judgeIP(ip)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 涂鸦移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> 涂鸦移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创新工场涂鸦移动2018校园招聘测试题-软件工程师-编程题二</title>
      <link href="/posts/%E5%88%9B%E6%96%B0%E5%B7%A5%E5%9C%BA%E6%B6%82%E9%B8%A6%E7%A7%BB%E5%8A%A82018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E6%B5%8B%E8%AF%95%E9%A2%98-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E5%88%9B%E6%96%B0%E5%B7%A5%E5%9C%BA%E6%B6%82%E9%B8%A6%E7%A7%BB%E5%8A%A82018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E6%B5%8B%E8%AF%95%E9%A2%98-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给定一字符串只包含数字，请写一个算法，找出该字符串中的最长不重复子串（不重复是指子串中每一元素不同于子串中其他元素）</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>1 行,一个字符全为数字的字符串</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>1 行,最长不重复子串</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>120135435</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>201354</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>定义 len(i) 为以下标 i 开始的不重复子串的最大长度</li><li>初始化 len(i) 为与str[i]相同的下一个字符的距离,若没有则设定下个相同字符的位置为 n</li><li>状态转移方程:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(i)=min(len(i),len(i+1)+1)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//最长不重复子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookUp</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取串长度</span></span><br><span class="line">    <span class="keyword">int</span> n=str.length(); </span><br><span class="line">    <span class="comment">//申请辅助空间,flag[i] 为后一个 i 在 str 中的位置,</span></span><br><span class="line"><span class="comment">//len[i] 为以 i 为第一个字符的不重复子串的长度</span></span><br><span class="line">    <span class="keyword">int</span> flag[<span class="number">10</span>],*len=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">5</span>]; </span><br><span class="line">    <span class="comment">//初始化 flag</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)   </span><br><span class="line">        flag[i]=n;</span><br><span class="line">    <span class="comment">//初始化 len</span></span><br><span class="line">    <span class="built_in">memset</span>(len,<span class="number">0</span>,<span class="keyword">sizeof</span> len);   </span><br><span class="line">    len[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化 len[i] 为当前字符与其后面第一个相同的自字符的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) </span><br><span class="line">    &#123;</span><br><span class="line">        len[i]=flag[str[i]-<span class="string">'0'</span>]-i;</span><br><span class="line">        flag[str[i]-<span class="string">'0'</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存最大子串的首</span></span><br><span class="line">    <span class="keyword">int</span> maxi=n; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//len[i] 的值更新为 len[i] 与 len[i+1]+1 两数之中的小者</span></span><br><span class="line">        len[i]=min(len[i],len[i+<span class="number">1</span>]+<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//更新最长不重复子串首字符位置 </span></span><br><span class="line">        <span class="keyword">if</span>(len[maxi]&lt;len[i])maxi=i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出最长不重复子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxi;i-maxi&lt;len[maxi];++i)    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        lookUp(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 涂鸦移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 涂鸦移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美图 2018校招 后端研发工程师在线考试-编程题一</title>
      <link href="/posts/%E7%BE%8E%E5%9B%BE-2018%E6%A0%A1%E6%8B%9B-%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E7%BE%8E%E5%9B%BE-2018%E6%A0%A1%E6%8B%9B-%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Bit位数计算"><a href="#题目-Bit位数计算" class="headerlink" title="题目 Bit位数计算"></a>题目 Bit位数计算</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>两个 int32 整数 m 和 n 的二进制表达，计算有多少个位 (bit) 不同？</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>一行中给定两个数字</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出这两个数字中bit不同的个数</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>15 8</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>两数异或</li><li>统计 1 的个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        m^=n;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m)</span><br><span class="line">        &#123;</span><br><span class="line">            m&amp;=m<span class="number">-1</span>;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 美图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美图 2018校招 后端研发工程师在线考试-编程题二</title>
      <link href="/posts/%E7%BE%8E%E5%9B%BE-2018%E6%A0%A1%E6%8B%9B-%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E7%BE%8E%E5%9B%BE-2018%E6%A0%A1%E6%8B%9B-%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-最长公共子串"><a href="#题目-最长公共子串" class="headerlink" title="题目 最长公共子串"></a>题目 最长公共子串</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有两个字符串（可能包含空格）,请找出其中最长的公共连续子串, 输出其长度。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>给定两行字符串</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出这两个字符串的最长公共连续子串的长度</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>abcdebcd</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>3</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>定义 len(i,j) 为串 1 在位置 i 处结尾与串 2 在位置 j 出结尾的公共子串的长度</li><li>动态更新最大长度</li><li>状态转移方程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len(I,j) = |-&gt; 0  (str1[i]!=str2[i])</span><br><span class="line">           |-&gt; len(i-1,j-1)+1  (str1[i]==str2[i])</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">2005</span>],str2[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> commLen[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(str1),len2=<span class="built_in">strlen</span>(str2),maxLen=<span class="number">0</span>;;</span><br><span class="line">        <span class="built_in">memset</span>(commLen,<span class="number">0</span>,<span class="keyword">sizeof</span> commLen);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len2;j&gt;<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    commLen[j]=commLen[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    maxLen=max(maxLen,commLen[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    commLen[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;maxLen&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 美图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 美图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链家2018链习生招聘考试-编程题一</title>
      <link href="/posts/%E9%93%BE%E5%AE%B62018%E9%93%BE%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E9%93%BE%E5%AE%B62018%E9%93%BE%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>玥玥带乔乔一起逃亡,现在有许多东西要放到乔乔的包里面,但是包的大小有限,所以我们只能够在里面放入非常重要的物品.现在给出该种物品的数量,体积,价值的数值,希望你能够算出怎样能使背包的价值最大的组合方式,并且输出这个数值,乔乔会非常感谢你的</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第 1 行有两个整数,物品种数 n 和背包装载体积v;第 2 到 n+1 行每行三个整数,为第 i 种物品的数量 m,体积 v,价值s </code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>仅包含一个整数,即为能拿到的最大的物品价值总和</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>2 103 4 32 2 5</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>13</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>定义 value(i,j) 为在背包装载体积为 i,物品为第 1 到 j 个的情况下,背包的最大价值</li><li>value(v,sum(m[i])) 即为所求</li><li>可以把空间复杂度从 O(nv) 降到 O(v)</li><li>状态转移方程:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value(i,j) = |-&gt; max(value(i-w[j],j-1)+s[j],value(i-1,j-1) (i-w[j] &gt;= 0)</span><br><span class="line">             |-&gt; value(i-1,j-1) (i-w[j] &lt; 0)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,v,c=<span class="number">0</span>,maxs=<span class="number">0</span>,value[<span class="number">501</span>],w[<span class="number">20001</span>],s[<span class="number">20001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(value,<span class="number">0</span>,<span class="keyword">sizeof</span> value);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;w[j],&amp;s[j]);</span><br><span class="line">        c+=m;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;k&lt;m;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            w[k+j]=w[j],s[k+j]=s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        j+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=i-w[j];</span><br><span class="line">            value[i]=(k&gt;=<span class="number">0</span>?max(value[k]+s[j],value[i<span class="number">-1</span>]):value[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;value[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 链家 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 链家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链家2018链习生招聘考试-编程题二</title>
      <link href="/posts/%E9%93%BE%E5%AE%B62018%E9%93%BE%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E9%93%BE%E5%AE%B62018%E9%93%BE%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>小明喜欢在火车旅行的时候用手机听音乐，他有 N 首歌在手机里，在整个火车途中，他可以听 P 首歌，所以他想产生一个播放表产生 P 首歌曲，这个播放表的规则是： · 每首歌都要至少被播放一次 · 在两首一样的歌中间，至少有M首其他的歌 迈克在想有多少种不同的播放表可以产生，那么给你 N,M,P,你来算一下，输出结果取1000000007的余数</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>输入 N,M,P N 范围在 1 到 100 M 范围在 0 到 N P 范围在 N 到 100</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出结果 mod 1000000007 的余数 </code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>1 0 3 </code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>1</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>定义 songList(i,j) 为安排到了第 j 首歌时已经用了 i 首不同歌的安排的种类数</li><li>当 j&gt;i 时,萝卜多坑少,所以种类数为0</li><li>当 j==i 时,当然是全排列 A(n,n)</li><li>当 j&gt;m 时就可以出现重复了,有两种安排方法,添加新歌,添加重复歌,所以其值就是这两种情况的和<ul><li>当 j&lt;=n 时添加重复歌曲的种类为 songList(i-1,j)*(j-m)</li><li>当 j&gt;n 时添加重复歌曲的种类为 songList(i-1,j)*(n-m), 因为一共就 n 首歌</li></ul></li><li>songList(n,p) 即为所求</li><li>可以压缩空间复杂度为O(n)</li><li>状态转移方程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">songList(i,j) =|-&gt; 0, j&gt;i</span><br><span class="line">        |-&gt; songList(i-1,j-1)*(n-j+1), j==i</span><br><span class="line">        |-&gt; songList(i-1,j-1)*(n-j+1)+songList(i-1,j)*(min(j,n)-m), j&gt;m</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,p,songList[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(songList,<span class="number">0</span>,<span class="keyword">sizeof</span> songList);</span><br><span class="line">        songList[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=p;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j=n;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i)</span><br><span class="line">                    songList[j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==i)</span><br><span class="line">                    songList[j]=songList[j<span class="number">-1</span>]*(n-j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;m)</span><br><span class="line">                    songList[j]=songList[j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)+songList[j]*(min(j,n)-m);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    songList[j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(songList[j]&gt;=inf) songList[j]%=inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;songList[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 链家 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 链家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链家2018链习生招聘考试-编程题三</title>
      <link href="/posts/%E9%93%BE%E5%AE%B62018%E9%93%BE%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/"/>
      <url>/posts/%E9%93%BE%E5%AE%B62018%E9%93%BE%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>小明有 n( 1&lt;=n&lt;=2000 )个美味的食物,他想卖掉它们来赚钱.这些食物放在一些箱子里,他们有些有趣的特性1. 这些食物被编号为 1~n,每一天小明可以从这些箱子的头部或者尾部取出食物去卖2. 这些食物放得越久,年龄越大,价值越大,食物 i 有一个出事的价值 v(i)3. 放了 a 天后年龄为 a ,食物最终价值为 v(i)*a给定每一个食物的初始价值v(i),请求出小明卖掉它们后可以获得的最大价值,第一天出售的食物的年龄为 1,此后每增加一天食物的年龄就加 1</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第 1 行:一个整数 n第 2 到第 n+1 行:每个食物的初始价值 v </code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>1 行:小明最终可以获得的最大价值</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>513152</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>43</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>定义 income(i,j) 为已经卖出除编号 i 到 j 之外的食物,所得到的最大价值</li><li>income(i,i) 中最大值即为所求</li><li>可以优化空间复杂度 O(n*n) 为 O(n)</li><li>状态转移方程:( day 为卖出除编号 i 到 j 之外的食物所用的时间 )</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">income( i,j )=max( income( i-1,j )+food[i-1]*day,income( i,j+1 )+food[j+1]*day )</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,food[<span class="number">2002</span>],income[<span class="number">2002</span>],day,maxIncome;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(income,<span class="number">0</span>,<span class="keyword">sizeof</span> income);</span><br><span class="line">    maxIncome=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    food[<span class="number">0</span>]=food[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;food[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        day=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=i;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            income[j]=max(income[j]+food[i<span class="number">-1</span>]*day,income[j+<span class="number">1</span>]+food[j+<span class="number">1</span>]*day);</span><br><span class="line">            ++day;</span><br><span class="line">        &#125;</span><br><span class="line">        maxIncome=max(maxIncome,income[i]+food[i]*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxIncome;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 链家 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 链家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方向如何准备BAT技术面试答案(转)</title>
      <link href="/posts/Java%E6%96%B9%E5%90%91%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87BAT%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88-%E8%BD%AC/"/>
      <url>/posts/Java%E6%96%B9%E5%90%91%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87BAT%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul><li>本文作者:微信公众号JavaQ</li><li>原文链接:<a href="https://www.nowcoder.com/discuss/31667?type=5&order=3&pos=14&page=2" target="_blank" rel="noopener">Java方向如何准备BAT技术面试答案(转)</a></li></ul><hr><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><h5 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h5><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><h4 id="Java-的四个基本特性（抽象、封装、继承，多态）"><a href="#Java-的四个基本特性（抽象、封装、继承，多态）" class="headerlink" title="Java 的四个基本特性（抽象、封装、继承，多态）"></a>Java 的四个基本特性（抽象、封装、继承，多态）</h4><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><ul><li>就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。</li><li>抽象包括两个方面：一个是数据抽象，一个是过程抽象。</li><li>数据抽象也就是对象的属性。过程抽象是对象的行为特征。</li></ul><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul><li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。</li><li>封装分为属性的封装和方法的封装。</li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li>是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。</li><li>父类的意义在于抽取多类事物的共性。</li></ul><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul><li>允许不同类的对象对同一消息做出响应。</li><li>方法的重载、类的覆盖正体现了多态。</li></ul><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p><h4 id="构造器-Constructor-是否可被-override"><a href="#构造器-Constructor-是否可被-override" class="headerlink" title="构造器 Constructor 是否可被 override"></a>构造器 Constructor 是否可被 override</h4><p>构造器不能被重写，不能用static修饰构造器，只能用 public<br>private protected 这三个权限修饰符，且不能有返回语句。</p><h4 id="访问控制符-public-protected-private-以及-默认-的区别"><a href="#访问控制符-public-protected-private-以及-默认-的区别" class="headerlink" title="访问控制符 public,protected,private,以及 默认 的区别"></a>访问控制符 public,protected,private,以及 默认 的区别</h4><h5 id="private"><a href="#private" class="headerlink" title="private"></a>private</h5><p>只有在本类中才能访问</p><h5 id="public"><a href="#public" class="headerlink" title="public"></a>public</h5><p>在任何地方都能访问</p><h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><p>在同包内的类及包外的子类能访问</p><h5 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h5><p>在同包内能访问</p><h4 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类#"></a>是否可以继承 String 类#</h4><ul><li>String 类是 final 类故不可以继承</li><li>一切由 final 修饰过的都不能继承</li></ul><h4 id="String-和-StringBuffer、StringBuilder-的区别"><a href="#String-和-StringBuffer、StringBuilder-的区别" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别"></a>String 和 StringBuffer、StringBuilder 的区别</h4><h5 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h5><ul><li>String 类中使用字符数组保存字符串，private final char value[]，所以 string 对象是不可变的。</li><li>StringBuilder 与 StringBuffer 都继承自AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li></ul><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>AbstractStringBuilder 是 StringBuilder与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf等公共方法。</li><li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><ul><li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</li><li>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><h4 id="hashCode-和-equals方法的关系"><a href="#hashCode-和-equals方法的关系" class="headerlink" title="hashCode 和 equals方法的关系"></a>hashCode 和 equals方法的关系</h4><ul><li>equals 相等，hashcode 必相等</li><li>hashcode 相等，equals 可能不相等。</li></ul><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><h5 id="语法层次"><a href="#语法层次" class="headerlink" title="语法层次"></a>语法层次</h5><p>抽象类和接口分别给出了不同的语法定义。</p><h5 id="设计层次"><a href="#设计层次" class="headerlink" title="设计层次"></a>设计层次</h5><ul><li>抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。</li><li>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li><li>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</li></ul><h5 id="跨域不同"><a href="#跨域不同" class="headerlink" title="跨域不同"></a>跨域不同</h5><ul><li>抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在 “is-a” 关系，即父类和派生类在概念本质上应该是相同的。</li><li>对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，”like-a” 的关系。</li></ul><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li><li>Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</li></ul><h4 id="什么是泛型、为什么要使用以及泛型擦除"><a href="#什么是泛型、为什么要使用以及泛型擦除" class="headerlink" title="什么是泛型、为什么要使用以及泛型擦除"></a>什么是泛型、为什么要使用以及泛型擦除</h4><h5 id="泛型，即“参数化类型”。"><a href="#泛型，即“参数化类型”。" class="headerlink" title="泛型，即“参数化类型”。"></a>泛型，即“参数化类型”。</h5><ul><li>创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。</li><li>Java 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。</li><li>泛型擦除可以简单的理解为将泛型java 代码转换为普通 java 代码，只不过编译器更直接点，将泛型 java 代码直接转换成普通 java 字节码。</li></ul><h5 id="类型擦除的主要过程"><a href="#类型擦除的主要过程" class="headerlink" title="类型擦除的主要过程"></a>类型擦除的主要过程</h5><ol><li>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</li><li>移除所有的类型参数。</li></ol><h4 id="Java-中的集合类及关系图"><a href="#Java-中的集合类及关系图" class="headerlink" title="Java 中的集合类及关系图"></a>Java 中的集合类及关系图</h4><ul><li>List 和 Set 继承自 Collection 接口。</li><li>Set 无序不允许元素重复。HashSet 和 TreeSet 是两个主要的实现类。<br>List 有序且允许元素重复。ArrayList、LinkedList 和 Vector 是三个主要的实现类。</li><li>Map 也属于集合系统，但和 Collection接口没关系。Map 是 key 对 value 的映射集合，其中 key 列就是一个集合。key 不能重复，但是value 可以重复。HashMap、TreeMap 和 Hashtable 是三个主要的实现类。</li><li>SortedSet 和 SortedMap 接口对元素按指定规则排序，SortedMap 是对 key 列进行排序。</li></ul><h4 id="HashMap-实现原理"><a href="#HashMap-实现原理" class="headerlink" title="HashMap 实现原理"></a>HashMap 实现原理</h4><p>具体原理参考文章：</p><ul><li><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></li><li><a href="http://www.admin10000.com/document/3322.html" target="_blank" rel="noopener">HashMap的工作原理</a></li></ul><h4 id="HashTable-实现原理"><a href="#HashTable-实现原理" class="headerlink" title="HashTable 实现原理"></a>HashTable 实现原理</h4><p>具体原理参考文章：</p><ul><li><a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener">Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a></li><li><a href="http://blog.csdn.net/chdjj/article/details/38581035" target="_blank" rel="noopener">【源码】Hashtable源码剖析</a></li></ul><h4 id="HashMap-和-HashTable区别"><a href="#HashMap-和-HashTable区别" class="headerlink" title="HashMap 和 HashTable区别"></a>HashMap 和 HashTable区别</h4><ol><li>HashTable 的方法前面都有 synchronized 来同步，是线程安全的；HashMap 未经同步，是非线程安全的。</li><li>HashTable 不允许 null 值( key 和 value 都不可以)；HashMap 允许 null 值( key 和 value 都可以)。</li><li>HashTable 有一个 contains ( Object value ) 功能和containsValue ( Object value ) 功能一样。</li><li>HashTable 使用 Enumeration 进行遍历；HashMap 使用 Iterator 进行遍历。</li><li>HashTable 中 hash 数组默认大小是 11，增加的方式是 old*2+1；HashMap 中 hash 数组的默认大小是 16，而且一定是 2 的指数。</li><li>哈希值的使用不同，HashTable 直接使用对象的 hashCode；  HashMap 重新计算 hash 值，而且用与代替求模。</li></ol><h4 id="ArrayList-和-vector-区别"><a href="#ArrayList-和-vector-区别" class="headerlink" title="ArrayList 和 vector 区别"></a>ArrayList 和 vector 区别</h4><ul><li>ArrayList 和 Vector 都实现了 List 接口，都是通过数组实现的。</li><li>Vector 是线程安全的，而 ArrayList 是非线程安全的。</li><li>List 第一次创建的时候，会有一个初始大小，随着不断向 List 中增加元素，当 List 认为容量不够的时候就会进行扩容。</li><li>Vector 缺省情况下自动增长原来一倍的数组长度，ArrayList 增长原来的 50%。</li></ul><h4 id="ArrayList-和-LinkedList-区别及使用场景"><a href="#ArrayList-和-LinkedList-区别及使用场景" class="headerlink" title="ArrayList 和 LinkedList 区别及使用场景"></a>ArrayList 和 LinkedList 区别及使用场景</h4><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>ArrayList 底层是用数组实现的，可以认为 ArrayList 是一个可改变大小的数组。随着越来越多的元素被添加到 ArrayList中，其规模是动态增加的。</li><li>LinkedList 底层是通过双向链表实现的， LinkedList 和 ArrayList相比，增删的速度较快。但是查询和修改值的速度较慢。同时，LinkedList 还实现了Queue接口，所以他还提供了 offer(), peek(), poll() 等方法</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>LinkedList 更适合从中间插入或者删除（链表的特性）。</li><li>ArrayList 更适合检索和在末尾插入或删除（数组的特性）。</li></ul><h4 id="Collection-和-Collections-的区别"><a href="#Collection-和-Collections-的区别" class="headerlink" title="Collection 和 Collections 的区别"></a>Collection 和 Collections 的区别</h4><ul><li>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li><li>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</li></ul><h4 id="ConcurrentHashMap-实现原理"><a href="#ConcurrentHashMap-实现原理" class="headerlink" title="ConcurrentHashMap 实现原理"></a>ConcurrentHashMap 实现原理</h4><p>具体原理参考文章：</p><ul><li><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="noopener">Java集合—ConcurrentHashMap原理分析</a></li><li><a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">聊聊并发（四）深入分析ConcurrentHashMap</a></li></ul><h4 id="Error、Exception-区别"><a href="#Error、Exception-区别" class="headerlink" title="Error、Exception 区别"></a>Error、Exception 区别</h4><p>Error 类和 Exception 类的父类都是 throwable 类</p><h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><ul><li>Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</li><li>Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</li></ul><h4 id="Unchecked-Exception-和-Checked-Exception"><a href="#Unchecked-Exception-和-Checked-Exception" class="headerlink" title="Unchecked Exception 和 Checked Exception"></a>Unchecked Exception 和 Checked Exception</h4><h5 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception:"></a>Unchecked Exception:</h5><ol><li>指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复。</li><li>包括 Error 与 RuntimeException 及其子类，如：<br> OutOfMemoryError, UndeclaredThrowableException, IllegalArgumentException, IllegalMonitorStateException, NullPointerException, IllegalStateException, IndexOutOfBoundsException 等。</li><li>语法上不需要声明抛出异常。</li></ol><h5 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception:"></a>Checked Exception:</h5><ol><li>代表程序不能直接控制的无效外界情况（如用户输入，数据库问题，网络异常，文件丢失等）</li><li>除了 Error 和 RuntimeException 及其子类之外，如：<br> ClassNotFoundException, NamingException, ServletException, SQLException, IOException 等。</li><li>需要 try catch 处理或 throws 声明抛出异常。</li></ol><h4 id="Java-中如何实现代理机制-JDK、CGLIB"><a href="#Java-中如何实现代理机制-JDK、CGLIB" class="headerlink" title="Java 中如何实现代理机制 (JDK、CGLIB)"></a>Java 中如何实现代理机制 (JDK、CGLIB)</h4><ul><li>JDK 动态代理：代理类和目标类实现了共同的接口，用到 InvocationHandler 接口。</li><li>CGLIB 动态代理：代理类是目标类的子类，用到 MethodInterceptor 接口。</li></ul><h4 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>使用 ExecutorService、Callable、Future 实现有返回结果的多线程。</li></ul><h4 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h4><p><img src="https://x3jy9g-sn3302.files.1drv.com/y4m4-uYv-u_zhiQDb78xALmHuNRYk0OxXuJOc3riCT-NAmiFXfdFhuFKhhtLkXz6YIB3zps69kQQXCC-YXpRarY8v_fpheUC5G-P1VDOC7RWWZlfFlTdlaMNXZJO4GXzBlQTa68gkgJgb4tzFGgcOkrrvbOb4R-eTMwEV2G0D54PnsLh8Rn8S1E77h-_VbaA98UHCNHtNZaYG3sVSy0aHyo1A?width=730&height=496&cropmode=none" alt="ThreadStatusChange.jpg"></p><h4 id="如何停止一个线程"><a href="#如何停止一个线程" class="headerlink" title="如何停止一个线程"></a>如何停止一个线程</h4><p>参考文章：</p><ul><li><a href="http://www.cnblogs.com/greta/p/5624839.html" target="_blank" rel="noopener">如何正确地停止一个线程？</a></li></ul><h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><p>线程安全就是多线程访问同一代码，不会产生不确定的结果。</p><h4 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h4><ul><li>对非安全的代码进行加锁控制；</li><li>使用线程安全的类；</li><li>多线程并发情况下，线程共享的变量改为方法级的局部变量。</li></ul><h4 id="synchronized-如何使用"><a href="#synchronized-如何使用" class="headerlink" title="synchronized 如何使用"></a>synchronized 如何使用</h4><p>synchronized是Java中的关键字，是一种同步锁。</p><h5 id="修饰的对象："><a href="#修饰的对象：" class="headerlink" title="修饰的对象："></a>修饰的对象：</h5><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li><li>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ol><h4 id="synchronized-和-Lock-的区别"><a href="#synchronized-和-Lock-的区别" class="headerlink" title="synchronized 和 Lock 的区别"></a>synchronized 和 Lock 的区别</h4><h5 id="主要相同点"><a href="#主要相同点" class="headerlink" title="主要相同点"></a>主要相同点</h5><p>Lock 能完成 synchronized 所实现的所有功能</p><h5 id="主要不同点"><a href="#主要不同点" class="headerlink" title="主要不同点"></a>主要不同点</h5><ul><li>Lock 有比 synchronized 更精确的线程语义和更好的性能。</li><li>Lock 的锁定是通过代码实现的，而 synchronized 是在JVM层面上实现的，synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且必须在 finally 从句中释放。</li><li>Lock 还有更强大的功能，例如，它的 tryLock 方法可以非阻塞方式去拿锁。</li><li>Lock 锁的范围有局限性，块范围，而 synchronized 可以锁住块、对象、类。</li></ul><h4 id="多线程如何进行信息交互"><a href="#多线程如何进行信息交互" class="headerlink" title="多线程如何进行信息交互"></a>多线程如何进行信息交互</h4><ul><li>void notify() 唤醒在此对象监视器上等待的单个线程。</li><li>void notifyAll() 唤醒在此对象监视器上等待的所有线程。</li><li>void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</li><li>void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</li><li>void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</li></ul><h4 id="sleep-和-wait-的区别-考察的方向是是否会释放锁"><a href="#sleep-和-wait-的区别-考察的方向是是否会释放锁" class="headerlink" title="sleep 和 wait 的区别(考察的方向是是否会释放锁)"></a>sleep 和 wait 的区别(考察的方向是是否会释放锁)</h4><ul><li>sleep() 方法是 Thread 类中方法，而 wait() 方法是Object类中的方法。</li><li>sleep() 方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用 sleep() 方法的过程中，线程不会释放对象锁。</li><li>而当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify() 方法后本线程才进入对象锁定池准备。</li></ul><h4 id="多线程与死锁"><a href="#多线程与死锁" class="headerlink" title="多线程与死锁"></a>多线程与死锁</h4><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><h5 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h5><ol><li>因为系统资源不足。</li><li>进程运行推进的顺序不合适。</li><li>资源分配不当。</li></ol><h4 id="如何才能产生死锁"><a href="#如何才能产生死锁" class="headerlink" title="如何才能产生死锁"></a>如何才能产生死锁</h4><h5 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h5><ol><li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><p>打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。</p><ol><li>打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</li><li>打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</li><li>打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</li><li>打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。</li></ol><h4 id="什么叫守护线程，用什么方法实现守护线程"><a href="#什么叫守护线程，用什么方法实现守护线程" class="headerlink" title="什么叫守护线程，用什么方法实现守护线程"></a>什么叫守护线程，用什么方法实现守护线程</h4><ul><li>守护线程是为其他线程的运行提供服务的线程。</li><li>setDaemon( boolean on ) 方法可以方便的设置线程的 Daemon 模式，true 为守护模式，false 为用户模式。</li></ul><h4 id="Java-线程池技术及原理"><a href="#Java-线程池技术及原理" class="headerlink" title="Java 线程池技术及原理"></a>Java 线程池技术及原理</h4><p>参考文章：</p><ul><li><a href="http://www.importnew.com/19011.html" target="_blank" rel="noopener">深入理解Java之线程池</a></li><li><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></li></ul><h4 id="java-并发包-concurrent-及常用的类"><a href="#java-并发包-concurrent-及常用的类" class="headerlink" title="java 并发包 concurrent 及常用的类"></a>java 并发包 concurrent 及常用的类</h4><p>这个内容有点多，参考文章：</p><ul><li>并发包诸类概览：<a href="http://www.raychase.net/1912" target="_blank" rel="noopener">java.util.concurrent并发包诸类概览</a></li><li>线程池：<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></li><li>锁：<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></li><li>集合：<a href="http://www.cnblogs.com/huangfox/archive/2012/08/16/2642666.html" target="_blank" rel="noopener">java中并发包简要分析01</a></li></ul><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><ul><li><p>用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。</p></li><li><p>Java语言中的 volatile 变量可以被看作是一种“程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。</p></li><li><p>锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的，如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。</p></li><li><p>要使volatile变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li><p>对变量的写操作不依赖于当前值；</p></li><li><p>该变量没有包含在具有其他变量的不变式中。</p><p>第一个条件的限制使volatile变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作需要使x 的值在操作期间保持不变，而volatile变量无法实现这点。</p><p>每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。<br><img src="https://vhjy9g-sn3302.files.1drv.com/y4m41N3ZJMP9CpUCUC917g7d9lx2NMZTo6pnoZd_1oYt4y4kAotSYYMvJzQkCsykcj0cDaMZ68qlWruAqW2vjt31KuIbiBLaI8jDTUKJYtzEK2aQ7QrFK6G-JwK8wFxOsCBnVnNVQpeY8duYIG89rgro3jYggBlpr5tc8Gb3heb0ePMI6nbF0QK4u-U9D1j6ZIuw2--PDWzaIRd0K8z3Qia1g?width=577&height=555&cropmode=none" alt="JavaVolatile.jpg"><br>read and load 从主存复制变量到当前工作内存<br>use and assign 执行代码，改变共享变量值<br>store and write 用工作内存数据刷新主存相关内容<br>其中 use and assign 可以多次出现，但是这一些操作并不是原子性，也就是在 read load 之后，如果主内存 count 变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。</p></li></ul></li></ul><h4 id="Java中的-NIO，BIO，AIO-分别是什么"><a href="#Java中的-NIO，BIO，AIO-分别是什么" class="headerlink" title="Java中的 NIO，BIO，AIO 分别是什么"></a>Java中的 NIO，BIO，AIO 分别是什么</h4><h5 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h5><ul><li>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。</li></ul><h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><ul><li>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。</li></ul><h5 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h5><ul><li>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.</li><li>AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK 7 开始支持。</li></ul><h4 id="IO-和-NIO-区别"><a href="#IO-和-NIO-区别" class="headerlink" title="IO 和 NIO 区别"></a>IO 和 NIO 区别</h4><ol><li>IO 是面向流的，NIO 是面向缓冲区的。</li><li>IO的各种流是阻塞的，NIO是非阻塞模式。</li><li>Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</li></ol><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><ul><li>把对象转换为字节序列的过程称为对象的序列化。</li><li>把字节序列恢复为对象的过程称为对象的反序列化。</li><li>对象的序列化主要有两种用途：<ol><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li><li>在网络上传送对象的字节序列。</li></ol></li><li>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。</li><li>发送方需要把这个 Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为 Java 对象。</li></ul><h4 id="常见的序列化协议有哪些"><a href="#常见的序列化协议有哪些" class="headerlink" title="常见的序列化协议有哪些"></a>常见的序列化协议有哪些</h4><p>Protobuf, Thrift, Hessian, Kryo</p><h4 id="内存溢出和内存泄漏的区别"><a href="#内存溢出和内存泄漏的区别" class="headerlink" title="内存溢出和内存泄漏的区别"></a>内存溢出和内存泄漏的区别</h4><ul><li>内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。</li><li>内存泄漏是指分配出去的内存不再使用，但是无法回收。</li></ul><h4 id="Java-内存模型及各个区域的-OOM，如何重现-OOM"><a href="#Java-内存模型及各个区域的-OOM，如何重现-OOM" class="headerlink" title="Java 内存模型及各个区域的 OOM，如何重现 OOM"></a>Java 内存模型及各个区域的 OOM，如何重现 OOM</h4><p>这部分内容很重要，详细阅读《深入理解 Java 虚拟机》，也可以详细阅读这篇文章 </p><ul><li><a href="http://hllvm.group.iteye.com/group/wiki/2857-JVM" target="_blank" rel="noopener">JVM内存管理：深入Java内存区域与OOM</a></li></ul><h4 id="出现OOM如何解决"><a href="#出现OOM如何解决" class="headerlink" title="出现OOM如何解决"></a>出现OOM如何解决</h4><ol><li>可通过命令定期抓取 heap dump 或者启动参数 OOM 时自动抓取 heap dump 文件。</li><li>通过对比多个 heap dump，以及 heap dump 的内容，分析代码找出内存占用最多的地方。</li><li>分析占用的内存对象，是否是因为错误导致的内存未及时释放，或者数据过多导致的内存溢出。</li></ol><h4 id="用什么工具可以查出内存泄漏"><a href="#用什么工具可以查出内存泄漏" class="headerlink" title="用什么工具可以查出内存泄漏"></a>用什么工具可以查出内存泄漏</h4><ol><li>Memory Analyzer－是一款开源的 JAVA 内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于 Eclipse RCP(Rich Client Platform)，可以下载 RCP 的独立版本或者 Eclipse 的插件。</li><li>JProbe－分析 Java 的内存泄漏。</li><li>JProfiler－一个全功能的 Java 剖析工具，专用于分析 J2SE 和 J2EE 应用程序。它把 CPU、执行绪 和 内存 的剖析组合在一个强大的应用中，GUI 可以找到效能瓶颈、抓出内存泄漏、并解决执行绪的问题。</li><li>JRockit－用来诊断 Java 内存泄漏并指出根本原因，专门针对 Intel 平台并得到优化，能在 Intel 硬件上获得最高的性能。</li><li>YourKit-.NET &amp; Java Profiling 业界领先的 Java 和 .NET 程序性能分析工具。</li><li>AutomatedQA －AutomatedQA 的获奖产品 performance profiling 和 memory debugging 工具集的下一代替换产品，支持 Microsoft,Borland, Intel, Compaq 和 GNU 编译器。可以为 .NET 和 Windows 程序生成全面细致的报告，从而帮助您轻松隔离并排除代码中含有的性能问题和内存/资源泄露问题。支持 .Net 1.0,1.1,2.0,3.0 和 Windows 32/64 位应用程序。</li><li>Compuware DevPartner Java Edition－包含 Java 内存检测,代码覆盖率测试,代码性能测试,线程死锁,分布式应用等几大功能模块</li></ol><h4 id="Java-内存管理及回收算法"><a href="#Java-内存管理及回收算法" class="headerlink" title="Java 内存管理及回收算法"></a>Java 内存管理及回收算法</h4><p>阅读这篇文章：</p><ul><li><a href="http://www.cnblogs.com/hnrainll/archive/2013/11/06/3410042.html" target="_blank" rel="noopener">Java 内存区域和GC机制</a></li></ul><h4 id="Java-类加载器及如何加载类-双亲委派"><a href="#Java-类加载器及如何加载类-双亲委派" class="headerlink" title="Java 类加载器及如何加载类(双亲委派)"></a>Java 类加载器及如何加载类(双亲委派)</h4><p>阅读文章：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></li><li><a href="http://blog.csdn.net/zhoudaxia/article/details/35824249" target="_blank" rel="noopener">深入理解Java类加载器(1)：Java类加载原理解析</a></li></ul><h4 id="XML-解析方式"><a href="#XML-解析方式" class="headerlink" title="XML 解析方式"></a>XML 解析方式</h4><ol><li>DOM(JAXP Crimson解析器)</li><li>SAX</li><li>JDOM</li><li>DOM4J</li></ol><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ol><li>DOM4J 性能最好，连 Sun 的 JAXM 也在用 DOM4J。目前许多开源项目中大量采用 DOM4J，例如大名鼎鼎的 hibernate 也用 DOM4J 来读取 XML 配置文件。如果不考虑可移植性，那就采用 DOM4J.</li><li>JDOM 和 DOM 在性能测试时表现不佳，在测试 10M 文档时内存溢出。在小文档情况下还值得考虑使用 DOM 和 JDOM。虽然 JDOM 的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM 仍是一个非常好的选择。DOM 实现广泛应用于多种编程语言。它还是许多其它与 XML 相关的标准的基础，因为它正式获得 W3C 推荐 ( 与基于非标准的 Java 模型相对 )，所以在某些类型的项目中可能也需要它 ( 如在 JavaScript 中使用 DOM )。</li><li>SAX 表现较好，这要依赖于它特定的解析方式－事件驱动。一个 SAX 检测即将到来的 XML 流，但并没有载入到内存 ( 当然当 XML 流被读入时，会有部分文档暂时隐藏在内存中 )。</li></ol><h4 id="Statement-和-PreparedStatement-之间的区别"><a href="#Statement-和-PreparedStatement-之间的区别" class="headerlink" title="Statement 和 PreparedStatement 之间的区别"></a>Statement 和 PreparedStatement 之间的区别</h4><ol><li><p>PreparedStatement 是预编译的,对于批量处理可以大大提高效率. 也叫 JDBC 存储过程</p></li><li><p>使用 Statement 对象。在对数据库只执行一次性存取的时侯，用 Statement 对象进行处理。PreparedStatement 对象的开销比 Statement 大，对于一次性操作并不会带来额外的好处。</p></li><li><p>Statement 每次执行 sql 语句，相关数据库都要执行 sql 语句的编译，preparedStatement 是预编译得, PreparedStatement 支持批处理</p></li><li><ul><li><p>代码片段1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String updateString = <span class="string">"UPDATE COFFEES SET SALES = 75 "</span> + <span class="string">"WHERE</span></span><br><span class="line"><span class="string">COF_NAME LIKE ′Colombian′"</span>;</span><br><span class="line">stmt.executeUpdate(updateString);</span><br></pre></td></tr></table></figure></li><li><p>代码片段2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement updateSales = con.prepareStatement(<span class="string">"UPDATE COFFEES SET</span></span><br><span class="line"><span class="string">SALES = ? WHERE COF_NAME LIKE ? "</span>);</span><br><span class="line">updateSales.setInt(<span class="number">1</span>, <span class="number">75</span>);</span><br><span class="line">updateSales.setString(<span class="number">2</span>, <span class="string">"Colombian"</span>);</span><br><span class="line">updateSales.executeUpdate();</span><br></pre></td></tr></table></figure></li><li><p>片断2 和 片断1 的区别在于，后者使用了 PreparedStatement 对象，而前者是普通的 Statement 对象。PreparedStatement 对象不仅包含了 SQL 语句，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需 DBMS 运行 SQL 语句，而不必先编译。当你需要执行 Statement 对象多次的时候，PreparedStatement 对象将会大大降低运行时间，当然也加快了访问数据库的速度。</p></li><li><p>这种转换也给你带来很大的便利，不必重复 SQL 语句的句法，而只需更改其中变量的值，便可重新执行 SQL 语句。选择 PreparedStatement 对象与否，在于相同句法的 SQL 语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。</p></li></ul></li><li><ol><li>执行许多 SQL 语句的 JDBC 程序产生大量的 Statement 和 PreparedStatement 对象。通常认为 PreparedStatement 对象比 Statement 对象更有效,特别是如果带有不同参数的同一 SQL 语句被多次执行的时候。PreparedStatement 对象允许数据库预编译 SQL 语句，这样在随后的运行中可以节省时间并增加代码的可读性。</li><li>然而，在 Oracle 环境中，开发人员实际上有更大的灵活性。当使用 Statement 或 PreparedStatement 对象时，Oracle 数据库会缓存 SQL 语句以便以后使用。在一些情况下,由于驱动器自身需要额外的处理和在 Java 应用程序和 Oracle 服务器间增加的网络活动，执行 PreparedStatement 对象实际上会花更长的时间。</li><li>然而，除了缓冲的问题之外，至少还有一个更好的原因使我们在企业应用程序中更喜欢使用 PreparedStatement 对象,那就是安全性。传递给 PreparedStatement 对象的参数可以被强制进行类型转换，使开发人员可以确保在插入或查询数据时与底层的数据库格式匹配。</li><li>当处理公共 Web 站点上的用户传来的数据的时候，安全性的问题就变得极为重要。传递给 PreparedStatement 的字符串参数会自动被驱动器忽略。最简单的情况下，这就意味着当你的程序试着将字符串 “D’Angelo” 插入到 VARCHAR2 中时，该语句将不会识别第一个 “’”，从而导致悲惨的失败。几乎很少有必要创建你自己的字符串忽略代码。</li><li>在Web环境中，有恶意的用户会利用那些设计不完善的、不能正确处理字符串的应用程序。特别是在公共Web站点上,在没有首先通过 PreparedStatement 对象处理的情况下，所有的用户输入都不应该传递给 SQL 语句。此外，在用户有机会修改 SQL 语句的地方，如 HTML 的隐藏区域或一个查询字符串上，SQL 语句都不应该被显示出来。</li></ol></li></ol><h4 id="servlet-生命周期及各个方法"><a href="#servlet-生命周期及各个方法" class="headerlink" title="servlet 生命周期及各个方法"></a>servlet 生命周期及各个方法</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html" target="_blank" rel="noopener">Servlet 生命周期、工作原理</a></li></ul><h4 id="servlet-中如何自定义-filter"><a href="#servlet-中如何自定义-filter" class="headerlink" title="servlet 中如何自定义 filter"></a>servlet 中如何自定义 filter</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/javawebsoa/archive/2013/07/31/3228858.html" target="_blank" rel="noopener">Servlet Filter</a></li></ul><h4 id="JSP-原理"><a href="#JSP-原理" class="headerlink" title="JSP 原理"></a>JSP 原理</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/hanxuemin12345/article/details/23831645" target="_blank" rel="noopener">JSP运行原理及运行过程</a></li></ul><h4 id="JSP-和-Servlet-的区别"><a href="#JSP-和-Servlet-的区别" class="headerlink" title="JSP 和 Servlet 的区别"></a>JSP 和 Servlet 的区别</h4><ol><li>JSP 经编译后就变成了 “类 servlet”。</li><li>JSP 由 HTML 代码和 JSP 标签构成，更擅长页面显示；Servlet 更擅长流程控制。</li><li>JSP 中嵌入 JAVA 代码，而 Servlet 中嵌入 HTML 代码。</li></ol><h4 id="JSP的动态-include-和静态-include"><a href="#JSP的动态-include-和静态-include" class="headerlink" title="JSP的动态 include 和静态 include"></a>JSP的动态 include 和静态 include</h4><ol><li>动态 include用 jsp:include 动作实现，如 <code>&lt;jsp:include page=&quot;abc.jsp&quot; flush=&quot;true&quot; /&gt;</code>，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。会先解析所要包含的页面，解析后和主页面合并一起显示，即先编译后包含。</li><li>静态 include 用 include 伪码实现，不会检查所含文件的变化，适用于包含静态页面，如 <code>&lt;%@ include file=&quot;qq.htm&quot; %&gt;</code>，不会提前解析所要包含的页面，先把要显示的页面包含进来，然后统一编译，即先包含后编译。</li></ol><h4 id="Struts-中请求处理过程"><a href="#Struts-中请求处理过程" class="headerlink" title="Struts 中请求处理过程"></a>Struts 中请求处理过程</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/liuling/p/2013-8-10-01.html" target="_blank" rel="noopener">struts2请求过程源码分析</a></li></ul><h4 id="MVC-概念"><a href="#MVC-概念" class="headerlink" title="MVC 概念"></a>MVC 概念</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/scwyh/articles/1436802.html" target="_blank" rel="noopener">MVC的概念</a></li></ul><h4 id="SpringMVC-与-Struts-区别"><a href="#SpringMVC-与-Struts-区别" class="headerlink" title="SpringMVC 与 Struts 区别"></a>SpringMVC 与 Struts 区别</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/tch918/article/details/38305395v" target="_blank" rel="noopener">同是流行MVC框架，比较Strtus2和SpringMVC的区别</a></li><li><a href="http://blog.csdn.net/chenleixing/article/details/44570681" target="_blank" rel="noopener">SpringMVC与Struts2区别与比较总结</a></li></ul><h4 id="Hibernate-Ibatis-两者的区别"><a href="#Hibernate-Ibatis-两者的区别" class="headerlink" title="Hibernate/Ibatis 两者的区别"></a>Hibernate/Ibatis 两者的区别</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/firejuly/article/details/8190229" target="_blank" rel="noopener">Hibernate与 MyBatis的比较</a></li></ul><h4 id="Hibernate-一级和二级缓存"><a href="#Hibernate-一级和二级缓存" class="headerlink" title="Hibernate 一级和二级缓存"></a>Hibernate 一级和二级缓存</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/windrui/article/details/23165845" target="_blank" rel="noopener">Hibernate缓存：一级缓存和二级缓存</a></li></ul><h4 id="简述-Hibernate-常见优化策略"><a href="#简述-Hibernate-常见优化策略" class="headerlink" title="简述 Hibernate 常见优化策略"></a>简述 Hibernate 常见优化策略</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/shimiso/article/details/8819114" target="_blank" rel="noopener">Hibernate性能优化的常用措施</a></li></ul><h4 id="SpringBean-的加载过程-推荐看-Spring-的源码"><a href="#SpringBean-的加载过程-推荐看-Spring-的源码" class="headerlink" title="SpringBean 的加载过程(推荐看 Spring 的源码)"></a>SpringBean 的加载过程(推荐看 Spring 的源码)</h4><p>参考文章</p><ul><li><a href="http://geeekr.com/read-spring-source-1-how-to-load-bean/" target="_blank" rel="noopener">看看Spring的源码（一）——Bean加载过程</a></li></ul><h4 id="SpringBean-的实例化-推荐看-Spring-的源码"><a href="#SpringBean-的实例化-推荐看-Spring-的源码" class="headerlink" title="SpringBean 的实例化(推荐看 Spring 的源码)"></a>SpringBean 的实例化(推荐看 Spring 的源码)</h4><p>参考文章</p><ul><li><a href="http://geeekr.com/read-spring-source-two-beans-initialization/" target="_blank" rel="noopener">看看Spring的源码(二)——bean实例化</a></li></ul><h4 id="Spring-如何实现-AOP-和-IOC-推荐看-Spring-的源码"><a href="#Spring-如何实现-AOP-和-IOC-推荐看-Spring-的源码" class="headerlink" title="Spring 如何实现 AOP 和 IOC (推荐看 Spring 的源码)"></a>Spring 如何实现 AOP 和 IOC (推荐看 Spring 的源码)</h4><p>参考文章</p><ul><li><a href="http://www.360doc.com/content/15/0116/21/12385684_441408260.shtml" target="_blank" rel="noopener">Java轻量级业务层框架Spring两大核心IOC和AOP原理</a></li></ul><h4 id="SpringBean-注入方式"><a href="#SpringBean-注入方式" class="headerlink" title="SpringBean 注入方式"></a>SpringBean 注入方式</h4><p>参考文章</p><ul><li><a href="http://blessht.iteye.com/blog/1162131" target="_blank" rel="noopener">spring四种依赖注入方式</a></li></ul><h4 id="Spring-的事务管理"><a href="#Spring-的事务管理" class="headerlink" title="Spring 的事务管理"></a>Spring 的事务管理</h4><p>这个主题的参考文章没找到特别好的</p><ul><li><a href="http://blog.csdn.net/trigl/article/details/50968079" target="_blank" rel="noopener">Spring事务管理（详解+实例）</a></li></ul><h4 id="Spring-事务的传播特性"><a href="#Spring-事务的传播特性" class="headerlink" title="Spring 事务的传播特性"></a>Spring 事务的传播特性</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/lfsf802/article/details/9417095" target="_blank" rel="noopener">Spring事务的传播特性</a></li></ul><h4 id="SpringMVC-原理"><a href="#SpringMVC-原理" class="headerlink" title="SpringMVC 原理"></a>SpringMVC 原理</h4><p>参考文章</p><ul><li><a href="http://blog.sina.com.cn/s/blog_7ef0a3fb0101po57.html" target="_blank" rel="noopener">SpringMVC工作原理</a></li></ul><h4 id="SpringMVC-用过哪些注解"><a href="#SpringMVC-用过哪些注解" class="headerlink" title="SpringMVC 用过哪些注解"></a>SpringMVC 用过哪些注解</h4><p>参考文章</p><ul><li><a href="http://aijuans.iteye.com/blog/2160141" target="_blank" rel="noopener">详解Spring MVC 4常用的那些注解</a></li></ul><h4 id="Restful-有几种请求"><a href="#Restful-有几种请求" class="headerlink" title="Restful 有几种请求"></a>Restful 有几种请求</h4><p>参考文章</p><ul><li><a href="http://www.infoq.com/cn/articles/designing-restful-http-apps-roth" target="_blank" rel="noopener">RESTful HTTP的实践</a></li></ul><h4 id="Restful-好处"><a href="#Restful-好处" class="headerlink" title="Restful 好处"></a>Restful 好处</h4><ol><li>客户-服务器：客户-服务器约束背后的原则是分离关注点。通过分离用户接口和数据存储这两个关注点，改善了用户接口跨多个平台的可移植性；同时通过简化服务器组件，改善了系统的可伸缩性。</li><li>无状态：通信在本质上是无状态的，改善了可见性、可靠性、可伸缩性.</li><li>缓存：改善了网络效率减少一系列交互的平均延迟时间，来提高效率、可伸缩性和用户可觉察的性能。</li><li>统一接口：REST 架构风格区别于其他基于网络的架构风格的核心特征是，它强调组件之间要有一个统一的接口。</li></ol><h4 id="Tomcat，Apache，JBoss-的区别"><a href="#Tomcat，Apache，JBoss-的区别" class="headerlink" title="Tomcat，Apache，JBoss 的区别"></a>Tomcat，Apache，JBoss 的区别</h4><h5 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h5><p>HTTP 服务器( WEB 服务器 )，类似 IIS，可以用于建立虚拟站点，编译处理静态页面，可以支持 SSL 技术，支持多个虚拟主机等功能。</p><h5 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h5><p>Servlet 容器，用于解析 jsp，Servlet 的 Servlet 容器，是高效，轻量级的容器。缺点是不支持 EJB，只能用于 java 应用。</p><h5 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h5><p>应用服务器，运行 EJB 的 J2EE 应用服务器，遵循 J2EE 规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA 等，其对 Servlet 的支持是通过集成其他 Servlet 容器来实现的，如 tomcat 和 jetty。</p><h4 id="Memcached-和-Redis-的区别"><a href="#Memcached-和-Redis-的区别" class="headerlink" title="Memcached 和 Redis 的区别"></a>Memcached 和 Redis 的区别</h4><ol><li>性能对比：由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li><li>内存使用效率对比：使用简单的 key-value 存储的话，Memcached 的内存利用率更高，而如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 Memcached。</li><li>Redis 支持服务器端的数据操作：Redis 相比 Memcached 来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在 Memcached 里，你需要将数据拿到客户端来进行类似的修改再 set 回去。这大大增加了网络 IO 的次数和数据体积。在 Redis 中，这些复杂的操作通常和一般的 GET/SET 一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么 Redis 会是不错的选择。</li></ol><h4 id="如何理解分布式锁"><a href="#如何理解分布式锁" class="headerlink" title="如何理解分布式锁"></a>如何理解分布式锁</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/zheng0518/article/details/51607063" target="_blank" rel="noopener">分布式锁1 Java常用技术方案</a></li><li><a href="http://blog.csdn.net/nicewuranran/article/details/51730131" target="_blank" rel="noopener">分布式锁实现机制</a></li></ul><h4 id="你知道的开源协议有哪些"><a href="#你知道的开源协议有哪些" class="headerlink" title="你知道的开源协议有哪些"></a>你知道的开源协议有哪些</h4><p>常见的开源协议有 GPL、LGPL、BSD、Apache Licence vesion 2.0、MIT，详细内容参考文章</p><ul><li><a href="http://blog.jobbole.com/44175/" target="_blank" rel="noopener">如何选择开源许可协议（一）：了解协议</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">如何选择开源许可证？</a></li></ul><h4 id="JSON-和-XML-区别"><a href="#JSON-和-XML-区别" class="headerlink" title="JSON 和 XML 区别"></a>JSON 和 XML 区别</h4><h5 id="XML"><a href="#XML" class="headerlink" title="XML:"></a>XML:</h5><ol><li>应用广泛，可扩展性强，被广泛应用各种场合；</li><li>读取、解析没有JSON快；</li><li>可读性强，可描述复杂结构</li></ol><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON:"></a>JSON:</h5><ol><li>结构简单，都是键值对；</li><li>读取、解析速度快，很多语言支持；</li><li>传输数据量小，传输速率大大提高；</li><li>描述复杂结构能力较弱。</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445" target="_blank" rel="noopener">23种设计模式</a></li></ul><h4 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h4><p>参考文章</p><ul><li><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">设计模式六大原则</a></li></ul><h4 id="用一个设计模式写一段代码或画出一个设计模式的UML"><a href="#用一个设计模式写一段代码或画出一个设计模式的UML" class="headerlink" title="用一个设计模式写一段代码或画出一个设计模式的UML"></a>用一个设计模式写一段代码或画出一个设计模式的UML</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445" target="_blank" rel="noopener">23种设计模式</a></li></ul><h4 id="高内聚，低耦合方面的理解"><a href="#高内聚，低耦合方面的理解" class="headerlink" title="高内聚，低耦合方面的理解"></a>高内聚，低耦合方面的理解</h4><p>参考文章</p><ul><li><a href="http://my.oschina.net/heweipo/blog/423235" target="_blank" rel="noopener">小菜学设计模式——高内聚、低耦合</a></li></ul><h4 id="深度优先和广度优先算法"><a href="#深度优先和广度优先算法" class="headerlink" title="深度优先和广度优先算法"></a>深度优先和广度优先算法</h4><p>推荐看书籍复习！可参考文章</p><ul><li><a href="http://blog.163.com/zhoumhan_0351/blog/static/3995422720098342257387/" target="_blank" rel="noopener">深度优先算法，图的遍历</a></li><li><a href="http://blog.163.com/zhoumhan_0351/blog/static/3995422720098711040303/" target="_blank" rel="noopener">广度优先搜索，图的遍历</a></li><li><a href="http://blog.csdn.net/andyelvis/article/details/1728378" target="_blank" rel="noopener">深度优先搜索与广度优先搜索</a></li><li><a href="http://driftcloudy.iteye.com/blog/782873" target="_blank" rel="noopener">树的深度优先与广度优先遍历</a></li></ul><h4 id="排序算法及对应的时间复杂度和空间复杂度"><a href="#排序算法及对应的时间复杂度和空间复杂度" class="headerlink" title="排序算法及对应的时间复杂度和空间复杂度"></a>排序算法及对应的时间复杂度和空间复杂度</h4><p>推荐看书籍复习！可参考文章</p><ul><li><a href="http://www.cnblogs.com/liuling/p/2013-7-24-01.html" target="_blank" rel="noopener">各种排序算法的分析及java实现</a></li><li><a href="http://blog.csdn.net/cyuyanenen/article/details/51514443" target="_blank" rel="noopener">常用排序算法的时间复杂度和空间复杂度</a></li><li><a href="http://blog.csdn.net/whuslei/article/details/6442755" target="_blank" rel="noopener">常见排序算法小结</a></li></ul><h4 id="排序算法编码实现"><a href="#排序算法编码实现" class="headerlink" title="排序算法编码实现"></a>排序算法编码实现</h4><p>参考</p><ul><li><a href="http://www.cnblogs.com/liuling/p/2013-7-24-01.html" target="_blank" rel="noopener">各种排序算法的分析及java实现</a></li></ul><h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4><p>参考</p><ul><li><a href="http://sanwen8.cn/p/142Wbu5.html" target="_blank" rel="noopener">七大查找算法</a></li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>参考</p><ul><li><a href="http://www.cnblogs.com/syxchina/archive/2011/03/02/2197251.html" target="_blank" rel="noopener">B树、B-树、B+树、B*树都是什么</a></li></ul><h4 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h4><p>推荐阅读数据复习！参考</p><ul><li><a href="http://www.cnblogs.com/c-cloud/p/3224788.html" target="_blank" rel="noopener">【经典算法】——KMP，深入讲解next数组的求解</a></li></ul><h4 id="Hash-算法及常用的-Hash-算法"><a href="#Hash-算法及常用的-Hash-算法" class="headerlink" title="Hash 算法及常用的 Hash 算法"></a>Hash 算法及常用的 Hash 算法</h4><p>参考</p><ul><li><a href="http://www.360doc.com/content/13/0409/14/10384031_277138819.shtml" target="_blank" rel="noopener">常见hash算法的原理</a></li></ul><h4 id="如何判断一个单链表是否有环"><a href="#如何判断一个单链表是否有环" class="headerlink" title="如何判断一个单链表是否有环"></a>如何判断一个单链表是否有环</h4><p>参考文章</p><ul><li><a href="http://www.jianshu.com/p/0e28d31600dd" target="_blank" rel="noopener">如何判断一个单链表是否有环？</a></li><li><a href="http://my.oschina.net/u/2391658/blog/693277?" target="_blank" rel="noopener">Java判断链表是否有环的两种实现方法</a></li></ul><h4 id="队列、栈、链表、树、堆、图"><a href="#队列、栈、链表、树、堆、图" class="headerlink" title="队列、栈、链表、树、堆、图"></a>队列、栈、链表、树、堆、图</h4><p>推荐阅读数据结构复习！</p><h4 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h4><p>参考</p><ul><li><a href="http://www.jianshu.com/p/03cfc1a721b8" target="_blank" rel="noopener">Linux常用操作命令</a></li></ul><h4 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/windrui/article/details/40046413" target="_blank" rel="noopener">linux系统下查看CPU、内存负载情况</a></li></ul><h4 id="Linux-下如何进行进程调度"><a href="#Linux-下如何进行进程调度" class="headerlink" title="Linux 下如何进行进程调度"></a>Linux 下如何进行进程调度</h4><p>推荐阅读书籍复习，参考文章</p><ul><li><a href="http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html" target="_blank" rel="noopener">Linux进程调度原理</a></li><li><a href="http://blog.csdn.net/rainharder/article/details/7975387" target="_blank" rel="noopener">Linux进程调度机制</a></li></ul><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><p>参考</p><ul><li><a href="http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html" target="_blank" rel="noopener">操作系统：死锁的产生、条件、和解锁</a></li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>参考</p><ul><li><a href="http://blog.sina.com.cn/s/blog_5e3604840100ddgq.html" target="_blank" rel="noopener">操作系统：死锁的产生、条件、和解锁</a></li></ul><h4 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h4><p>参考</p><ul><li><a href="http://www.360doc.com/content/12/0712/20/5287961_223855037.shtml" target="_blank" rel="noopener">数据库三大范式的理解</a></li></ul><h4 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a>数据库事务隔离级别</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="noopener">数据库事务隔离级别</a></li></ul><h4 id="数据库连接池的原理"><a href="#数据库连接池的原理" class="headerlink" title="数据库连接池的原理"></a>数据库连接池的原理</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/shuaihj/article/details/14223015" target="_blank" rel="noopener">谈谈数据库连接池的原理</a></li></ul><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>参考</p><ul><li><a href="http://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></li></ul><h4 id="如何实现不同数据库的数据查询分页"><a href="#如何实现不同数据库的数据查询分页" class="headerlink" title="如何实现不同数据库的数据查询分页"></a>如何实现不同数据库的数据查询分页</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/yztezhl/article/details/20489387" target="_blank" rel="noopener">不同数据库的分页查询实现方法总结</a></li></ul><h4 id="SQL-注入的原理，如何预防"><a href="#SQL-注入的原理，如何预防" class="headerlink" title="SQL 注入的原理，如何预防"></a>SQL 注入的原理，如何预防</h4><p>参考</p><ul><li><a href="https://www.aliyun.com/zixun/content/3_15_245099.html" target="_blank" rel="noopener">谈谈六个防止SQL注入式攻击的建议</a></li></ul><h4 id="数据库索引的实现-B-树介绍、和-B-树、R-树区别"><a href="#数据库索引的实现-B-树介绍、和-B-树、R-树区别" class="headerlink" title="数据库索引的实现( B+ 树介绍、和 B 树、R 树区别 )"></a>数据库索引的实现( B+ 树介绍、和 B 树、R 树区别 )</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="noopener">数据库索引的实现原理</a></li><li><a href="http://www.xuebuyuan.com/2216918.html" target="_blank" rel="noopener">由浅入深理解数据库中索引的底层实现</a></li></ul><h4 id="SQL-性能优化"><a href="#SQL-性能优化" class="headerlink" title="SQL 性能优化"></a>SQL 性能优化</h4><p>参考文章</p><ul><li><a href="http://database.51cto.com/art/200904/118526.htm" target="_blank" rel="noopener">高手详解SQL性能优化十条经验</a></li><li><a href="http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html" target="_blank" rel="noopener">Oracle SQL性能优化</a></li></ul><h4 id="数据库索引的优缺点以及什么时候数据库索引失效"><a href="#数据库索引的优缺点以及什么时候数据库索引失效" class="headerlink" title="数据库索引的优缺点以及什么时候数据库索引失效"></a>数据库索引的优缺点以及什么时候数据库索引失效</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/mxmbk/articles/5226344.html" target="_blank" rel="noopener">数据库索引的作用和优点缺点以及索引的11中用法</a></li><li><a href="http://www.cnblogs.com/simplefrog/archive/2012/07/15/2592527.html" target="_blank" rel="noopener">正确高效使用数据库不可不知的索引失效问题</a></li><li><a href="http://www.open-open.com/lib/view/open1418476492792.html" target="_blank" rel="noopener">SQL优化避免索引失效</a></li><li><a href="http://blog.csdn.net/colin_liu2009/article/details/7301089" target="_blank" rel="noopener">索引失效原因总结</a></li><li><a href="http://www.cnblogs.com/hongfei/archive/2012/10/20/2732589.html" target="_blank" rel="noopener">哪些情况下索引会失效？</a></li></ul><h4 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/hechurui/article/details/49508735" target="_blank" rel="noopener">Redis五种数据类型介绍</a></li></ul><h4 id="OSI-七层模型以及-TCP-IP-四层模型"><a href="#OSI-七层模型以及-TCP-IP-四层模型" class="headerlink" title="OSI 七层模型以及 TCP/IP 四层模型"></a>OSI 七层模型以及 TCP/IP 四层模型</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/sprintfwater/article/details/8751453" target="_blank" rel="noopener">OSI七层协议模型和TCP/IP四层模型比较</a></li><li><a href="http://www.cnblogs.com/commanderzhu/p/4821555.html" target="_blank" rel="noopener">OSI七层模型及TCP/IP四层模型</a></li><li><a href="http://blog.csdn.net/superjunjin/article/details/7841099" target="_blank" rel="noopener">TCP/IP四层模型和OSI七层模型的概念</a></li></ul><h4 id="HTTP-和-HTTPS-区别"><a href="#HTTP-和-HTTPS-区别" class="headerlink" title="HTTP 和 HTTPS 区别"></a>HTTP 和 HTTPS 区别</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/mingli198611/article/details/8055261" target="_blank" rel="noopener">HTTP和HTTPS详解</a></li><li><a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></li></ul><h4 id="HTTP-报文内容"><a href="#HTTP-报文内容" class="headerlink" title="HTTP 报文内容"></a>HTTP 报文内容</h4><p>参考文章</p><ul><li><a href="https://yq.aliyun.com/articles/44675" target="_blank" rel="noopener">HTTP请求报文和HTTP响应报文</a></li><li><a href="http://www.cnblogs.com/klguang/p/4618526.html" target="_blank" rel="noopener">http报文详解</a></li><li><a href="http://my.oschina.net/orgsky/blog/387759" target="_blank" rel="noopener">HTTP请求报文解剖</a></li></ul><h4 id="get-提交和post-提交的区别"><a href="#get-提交和post-提交的区别" class="headerlink" title="get 提交和post 提交的区别"></a>get 提交和post 提交的区别</h4><p>参考文章</p><ul><li><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">浅谈HTTP中Get与Post的区别</a></li><li><a href="http://www.jellythink.com/archives/806" target="_blank" rel="noopener">详解HTTP中GET和POST的区别</a></li></ul><h4 id="get-提交是否有字节限制，如果有是在哪限制的"><a href="#get-提交是否有字节限制，如果有是在哪限制的" class="headerlink" title="get 提交是否有字节限制，如果有是在哪限制的"></a>get 提交是否有字节限制，如果有是在哪限制的</h4><p>参考</p><ul><li><a href="http://www.jellythink.com/archives/806" target="_blank" rel="noopener">详解HTTP中GET和POST的区别</a></li></ul><h4 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h4><p>阅读</p><ul><li><a href="http://www.jianshu.com/p/f7d1010fa603" target="_blank" rel="noopener">TCP的三次握手和四次挥手</a></li></ul><h4 id="Session-和-Cookie的区别"><a href="#Session-和-Cookie的区别" class="headerlink" title="Session 和 Cookie的区别"></a>Session 和 Cookie的区别</h4><p>参考</p><ul><li><a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="noopener">cookie 和session 的区别详解</a></li></ul><h4 id="HTTP-请求中-Session-实现原理"><a href="#HTTP-请求中-Session-实现原理" class="headerlink" title="HTTP 请求中 Session 实现原理"></a>HTTP 请求中 Session 实现原理</h4><p>参考</p><ul><li><a href="http://blog.csdn.net/zhq426/article/details/2992488" target="_blank" rel="noopener">Session实现原理</a></li></ul><h4 id="redirect-与-forward-区别"><a href="#redirect-与-forward-区别" class="headerlink" title="redirect 与 forward 区别"></a>redirect 与 forward 区别</h4><p>参考</p><ul><li><a href="http://www.cnblogs.com/wxgblogs/p/5602849.html" target="_blank" rel="noopener">forward和redirect的区别</a></li></ul><h4 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h4><p>参考</p><ul><li><a href="http://www.cnblogs.com/bizhu/archive/2012/05/12/2497493.html" target="_blank" rel="noopener">TCP和UDP的区别（转）</a></li></ul><h4 id="DDos-攻击及预防"><a href="#DDos-攻击及预防" class="headerlink" title="DDos 攻击及预防"></a>DDos 攻击及预防</h4><p>参考文章</p><ul><li><a href="http://blog.csdn.net/huwei2003/article/details/45476743" target="_blank" rel="noopener">DDoS的攻击原理与防御方法</a></li><li><a href="http://www.leiphone.com/news/201509/9zGlIDvLhwguqOtg.html" target="_blank" rel="noopener">漫画告诉你什么是DDoS攻击？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 秋招日志</title>
      <link href="/posts/%E7%A7%8B%E6%8B%9B%E6%97%A5%E5%BF%97/"/>
      <url>/posts/%E7%A7%8B%E6%8B%9B%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>公司</th><th>内推状态</th><th>校招状态</th><th>时间</th></tr></thead><tbody><tr><td>1</td><td>腾讯</td><td></td><td>已拒绝</td><td></td></tr><tr><td>2</td><td>阿里巴巴</td><td></td><td>已拒绝</td><td></td></tr><tr><td>3</td><td>京东</td><td></td><td>已拒绝</td><td></td></tr><tr><td>4</td><td>百度</td><td></td><td>已拒绝</td><td></td></tr><tr><td>5</td><td>网易</td><td>已拒绝</td><td>已拒绝</td><td></td></tr><tr><td>6</td><td>美团点评</td><td></td><td>已笔试</td><td></td></tr><tr><td>7</td><td>趋势科技</td><td>已拒绝</td><td></td><td></td></tr><tr><td>8</td><td>华为</td><td></td><td>已放弃</td><td></td></tr><tr><td>9</td><td>唯品会</td><td></td><td>已拒绝</td><td></td></tr><tr><td>10</td><td>好未来</td><td></td><td>已拒绝</td><td></td></tr><tr><td>11</td><td>完美世界</td><td></td><td>已笔试</td><td></td></tr><tr><td>12</td><td>小米</td><td></td><td>已笔试</td><td></td></tr><tr><td>13</td><td>搜狐</td><td>已笔试</td><td></td><td></td></tr><tr><td>14</td><td>新浪</td><td></td><td>已投递</td><td></td></tr><tr><td>15</td><td>搜狗</td><td>已笔试</td><td></td><td></td></tr><tr><td>16</td><td>亚马逊</td><td></td><td>已拒绝</td><td></td></tr><tr><td>17</td><td>4399</td><td></td><td>已笔试</td><td></td></tr><tr><td>18</td><td>爱奇艺</td><td></td><td>已投递</td><td></td></tr><tr><td>19</td><td>今日头条</td><td>已笔试</td><td>已笔试</td><td></td></tr><tr><td>20</td><td>滴滴</td><td>已拒绝</td><td>已笔试</td><td></td></tr><tr><td>21</td><td>链家</td><td>已拒绝</td><td>已笔试</td><td></td></tr><tr><td>22</td><td>搜狐畅游</td><td></td><td>已放弃</td><td></td></tr><tr><td>23</td><td>盛大</td><td></td><td>已放弃</td><td></td></tr><tr><td>24</td><td>去哪    儿</td><td>已签约</td><td></td><td></td></tr><tr><td>25</td><td>拼多多</td><td>以拒绝</td><td>已投递</td><td></td></tr><tr><td>26</td><td>苏宁</td><td>已拒绝</td><td></td><td></td></tr><tr><td>27</td><td>科大讯飞</td><td></td><td>已投递</td><td></td></tr><tr><td>28</td><td>三七互娱</td><td></td><td>已笔试</td><td></td></tr><tr><td>29</td><td>猿辅导</td><td>已投递</td><td></td><td></td></tr><tr><td>30</td><td>巨人网络</td><td></td><td>已笔试</td><td></td></tr><tr><td>31</td><td>猎豹移动</td><td></td><td>已笔试</td><td></td></tr><tr><td>32</td><td>欢聚时代</td><td></td><td>已笔试</td><td></td></tr><tr><td>33</td><td>银联</td><td>已投递</td><td></td><td></td></tr><tr><td>34</td><td>Face++</td><td></td><td>已投递</td><td></td></tr><tr><td>35</td><td>网龙</td><td></td><td>已笔试</td><td></td></tr><tr><td>36</td><td>中兴</td><td>已拒绝</td><td></td><td></td></tr><tr><td>37</td><td>360</td><td>已拒绝</td><td>已拒绝</td><td></td></tr><tr><td>38</td><td>商汤科技</td><td>已拒绝</td><td>已投递</td><td></td></tr><tr><td>39</td><td>招银网络</td><td></td><td>已拒绝</td><td></td></tr><tr><td>40</td><td>微策略</td><td></td><td>已笔试</td><td></td></tr><tr><td>41</td><td>思特沃克</td><td></td><td>已投递</td><td></td></tr><tr><td>42</td><td>金山云</td><td></td><td>已投递</td><td></td></tr><tr><td>43</td><td>招行信用</td><td></td><td>已放弃</td><td></td></tr><tr><td>44</td><td>多益网络</td><td>已拒绝</td><td></td><td></td></tr><tr><td>45</td><td>深信服</td><td></td><td>已放弃</td><td></td></tr><tr><td>46</td><td>艺龙</td><td></td><td>已拒绝</td><td></td></tr><tr><td>47</td><td>摩拜</td><td></td><td>已投递</td><td></td></tr><tr><td>48</td><td>涂鸦移动</td><td></td><td>已笔试</td><td></td></tr><tr><td>49</td><td>贝贝</td><td></td><td>已笔试</td><td></td></tr><tr><td>50</td><td>美图</td><td></td><td>已拒绝</td><td></td></tr><tr><td>51</td><td>百度外卖</td><td>已投递</td><td>已放弃</td><td></td></tr><tr><td>52</td><td>第四范式</td><td></td><td>已投递</td><td></td></tr><tr><td>53</td><td>酷狗音乐</td><td></td><td>已笔试</td><td></td></tr><tr><td>54</td><td>饿了么</td><td></td><td>已拒绝</td><td></td></tr><tr><td>55</td><td>平安科技</td><td>已投递</td><td></td><td></td></tr><tr><td>56</td><td>同花顺</td><td></td><td>已放弃</td><td></td></tr><tr><td>57</td><td>虹软</td><td></td><td>已投递</td><td></td></tr><tr><td>58</td><td>作业帮</td><td></td><td>已放弃</td><td></td></tr><tr><td>59</td><td>三星</td><td></td><td>已投递</td><td></td></tr><tr><td>60</td><td>便利蜂</td><td></td><td>已投递</td><td></td></tr><tr><td>61</td><td>VMWare</td><td></td><td>已笔试</td><td></td></tr><tr><td>62</td><td>迅雷</td><td></td><td>已拒绝</td><td></td></tr><tr><td>63</td><td>微软</td><td></td><td>已笔试</td><td></td></tr><tr><td>64</td><td>绿盟</td><td></td><td>已笔试</td><td></td></tr><tr><td>65</td><td>新东方</td><td></td><td>已投递</td><td></td></tr><tr><td>66</td><td>IBM</td><td></td><td>已投递</td><td></td></tr><tr><td>67</td><td>神州信息</td><td></td><td>已投递</td><td></td></tr><tr><td>68</td><td>人人</td><td></td><td>已放弃</td><td></td></tr><tr><td>69</td><td>联想</td><td></td><td>已笔试</td><td></td></tr><tr><td>70</td><td>浪潮</td><td></td><td>已放弃</td><td></td></tr><tr><td>71</td><td>融360</td><td></td><td>已投递</td><td></td></tr><tr><td>72</td><td>陌陌</td><td></td><td>已笔试</td><td></td></tr><tr><td>73</td><td>Hulu</td><td></td><td>已拒绝</td><td></td></tr><tr><td>74</td><td>Bilibili</td><td></td><td>已放弃</td><td></td></tr><tr><td>75</td><td>展讯</td><td></td><td>已笔试</td><td></td></tr><tr><td>76</td><td>金山WPS</td><td></td><td>已放弃</td><td></td></tr><tr><td>77</td><td>vivo</td><td></td><td>已投递</td><td></td></tr><tr><td>78</td><td>Intel</td><td></td><td>已笔试</td><td></td></tr><tr><td>79</td><td>58到家</td><td></td><td>已投递</td><td></td></tr><tr><td>80</td><td>HPE</td><td></td><td>已放弃</td><td></td></tr><tr><td>81</td><td>知乎</td><td></td><td>已投递</td><td></td></tr><tr><td>82</td><td>国家电网</td><td></td><td>已投递</td><td></td></tr><tr><td>83</td><td>酷家乐</td><td></td><td>已拒绝</td><td></td></tr><tr><td>84</td><td>58集团</td><td></td><td>已笔试</td><td></td></tr><tr><td>85</td><td>51信用卡</td><td></td><td>已放弃</td><td></td></tr><tr><td>86</td><td>爱立信</td><td></td><td>已投递</td><td></td></tr><tr><td>87</td><td>美丽联合</td><td></td><td>已放弃</td><td></td></tr><tr><td>88</td><td>顺丰</td><td></td><td>待面试</td><td></td></tr><tr><td>89</td><td>小红书</td><td></td><td>已拒绝</td><td></td></tr><tr><td>90</td><td>创新工场</td><td></td><td>已投递</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团点评2018校招在线考试-编程题一</title>
      <link href="/posts/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>序列中任意个连续的元素组成的子序列称为该序列的子串。现在给你一个序列P和一个整数K，询问元素和是K的倍数的子串的最大长度。比如序列[1,2,3,4,5]，给定的整数 K 为 5，其中满足条件的子串为{5}、{2,3}、{1,2,3,4}、{1,2,3,4,5}，那么答案就为 5，因为最长的子串为{1,2,3,4,5}；如果满足条件的子串不存在，就输出 0。</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一含一个整数N, 1 ≤ N ≤ 105 。第二行包含 N 个整数pi ，pi 表示序列 P 第 i 个元素的值。0 ≤ pi ≤ 105 。第三行包含一个整数 K， 1 ≤ K ≤ 105 。</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>只有一行,输出元素和是K的倍数的子串的最大长度。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>51 2 3 4 5562 1 7 7 7 74</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>55</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>求出 p1…pi(1 &lt;= i &lt;= n)的和,并 mod k,</li><li>对于每个余数 s(0 &lt;= i &lt; k), 求出其第一次出现位置,求出其最后一次出现的位置,两者之间元素之和即能整除 k</li><li>所求即两者之差中的最大值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,arr[<span class="number">100001</span>],k,first[<span class="number">100001</span>],last[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,maxlen;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        first[<span class="number">0</span>]=last[<span class="number">0</span>]=arr[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(i)</span><br><span class="line">                arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">            first[i]=last[i]=<span class="number">-1</span>;</span><br><span class="line">        maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i]%=k;</span><br><span class="line">            <span class="keyword">if</span>(first[arr[i]]&lt;<span class="number">0</span>)</span><br><span class="line">                first[arr[i]]=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxlen=max(maxlen,i-first[i]);</span><br><span class="line">        &#125;last[<span class="number">0</span>]-first[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;maxlen&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 美团点评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 美团点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团点评2018校招在线考试-编程题二</title>
      <link href="/posts/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842018%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-改考卷"><a href="#题目-改考卷" class="headerlink" title="题目:改考卷"></a>题目:改考卷</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>在上小学的时候，我们经常碰到这样的事：    考完试后老师懒得改试卷，于是让我们同桌相互交换试卷后为对方批改。但是后来老师发现这样作容易出现作弊，于是他想了一个新办法。老师将同学分成了 n 个组，其中编号为𝑖的组中有si 个人。然后老师会按某种顺序依次访问这些组。    对于他访问的第一个组，他会将这组内的所有试卷都收走，放置在桌上；对于他后续访问的每一个组，首先他会从桌上的试卷最上方拿出该组对应人数数量的试卷，随机分配给该组每个人一张试卷让他们进行批改，而后再将这组学生自己考的试卷收走放置在桌面试卷的最下方。当他访问完所有的组后他会将桌面上剩余的所有试卷随机分配给他第一个访问的组的学生进行批改。    但他发现这种方法有时候也会出现问题：有可能在中途访问到某个组的时候桌面上的试卷不够分配给这组学生每人一张；也有可能最后会有学生分配到批改自己的试卷，而且这两种情况是否出现是与他访问每个组的顺序有关的。现在他想知道是否存在一种访问顺序能够使以上两种情况都不出现，顺利完成试卷批改呢？ </code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一个整数 n，表示学生组数。2 ≤ n ≤ 30第二行包含 n 个整数，s1 ,s2 ,…,sn ，分别表示每组学生的人数。1 ≤ si ≤ 10000</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>若存在一种访问顺序能使试卷顺利批改完成，输出 Yes，否则输出 No。</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>210 2042 3 3 1</code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>NoYes</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>把 s1…sn 按降序排列,不会出现第一种情况</li><li>若人数最多的一组的人数不比其他所有组的人数之和,则不会出现第二种情况</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,group[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;group[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(group,group+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            group[i]+=group[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(group[<span class="number">0</span>]&lt;(group[n<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 美团点评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 美团点评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计二进制数中1的个数</title>
      <link href="/posts/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/posts/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="循环减一按位与"><a href="#循环减一按位与" class="headerlink" title="循环减一按位与"></a>循环减一按位与</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>执行速度较快,易理解;</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>对于 n,若n不为 0,则进行以下循环,每进行一次循环,统计循环次数 c</li><li>将 n 与 (n-1) 的按位与赋值给 n</li><li>循环结束,循环次数 c 即为所求<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3>每次循环将消去二进制数 n 的一个最低位 1<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">++c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>代码简洁,理解稍难</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul><li><p>将整数 n 按二进制分为 m 组,每组包含 4 个二进制位</p></li><li><p>对于每组,计算 1 的个数 e</p></li><li><p>然后计算 e[1]-e[m] 的和 eSum</p><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3></li><li><p>e的计算</p><p>  假设按照从高到低的顺序,各二进制的值分别为 a,b,c,d,即,a为最高位,d为最低位<br>  设每组的值为 v,则 v=8<em>a+4</em>b+2<em>c+d<br>  设每组所含的1的个数为 e,则 e=a+b+c+d=(8</em>a+4<em>b+2</em>c+d)-(4<em>a+2</em>b+2<em>c)-(2</em>a+2*b)-a=v-v/2-v/4-v/8</p></li><li><p>eSum的计算</p><p>  使用公式 (2^p*x) mod (2^p-1)=x mod (2^p-1)<br>  计算出来的 eSum 是小于 2^p-1 的,所以需要适时的调整 p 的大小</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x=n-((n&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x7777777777777777</span>)</span><br><span class="line">        -((n&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x3333333333333333</span>)</span><br><span class="line">        -((n&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x1111111111111111</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)((x+(x&gt;&gt;<span class="number">4</span>))&amp;<span class="number">0x0f0f0f0f0f0f0f0f</span>)%<span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="C-bitset对象"><a href="#C-bitset对象" class="headerlink" title="C++ bitset对象"></a>C++ bitset对象</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>使用最为简单,需要导入 bitset 头文件</p><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">64</span>&gt;(n).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>References : <a href="http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html" target="_blank" rel="noopener">算法-求二进制数中1的个数</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯2018校园招聘在线笔试模拟考-编程题</title>
      <link href="/posts/%E8%85%BE%E8%AE%AF2018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E6%A8%A1%E6%8B%9F%E8%80%83-%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/posts/%E8%85%BE%E8%AE%AF2018%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E6%A8%A1%E6%8B%9F%E8%80%83-%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>对于一颗满二叉排序树深度为 K,结点数为 2^K-1;节点值为 1 至 (2^K-1).给出任意三个节点的值,输出包含该三个节点的最小子树的根节点值.</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>输入包括一行,第一个数为树的深读 K后三个数为任意三个节点值</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>输出包含一行,一个数字,为包含该三个节点的最小子树的根节点值</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>4 10 15 13  </code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>12</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li>二分查找判断当前根节点值 root 与给定三节点中最大与最小值的关系</li><li>若 root 大于最大值,说明三点在 root 左侧,root 赋值为左子树</li><li>若 root 小于最小值,说明三点在 root 左侧,root 赋值为右子树</li><li>若 root 大于等于最小值,小于等于最大值,root 即为所求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,x[<span class="number">3</span>],r,d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x[<span class="number">0</span>]&gt;&gt;x[<span class="number">1</span>]&gt;&gt;x[<span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        sort(x,x+<span class="number">3</span>);</span><br><span class="line">        r=<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>),d=k<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(r&lt;=x[<span class="number">2</span>]&amp;&amp;r&gt;=x[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r&gt;x[<span class="number">2</span>]) r-=(<span class="number">1</span>&lt;&lt;d);</span><br><span class="line">            <span class="keyword">else</span> r+=(<span class="number">1</span>&lt;&lt;d);</span><br><span class="line">            --d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 腾讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 二分法 </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 二叉排序树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜狐集团2018秋季校招笔试题（技术类）-编程题二</title>
      <link href="/posts/%E6%90%9C%E7%8B%90%E9%9B%86%E5%9B%A22018%E7%A7%8B%E5%AD%A3%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%8A%80%E6%9C%AF%E7%B1%BB%EF%BC%89-%20%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/"/>
      <url>/posts/%E6%90%9C%E7%8B%90%E9%9B%86%E5%9B%A22018%E7%A7%8B%E5%AD%A3%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%8A%80%E6%9C%AF%E7%B1%BB%EF%BC%89-%20%E7%BC%96%E7%A8%8B%E9%A2%98%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>工厂生产的产品包装在相同高度 h,尺寸为1*1,2*2,3*3,4*4,5*5,6*6 的方形包装中.这些产品始终以与产品高度相同的尺寸为 6*6 的包裹交付给客户.因为邮费很贵,所以工厂要想方设法地减少每个订单运送时的包裹数量.他们很需要有一个好的程序员帮他们解决这个问题从而节省费用.现在这个程序由你来设计.</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>输入文件包括几行,每一行代表一个订单.每个订单里的一行包括六个整数,中间用空格隔开,分别为 1*1 至 6*6 这六种产品的数量.输入文件将以 6 个 0 组成一行结尾.</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>除了输入的最后一行 6 个 0 以外,输入文件里每一行对应着输出文件一行,每一行输出一个整数代表对应订单所需的最小包裹数.</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>0 0 4 0 0 17 5 1 0 0 00 0 0 0 0 0  </code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>21</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="直接求解"><a href="#直接求解" class="headerlink" title="直接求解"></a>直接求解</h3><p>由于数据量不大,直接求解</p><ul><li>1 个 6*6 的产品单独组成一个包裹</li><li>1 个 5<em>5 的产品可以和 11 个 1</em>1 的产品组成一个包裹</li><li>1 个 4<em>4 的产品可以和 2</em>2 或 1*1 的产品组成一个包裹</li><li>4 个 3<em>3 的产品单独组成一个包裹,若 3</em>3 的产品不足 4 个,则可以和 2<em>2 的产品或者 1</em>1 的产品或者两者混合组成一个包裹</li><li>9 个 2<em>2 的产品单独组成一个包裹,若 2</em>2 的产品不足9个,则可以和1*1的产品组成一个包裹</li><li>36 个 1*1 的产品单独组成一个包裹</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prod[<span class="number">6</span>],c,rest2[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;prod[<span class="number">0</span>],&amp;prod[<span class="number">1</span>],&amp;prod[<span class="number">2</span>],&amp;prod[<span class="number">3</span>],&amp;prod[<span class="number">4</span>],&amp;prod[<span class="number">5</span>]);</span><br><span class="line">        <span class="keyword">if</span>(prod[<span class="number">0</span>]|prod[<span class="number">1</span>]|prod[<span class="number">2</span>]|prod[<span class="number">3</span>]|prod[<span class="number">4</span>]|prod[<span class="number">5</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            c=<span class="number">0</span>;</span><br><span class="line">            c+=prod[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"6 "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            c+=prod[<span class="number">4</span>];</span><br><span class="line">            prod[<span class="number">0</span>]-=min(prod[<span class="number">0</span>],prod[<span class="number">4</span>]*<span class="number">11</span>);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"5 "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            c+=prod[<span class="number">3</span>];</span><br><span class="line">            prod[<span class="number">0</span>]-=min(prod[<span class="number">0</span>],max(<span class="number">0</span>,prod[<span class="number">3</span>]*<span class="number">5</span>-prod[<span class="number">1</span>])*<span class="number">4</span>);</span><br><span class="line">            prod[<span class="number">1</span>]-=min(prod[<span class="number">1</span>],prod[<span class="number">3</span>]*<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"4 "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            t=prod[<span class="number">2</span>]/<span class="number">4</span>;</span><br><span class="line">            prod[<span class="number">2</span>]-=<span class="number">4</span>*t;</span><br><span class="line">            c+=t;</span><br><span class="line">            <span class="keyword">if</span>(prod[<span class="number">2</span>])++c;</span><br><span class="line">            prod[<span class="number">0</span>]-=min(prod[<span class="number">0</span>],<span class="number">36</span><span class="number">-9</span>*prod[<span class="number">2</span>]<span class="number">-4</span>*min(rest2[prod[<span class="number">2</span>]],prod[<span class="number">1</span>]));</span><br><span class="line">            prod[<span class="number">1</span>]-=min(rest2[prod[<span class="number">2</span>]],prod[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"3 "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            t=prod[<span class="number">1</span>]/<span class="number">9</span>;</span><br><span class="line">            prod[<span class="number">1</span>]-=<span class="number">9</span>*t;</span><br><span class="line">            c+=t;</span><br><span class="line">            <span class="keyword">if</span>(prod[<span class="number">1</span>])++c;</span><br><span class="line">            prod[<span class="number">0</span>]-=min(prod[<span class="number">0</span>],<span class="number">36</span><span class="number">-4</span>*prod[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"2 "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            c+=prod[<span class="number">0</span>]/<span class="number">36</span>;</span><br><span class="line">            <span class="keyword">if</span>(prod[<span class="number">0</span>])++c;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 搜狐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 搜狐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜狐集团2018秋季校招笔试题（技术类）-编程题一</title>
      <link href="/posts/%E6%90%9C%E7%8B%90%E9%9B%86%E5%9B%A22018%E7%A7%8B%E5%AD%A3%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%8A%80%E6%9C%AF%E7%B1%BB%EF%BC%89-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E6%90%9C%E7%8B%90%E9%9B%86%E5%9B%A22018%E7%A7%8B%E5%AD%A3%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%8A%80%E6%9C%AF%E7%B1%BB%EF%BC%89-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>Kolakoski 序列是个随机生成的无限序列.例如,当给定的整数组为 [1,2] 时,Kolakoski 序列是这样的:[1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,...]如果我们将相邻的相同的数字分成一组,那么将会得到:[[1],[2,2],[1,1],[2],[1],[2,2],[1],[2,2],[1,1],[2],[1,1],[2,2],[1],[2],[1,1],[2],[1],[2,2],[1,1],...]可以看出,每组数字交替由 1,2 组成.接下来对每个分组求它的长度,得到:[1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,...]可以看出,经过上述变换后,数列保持不变.对于其他给定的整数组,同样可以用类似的方法构造 Kolakoski 序列,例如给定整数组 [2,3] 时:[2,2,3,3,2,2,2,3,3,3,2,2,3,3,2,2,3,3,3,2,2,2,3,3,3,2,2,3,3,...]给定整数组 [2,1,3,1] 时,构造得到如下:[2,2,1,1,3,1,2,2,2,1,3,3,1,1,2,2,1,3,3,3,1,1,1,2,1,3,3,1,1,...]</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>输入由两行组成,第一行包括两个正整数 n,m第二行包括 m 个正整数 a[]数据规模与限制:0 &lt; n &lt; 100001 &lt; m&lt; 10000 &lt; a[i] &lt; 1000a[i] 不等于 a[i+1]a[0] 不等于 a[m-1]</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>每行只有一个数字,共 n 行整数组 a 生成的 Kolakoski 序列的前 n 项</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>30 42 1 3 1  </code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>221131222133112213331112133112</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>i 表示当前正在生成的分组</li><li>j 表示已生成的 Kolakoski 序列的个数</li><li>k 表示生成当前分组所用的整数在 a[] 中的位置</li><li>若 i=j,说明没有生成第 i 组的长度,则需要生成的 i 组的长度为 a[k]</li><li>若 i&lt;j,说明已经生成第 i 组长度,则需要生成的 i 组的长度 b[j]</li><li>循环生成第 i 组</li><li>若 j&gt;=n 说明已生成完毕</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],n,m,Kolakoski[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=j=k=<span class="number">0</span>;j&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">                t=Kolakoski[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t=a[k];</span><br><span class="line">            <span class="keyword">while</span>(t&gt;<span class="number">0</span>&amp;&amp;j&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                Kolakoski[j]=a[k];</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;Kolakoski[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                --t,++j;</span><br><span class="line">            &#125;</span><br><span class="line">            k=(k+<span class="number">1</span>)%m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 搜狐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 搜狐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统下搭建Hexo个人博客</title>
      <link href="/posts/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/posts/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li></ul><p>直接单击链接进入下载最新版的 Git 和 Node.js 安装包,下载完毕之后安装</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在 CMD 或 PoweShell <font color="skyblue">( 建议在管理员权限下打开,下同 )</font>中键入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 CMD 或 PoweShell 中依次键入以下三条命令<font color="orange">( <code>&lt;folder&gt;</code> 替换为网站文件夹路径 )</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化完成后，指定文件夹的目录如下：</p><pre><code>....._config.yml....package.json....scaffolds....source.  ...._drafts.  ...._posts....themes</code></pre><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。</p><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模版 文件夹。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题 文件夹。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>网站配置文件为Hexo工作目录下的_config.yml文件<br><font color="skyblue">( * 为必填选项,其余按需更改 )</font></p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>网站标题</td></tr><tr><td>subtitle</td><td>网站副标题</td></tr><tr><td>description</td><td>网站描述</td></tr><tr><td>author</td><td>您的名字</td></tr><tr><td>language</td><td>网站使用的语言</td></tr><tr><td>timezone</td><td>网站时区</td></tr><tr><td>### 网址</td><td></td></tr><tr><td>参数</td><td>描述</td></tr><tr><td>—</td><td>—</td></tr><tr><td>*url</td><td>网址</td></tr><tr><td>*root</td><td>网站根目录</td></tr><tr><td>permalink</td><td>文章的永久链接格式</td></tr><tr><td>permalink_defaults</td><td>永久链接中各部分的默认值</td></tr><tr><td><font color="skyblue">如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</font></td><td></td></tr><tr><td>### 目录</td><td></td></tr><tr><td>参数</td><td>描述</td></tr><tr><td>—</td><td>—</td></tr><tr><td>source_dir</td><td>资源文件夹，这个文件夹用来存放内容</td></tr><tr><td>public_dir</td><td>公共文件夹，这个文件夹用于存放生成的站点文件</td></tr><tr><td>tag_dir</td><td>标签文件夹</td></tr><tr><td>archive_dir</td><td>归档文件夹</td></tr><tr><td>category_dir</td><td>分类文件夹</td></tr><tr><td>code_dir</td><td>Include code 文件夹</td></tr><tr><td>i18n_dir</td><td>国际化（i18n）文件夹</td></tr><tr><td>skip_render</td><td>跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td></tr></tbody></table><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>new_post_name</td><td>新文章的文件名称</td><td>:title.md</td></tr><tr><td>default_layout</td><td>预设布局</td><td>post</td></tr><tr><td>auto_spacing</td><td>在中文和英文之间加入空格</td><td>false</td></tr><tr><td>titlecase</td><td>把标题转换为 title case</td><td>false</td></tr><tr><td>external_link</td><td>在新标签中打开链接</td><td>true</td></tr><tr><td>filename_case</td><td>把文件名称转换为小写或大写</td><td>0</td></tr><tr><td>render_drafts</td><td>显示草稿</td><td>false</td></tr><tr><td>post_asset_folder</td><td>启动 Asset 文件夹</td><td>false</td></tr><tr><td>relative_link</td><td>把链接改为与根目录的相对位址</td><td>false</td></tr><tr><td>future</td><td>显示未来的文章</td><td>true</td></tr><tr><td>highlight</td><td>代码块的设置</td><td></td></tr></tbody></table><h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>default_category</td><td>默认分类</td><td>uncategorized</td></tr><tr><td>category_map</td><td>分类别名</td><td></td></tr><tr><td>tag_map</td><td>标签别名</td><td></td></tr><tr><td>### 日期 / 时间格式</td><td></td><td></td></tr><tr><td>参数</td><td>描述</td><td>默认值</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>date_format</td><td>日期格式</td><td>YYYY-MM-DD</td></tr><tr><td>time_format</td><td>时间格式</td><td>H:mm:ss</td></tr><tr><td>### 分页</td><td></td><td></td></tr><tr><td>参数</td><td>描述</td><td>默认值</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>per_page</td><td>每页显示的文章量(0 = 关闭分页功能)</td><td>10</td></tr><tr><td>pagination_dir    分页目录</td><td>page</td><td></td></tr><tr><td>### 扩展</td><td></td><td></td></tr><tr><td>参数</td><td>描述</td><td></td></tr><tr><td>—</td><td>—</td><td></td></tr><tr><td>theme</td><td>当前主题名称。值为false时禁用主题</td><td></td></tr><tr><td>deploy</td><td>部署部分的设置</td><td></td></tr><tr><td>## 命令</td><td></td><td></td></tr><tr><td><font color="skyblue">( * 常用命令 )</font></td><td></td><td></td></tr><tr><td>### init</td><td></td><td></td></tr><tr><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure></td><td></td><td></td></tr></tbody></table><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate *"></a>generate *</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish *"></a>publish *</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server *"></a>server *</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, –port</td><td>重设端口</td></tr><tr><td>-s, –static</td><td>只使用静态文件</td></tr><tr><td>-l, –log</td><td>启动日记记录，使用覆盖记录格式</td></tr><tr><td>### deploy *</td><td></td></tr><tr><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></td><td></td></tr></tbody></table><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g, –generate</td><td>部署之前预先生成静态文件</td></tr><tr><td>该命令可以简写为：</td><td></td></tr><tr><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></td><td></td></tr></tbody></table><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hexo render &lt;file1&gt; [file2] ...</span><br><span class="line">```bash</span><br><span class="line">渲染文件。</span><br><span class="line"></span><br><span class="line">|参数|描述|</span><br><span class="line">|---|---|</span><br><span class="line">|-o, --output|设置输出路径|</span><br><span class="line"><span class="comment">### migrate</span></span><br><span class="line">```bash</span><br><span class="line">hexo migrate &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统 迁移内容。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --safe</span><br></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --debug</span><br></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --silent</span><br></pre></td></tr></table></figure><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --config custom.yml</span><br></pre></td></tr></table></figure><p>自定义配置文件的路径，执行后将不再使用 _config.yml。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --draft</span><br></pre></td></tr></table></figure><p>显示 source/_drafts 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p><hr><p>Reference : <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Docs</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴2018届应届生招聘研发工程师CC++考试-编程题一</title>
      <link href="/posts/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B42018%E5%B1%8A%E5%BA%94%E5%B1%8A%E7%94%9F%E6%8B%9B%E8%81%98%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88CC++%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/"/>
      <url>/posts/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B42018%E5%B1%8A%E5%BA%94%E5%B1%8A%E7%94%9F%E6%8B%9B%E8%81%98%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88CC++%E8%80%83%E8%AF%95-%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>给定一个字符串  S 和有效单词的字典D，请确定可以插入到 S中的最小空格数，使得最终的字符串完全由D中的有效单词组成，并输出解。    如果没有解则应该输出 n/a    </code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><pre><code>第一行为字符串 S,第二行为词典单词数目 n,接下来 n行,每行为一个单词  </code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>只有一行,为插入最少空格后的字符串</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><pre><code>ilikealibaba6ilikealilibababaalibaba  </code></pre><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><pre><code>i like alibaba</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li>深搜所有符合要求的解,过程剪枝</li><li>选择最优解输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> newStr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mincut</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; dict,<span class="keyword">int</span> s,<span class="built_in">string</span> sstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s==str.length()&amp;&amp;sstr.length()&lt;newStr.length())</span><br><span class="line">&#123;</span><br><span class="line">    newStr=sstr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=dict.begin();it!=dict.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> t=*it;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t.length();++i)</span><br><span class="line">        <span class="keyword">if</span>(t[i]!=str[i+s])<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==t.length()&amp;&amp;s+i&lt;=str.length())</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(s) t=<span class="string">" "</span>+t;</span><br><span class="line">        mincut(str,dict,s+i,sstr+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> strS;</span><br><span class="line"><span class="built_in">string</span> dictStr;</span><br><span class="line"><span class="keyword">int</span> nDict;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; dict;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;strS;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;nDict;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nDict; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;dictStr;</span><br><span class="line">    dict.insert(dictStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newStr=strS+strS;</span><br><span class="line"></span><br><span class="line">mincut(strS, dict,<span class="number">0</span>,<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(newStr.length())</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;newStr;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n/a"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><ul><li>把字典按长度降序排序</li><li>匹配区间为 (s, e)</li><li>若 s==e ,则匹配成功,返回 true</li><li>在区间 (s, e) 内中匹配最长单词所在位置</li><li>每找到一个位置 pos ,则根据这个单词把区间 (s, e) 分为 (s, pos).(pos, pos+dict[i].length).(pos+dict[i].length, e) 三部分</li><li>对 前.后 两部分进行同样的操作</li><li>若 前.后 两部分匹配成功,则此区间匹配成功,返回 true</li><li>若匹配不成功,则寻找下个位置</li><li>若无下个位置则匹配次长单词</li><li>若没有匹配成功,则返回 false</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.length()&gt;s2.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;newStr;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mincut</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==e)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dict.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos=s;</span><br><span class="line">        <span class="keyword">while</span>(pos+dict[i].length()&lt;=e&amp;&amp;(pos=str.find(dict[i],pos))!=<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            newStr[pos]=i;</span><br><span class="line">            <span class="keyword">if</span>(mincut(str,dict,s,pos)&amp;&amp;mincut(str,dict,pos+dict[i].length(),e))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            newStr.erase(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strS;</span><br><span class="line">    <span class="keyword">int</span> nDict;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;strS;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;nDict;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dict(nDict);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nDict; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;dict[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(dict.begin(),dict.end(),comp);</span><br><span class="line">    <span class="keyword">if</span>(!mincut(strS, dict,<span class="number">0</span>,strS.length()))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"n/a"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dict[newStr[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">auto</span> it=newStr.begin();</span><br><span class="line">        <span class="keyword">for</span>(it++;it!=newStr.end();it++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;dict[it-&gt;second];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 阿里巴巴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 二分法 </tag>
            
            <tag> string </tag>
            
            <tag> DFS </tag>
            
            <tag> 阿里巴巴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hello-world/"/>
      <url>/posts/hello-world/</url>
      
        <content type="html"><![CDATA[<p>My first personal blog </p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>There is my thought in my mind</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>Not everything can be keep in mind, so there is convenience to review</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
